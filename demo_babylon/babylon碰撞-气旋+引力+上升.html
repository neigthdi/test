<!DOCTYPE html>
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Babylon.js sample code</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js">
		</script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		<style>
			html,
			body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>
	</head>

	<body>
		<div id='fps'
			style="position: absolute;background: #fff;left: 50%;top: 0;transform: translateX(-50%);pointer-events: none;">
		</div>
		<canvas id="renderCanvas"></canvas>
		<script>
			var canvas = document.getElementById('renderCanvas')
			var startRenderLoop = function(engine, canvas) {
				engine.runRenderLoop(function() {
					if (sceneToRender && sceneToRender.activeCamera) {
						sceneToRender.render()

						fps.innerHTML = engine.getFps().toFixed(2)
					}
				})
			}
			var engine = null
			var scene = null
			var sceneToRender = null
			var createDefaultEngine = function() {
				return new BABYLON.Engine(canvas, true, {
					preserveDrawingBuffer: true,
					stencil: true,
					disableWebGL2Support: false
				})
			}

			window.initFunction = async function() {

				var asyncEngineCreation = async function() {
					try {
						return createDefaultEngine()
					} catch (e) {
						console.log(
							'the available createEngine function failed. Creating the default engine instead'
						)
						return createDefaultEngine()
					}
				}

				window.engine = await asyncEngineCreation()
				if (!engine) throw 'engine should not be null.'
				startRenderLoop(engine, canvas)
				window.scene = createScene()
			}
			initFunction().then(() => {
				scene.then(returnedScene => {
					sceneToRender = returnedScene
				})
			})

			window.addEventListener('resize', function() {
				engine.resize()
			})

			const createScene = async function() {
				const scene = new BABYLON.Scene(engine)
				const camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 1.5, Math.PI / 2.2, 15, new BABYLON
					.Vector3(0, 0, 0))
				camera.upperBetaLimit = Math.PI / 2.2
				camera.attachControl(canvas, true)
				camera.setPosition(new BABYLON.Vector3(400, 400, 400))
				scene.registerBeforeRender(() => {})
				scene.debugLayer.show()





				// todo.....
				var light = new BABYLON.DirectionalLight('dir01', new BABYLON.Vector3(0, -1, -0.3), scene)
				light.position = new BABYLON.Vector3(20, 60, 30)
				scene.collesionEnabled = true
				scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin())
				camera.applyGravity = true
				var shadowGenerator = new BABYLON.ShadowGenerator(1024, light)
				shadowGenerator.getShadowMap().refreshRate = 60
				shadowGenerator.usePoissonSampling = true


				var ground = BABYLON.Mesh.CreateGround('ground', 50, 50, 1, scene)
				var groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene)
				groundMaterial.diffuseTexture = new BABYLON.Texture(
					'./babylon/textures/wood.jpg', scene)
				groundMaterial.diffuseTexture.uScale = 30
				groundMaterial.diffuseTexture.vScale = 30
				groundMaterial.specularColor = new BABYLON.Color3(.1, .1, .1)
				ground.receiveShadows = true
				ground.material = groundMaterial
				ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor
					.BoxImpostor, {
						mass: 0,
						restitution: 1
					}, scene)

				let physicsViewer = new BABYLON.Debug.PhysicsViewer()
				let physicsHelper = new BABYLON.PhysicsHelper(scene)


				// 用来展示碰撞的箱子
				let boxSize = 2,
					boxPadding = 4,
					minXY = -12,
					maxXY = 12,
					maxZ = 8

				const boxParams = {
					height: boxSize,
					width: boxSize,
					depth: boxSize
				}
				let boxImpostorParams = {
					mass: boxSize,
					restitution: 0,
					firction: 1
				}
				let boxMaterial = new BABYLON.StandardMaterial('boxMaterial')
				boxMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0)
				for (let x = minXY; x <= maxXY; x += boxSize + boxPadding) {
					for (let z = minXY; z < maxXY; z += boxSize + boxPadding) {
						for (let y = boxSize / 2; y <= maxZ; y += boxSize) {
							let boxName = `box:${x},${y},${z}`
							let box = BABYLON.MeshBuilder.CreateBox(boxName, boxParams, scene)
							box.position = new BABYLON.Vector3(x, y, z)
							box.material = boxMaterial
							box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor
								.BoxImpostor, boxImpostorParams, scene)
							physicsViewer.showImpostor(box.physicsImpostor)
						}
					}
				}

				let radius = 10
				let strength = 15
				let origins = [
					new BABYLON.Vector3(-8, 6, 1),
					new BABYLON.Vector3(0, 0, 0)
				]
				for (let i = 0; i < origins.length; i++) {
					let origin = origins[i]
					// 他这种爆轰也是需要遍历每一个来实现效果的

					// let event=physicsHelper.applyRadialExplosionImpulse(
					//     origin,
					//     {
					//         radius:radius,
					//         strength:strength,
					//         falloff:BABYLON.PhysicsRadialImpulseFalloff.Linear
					//     }
					// )


					// 引力场
					// let event=physicsHelper.gravitationalField(
					//     new BABYLON.Vector3(0,6,10)
					//     // 引力点
					//     ,{
					//         radius:radius,
					//         strength:strength,
					//         falloff:BABYLON.PhysicsRadialImpulseFalloff.Linear
					//     }
					// )

					// event.enable()
					// // 引力场事件需要单独启动
					// let eventData=event.getData()
					// let debugData=showExplosionDebug(eventData)

				}

				// 引力点
				// let event=physicsHelper.gravitationalField(
				//         new BABYLON.Vector3(0,6,10)
				//         // 引力点
				//         ,{
				//             radius:radius,
				//             strength:strength,
				//             falloff:BABYLON.PhysicsRadialImpulseFalloff.Linear
				//         }
				// )

				// event.enable()
				// setTimeout(()=>{
				//     // event.disable()
				// })
				// 引力场事件需要单独启动,但是这个不需要for循环。for外面调用就可以,但是为什么被吸到一起的东西会摇晃呢，难道这是一个循环事件么？这个晃是和力的大小有关系的，需要仔细调一下，就是
				// 试不出来那种吸过去固定住那种，猜是物体之间碰撞还是会有计算

				// 上升气流
				// let event=physicsHelper.updraft(
				//     new BABYLON.Vector3(0,0,0),
				//     {
				//         radius:100,
				//         strength:2,
				//         height:20,
				//     }
				// )
				// event.enable()


				// 气旋
				let event = physicsHelper.vortex(
					new BABYLON.Vector3(0, -8, 8), {
						radius: 20,
						strength: 30,
						// 力小了的话，可能物体会飞不起来
						height: 50
					}
				)

				// 如果高度太高的话，是会里面上升到最大高度，然后开始旋转，表现也是先聚在一起，然后像洗衣机一样，螺旋上升，直到把物体甩出去
				// 
				event.enable()
				let eventData = event.getData()
				let debugData = showExplosionDebug(eventData)






				return scene
			}

			// 辅助函数
			function showExplosionDebug(data) {

				var sphereMaterial = new BABYLON.StandardMaterial('sphereMaterial', scene)
				sphereMaterial.alpha = 0.5
				if (data.sphere) {
					data.sphere.isVisible = true
					data.sphere.material = sphereMaterial
				}

				return {
					sphere: data.sphere
				}
			}

			function hideExplosionDebug(debugData) {
				debugData.sphere.isVisible = false
			}
		</script>
	</body>

</html>