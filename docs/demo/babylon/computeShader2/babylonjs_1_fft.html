<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<title></title>
	</head>
	<body>
		<canvas id="shaderSea1" style="width: 800px;height: 800px;"></canvas>
		<script>
			let IMG_SIZE = 128
			// let data = new Uint8Array(IMG_SIZE * IMG_SIZE * 4)
			let PI = 3.14159265358979323846
			let TWO_PI = 2 * PI
			let G = -9.8
			let logN = Math.log2(IMG_SIZE)
			let half = IMG_SIZE / 2
			let uTime = 0.02
			let workGroupSizeRowX = IMG_SIZE
			let workGroupSizeRowY = 1
			let workGroupSizeColX = 1
			let workGroupSizeColY = IMG_SIZE
		
			let fftData = new Uint8Array(IMG_SIZE * IMG_SIZE * 4)
			let fftK = new Float32Array(IMG_SIZE * IMG_SIZE * 4) // 32位浮点数数组。每个元素占用4个字节。常用于科学计算、图形渲染中需要小数精度的场景。
			let wData = new Float32Array(IMG_SIZE * 4)
		</script>
		<script>
			// 复数乘法
			function complexMultiply(a, b) {
				return {
					x: a.x * b.x - a.y * b.y, // 实部
					y: a.x * b.y + a.y * b.x // 虚部
				}
			}

			// 色散关系函数
			function dispersion(k) {
				return Math.sqrt(G * vectorLength(k))
			}

			// 计算向量长度（模）
			function vectorLength(v) {
				return Math.sqrt(v.x * v.x + v.y * v.y)
			}

			// 归一化向量
			function normalize(v) {
				let len = vectorLength(v)
				return { x: v.x / len, y: v.y / len }
			}

			// 点积计算
			function dot(a, b) {
				return a.x * b.x + a.y * b.y
			}

			// 快速随机值生成函数
			function randValueFast(uv, seed) {
				return fract(Math.sin(dot(uv, { x: 12.9898, y: 78.233 }) + seed) * 43758.5453)
			}

			// fract函数
			function fract(x) {
				return x - Math.floor(x)
			}

			// 计算两个相互独立的高斯随机数
			function gauss(uv) {
				let u1 = randValueFast(uv, 1753.0)
				let u2 = randValueFast(uv, 3571.0)

				if (u1 < 1e-6) {
					u1 = 1e-6
				}

				let g1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(TWO_PI * u2)
				let g2 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(TWO_PI * u2)

				return { x: g1, y: g2 }
			}

			// 菲利普频谱计算，输入波数 K
			function phillips(K) {
				let W = { x: 1.0, y: -1.0 } // 风的方向向量
				let V = 10.0 // 风速
				let A = 10.0 // 振幅参数

				let L = V * V / G // 最大波长
				let L2 = L * L

				let kLen = Math.max(0.0001, vectorLength(K))
				let kLen2 = kLen * kLen
				let kLen4 = kLen2 * kLen2

				let K_norm = normalize(K)
				let W_norm = normalize(W)
				let dot_KW = dot(K_norm, W_norm)

				// 基础 Phillips 谱
				let phi = A * Math.exp(-1.0 / (kLen2 * L2)) / kLen4

				// 风向对齐项
				phi *= dot_KW * dot_KW

				// 仅保留与风向同方向的波
				if (dot_KW > 0.0) {
					phi *= V
				}

				// 衰减因子（减少长波）
				let l = 0.001 * L
				let kSqr = dot(K, K)
				phi *= Math.exp(l * l * -kSqr)

				return phi
			}
		</script>
		<script>
			let Code_Phillips_Texture = `
				// 复数乘法
				fn complexMultiply(a: vec2<f32>, b: vec2<f32>) -> vec2<f32> {
					var result: vec2<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
	
				// 色散关系函数
				fn dispersion(k: vec2<f32>) -> f32 {
					return sqrt(9.8 * length(k));
				}
	
				@group(0) @binding(0) var samplerSrc: sampler;
				@group(0) @binding(1) var src: texture_2d<f32>;
				// WebGPU 对浮点纹理的采样有严格限制： rgba32float 格式的纹理默认是 unfilterable（不可过滤的），不能用于线性过滤采样。所以用 rgba16float
				@group(0) @binding(2) var phillipsTexture: texture_storage_2d<rgba16float, write>; 
				@group(0) @binding(3) var<uniform> uTime: f32;
	
				@group(1) @binding(0) var samplerFft: sampler;
				@group(1) @binding(1) var fftK: texture_2d<f32>;
				
				@compute @workgroup_size(1, 1, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>,
					@builtin(local_invocation_id) local_id: vec3<u32>
				) {
					let src_dims: vec2<f32> = vec2<f32>(textureDimensions(src, 0));
					let src_texture: vec4<f32> = textureSampleLevel(src, samplerSrc, vec2<f32>(global_id.xy) / src_dims, 0.0);
	
					let fft_dims: vec2<f32> = vec2<f32>(textureDimensions(fftK, 0));
					let fft_texture: vec4<f32> = textureSampleLevel(fftK, samplerFft, vec2<f32>(global_id.xy) / fft_dims, 0.0);
	
					var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
					
					let k = textureLoad(fftK, vec2<i32>(i32(global_id.x), i32(global_id.y)), 0).rg;
	
					// let k = vec2<f32>(fft_texture.r, fft_texture.g);
	
					let omega = dispersion(k) * uTime;
					let c = cos(omega);
					let s = sin(omega);
					let h0k = src_texture.rg;
					let h0k_conj = src_texture.ba;
	
					let h1 = complexMultiply(h0k, vec2<f32>(c, s));
					let h2 = complexMultiply(h0k_conj, vec2<f32>(c, -s));
	
					color.r = h1.r + h2.r;
					color.g = h1.g + h2.g;
	
					textureStore(phillipsTexture, vec2<i32>(global_id.xy), color);
				}
			`

			/** 第二步 计算 row ，得到 textureRow */
			let Code_Row = `
				fn complexMultiply(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {
					var result: vec4<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
	
				@group(0) @binding(0) var samplerSrc: sampler;
				@group(0) @binding(1) var src: texture_2d<f32>;
				@group(0) @binding(2) var rowTexture: texture_storage_2d<rgba16float, write>;
				@group(1) @binding(0) var samplerW: sampler;
	
				@group(1) @binding(1) var wData: texture_2d<f32>;
	
				var<workgroup> sharedData: array<vec4<f32>, ${IMG_SIZE}u>;
				var<workgroup> tempData: array<vec4<f32>, ${IMG_SIZE}u>;
	
				@compute @workgroup_size(${workGroupSizeRowX}, ${workGroupSizeRowY}, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>,
					@builtin(local_invocation_id) local_id: vec3<u32>
				) {
	
					let src_dims: vec2<f32> = vec2<f32>(textureDimensions(src, 0));
					let src_texture: vec4<f32> = textureSampleLevel(src, samplerSrc, vec2<f32>(global_id.xy) / src_dims, 0.0);
	
					let w_dims: vec2<f32> = vec2<f32>(textureDimensions(wData, 0));
					let w_texture: vec4<f32> = textureSampleLevel(wData, samplerW, vec2<f32>(global_id.xy) / w_dims, 0.0);
	
					// 该行存入到 sharedData 中
					// 使用 global_id.x 作为索引，因为要存储行数据
					sharedData[global_id.x] = textureLoad(src, vec2<i32>(i32(global_id.x), i32(global_id.y)), 0);
	
					
					// 开始计算
					for (var m = 0u; m < ${logN}u; m++) {
						workgroupBarrier(); // 同步点①：确保所有线程完成上一轮数据写入
	
						tempData[global_id.x] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
						
						workgroupBarrier(); // 同步点②：确保初始化完成
	
						var inputIndex = 0u;
						var step = 1u << m; // 等于pow
						var blockSize = 1u << (m + 1u);
						var blockNum = ${IMG_SIZE}u / blockSize;
						var kFor = blockSize / 2u;
	
						for (var n = 0u; n < blockNum; n++) {
							for(var k = 0u; k < kFor; k++) {
								var inputData1 = sharedData[inputIndex];
								var inputData2 = sharedData[inputIndex + ${half}u];
	
								var outputIndex1 = 2u * (inputIndex - (inputIndex % (1u << m))) + (inputIndex % (1u << m));
								var outputIndex2 = outputIndex1 + step;
	
								var indexW = k * (1u << (${logN}u - m - 1u));
								var w = textureLoad(wData, vec2<i32>(i32(indexW), 0), 0);
								// var angle = 2.0 * 3.1415926535 * f32(indexW) / f32(${IMG_SIZE});
								// w = vec4<f32>(cos(angle), -sin(angle), 0.0, 0.0);
	
								var p1 = inputData1;
								var p2 = complexMultiply(inputData2, w);
	
								tempData[outputIndex1] = p1 + p2;
								tempData[outputIndex2] = p1 - p2;
	
								workgroupBarrier(); // 同步点③：确保所有蝶形运算完成
	
								inputIndex = inputIndex + 1u;
							}
						}
	
						workgroupBarrier(); // 同步点④：确保所有运算完成
	
						sharedData[global_id.x] = tempData[global_id.x];
	
						workgroupBarrier(); // 同步点⑤：确保交换完成
	
					}
	
					// 使用 clamp 函数，将值限制在 [0, 1] 范围内
					// var color = vec4<f32>(clamp(sharedData[global_id.x].r, 0.0, 1.0), clamp(sharedData[global_id.x].g, 0.0, 1.0), 0.0, 1.0);
					var color = vec4<f32>(sharedData[global_id.x].r, sharedData[global_id.x].g, 0.0, 1.0);
	
					textureStore(rowTexture, vec2<i32>(global_id.xy), color);
				}
			`


			/** 第三步 计算 col ，得到 textureCol */
			let Code_Col = `
				fn complexMultiply(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {
					var result: vec4<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
	
				@group(0) @binding(0) var samplerSrc: sampler;
				@group(0) @binding(1) var src: texture_2d<f32>;
				@group(0) @binding(2) var colTexture: texture_storage_2d<rgba32float, write>;
	
				@group(1) @binding(0) var samplerW: sampler;
				@group(1) @binding(1) var wData: texture_2d<f32>;
	
				var<workgroup> sharedData: array<vec4<f32>, ${IMG_SIZE}u>;
				var<workgroup> tempData: array<vec4<f32>, ${IMG_SIZE}u>;
	
				@compute @workgroup_size(${workGroupSizeColX}, ${workGroupSizeColY}, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>,
					@builtin(local_invocation_id) local_id: vec3<u32>
				) {
					let src_dims: vec2<f32> = vec2<f32>(textureDimensions(src, 0));
					let src_texture: vec4<f32> = textureSampleLevel(src, samplerSrc, vec2<f32>(global_id.xy) / src_dims, 0.0);
	
					let w_dims: vec2<f32> = vec2<f32>(textureDimensions(wData, 0));
					let w_texture: vec4<f32> = textureSampleLevel(wData, samplerW, vec2<f32>(global_id.xy) / w_dims, 0.0);
	
					// 该列存入到 sharedData 中
					// 使用 global_id.y 作为索引，因为要存储列数据
					sharedData[global_id.y] = textureLoad(src, vec2<i32>(i32(global_id.x), i32(global_id.y)), 0);
	
	
					// 开始计算
					for (var m = 0u; m < ${logN}u; m++) {
						workgroupBarrier(); // 同步点①：确保所有线程完成上一轮数据写入
	
						tempData[global_id.y] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
						
						workgroupBarrier(); // 同步点②：确保初始化完成
	
						var inputIndex = 0u;
						var step = 1u << m; // 等于pow
						var blockSize = 1u << (m + 1u);
						var blockNum = ${IMG_SIZE}u / blockSize;
						var kFor = blockSize / 2u;
	
						for (var n = 0u; n < blockNum; n++) {
							for(var k = 0u; k < kFor; k++) {
								var inputData1 = sharedData[inputIndex];
								var inputData2 = sharedData[inputIndex + ${half}u];
	
								var outputIndex1 = 2u * (inputIndex - (inputIndex % (1u << m))) + (inputIndex % (1u << m));
								var outputIndex2 = outputIndex1 + step;
	
								var indexW = k * (1u << (${logN}u - m - 1u));
								var w = textureLoad(wData, vec2<i32>(i32(indexW), 0), 0);
								// var angle = 2.0 * 3.1415926535 * f32(indexW) / f32(${IMG_SIZE});
								// w = vec4<f32>(cos(angle), -sin(angle), 0.0, 0.0);
	
								var p1 = inputData1;
								var p2 = complexMultiply(inputData2, w);
	
								tempData[outputIndex1] = p1 + p2;
								tempData[outputIndex2] = p1 - p2;
	
								workgroupBarrier(); // 同步点③：确保所有蝶形运算完成
	
								inputIndex = inputIndex + 1u;
							}
						}
	
						workgroupBarrier(); // 同步点④：确保所有运算完成
	
						sharedData[global_id.y] = tempData[global_id.y];
	
						workgroupBarrier(); // 同步点⑤：确保交换完成
					}
	
					// 使用 clamp 函数，将值限制在 [0, 1] 范围内
					// var color = vec4<f32>(clamp(sharedData[global_id.y].r, 0.0, 1.0), clamp(sharedData[global_id.y].g, 0.0, 1.0), 0.0, 1.0);
					var color = vec4<f32>(sharedData[global_id.y].r, sharedData[global_id.y].g, 0.0, 1.0);
	
					textureStore(colTexture, vec2<i32>(global_id.xy), color);
				}
			`
		</script>
		<script>
			for (let y = 0; y < IMG_SIZE; y++) {
				for (let x = 0; x < IMG_SIZE; x++) {
					let index = (x + y * IMG_SIZE) * 4
					let gaussValue1 = gauss({ x: x + 3, y: y + 5 })
					let gaussValue2 = gauss({ x: x + 7, y: y + 11 })

					let nx = x - IMG_SIZE / 2
					let ny = y - IMG_SIZE / 2

					let K = {
						x: TWO_PI * nx / IMG_SIZE,
						y: TWO_PI * ny / IMG_SIZE
					}

					let phillipsRes1 = Math.sqrt(phillips(K) * 0.5)
					let h0k = {
						x: gaussValue1.x * phillipsRes1,
						y: gaussValue1.y * phillipsRes1
					}

					let phillipsRes2 = Math.sqrt(phillips({ x: K.x * -1, y: K.y * -1 }) * 0.5)
					let h0kConj = {
						x: gaussValue2.x * phillipsRes2,
						y: gaussValue2.y * phillipsRes2 * -1
					}

					let omega = dispersion(K)
					let c = Math.cos(omega)
					let s = Math.sin(omega)
					let h1 = complexMultiply(h0k, { x: c, y: s })
					let h2 = complexMultiply(h0kConj, { x: c, y: s * -1 })

					let H_Tilde = {
						x: h1.x + h2.x,
						y: h1.y + h2.y
					}

					let kLen = vectorLength(K)
					kLen = kLen < 0.001 ? 0.001 : kLen
					let maxK = { x: K.x / kLen, y: K.y / kLen }

					let KxHTilde = complexMultiply({ x: 0, y: -1 * maxK.x }, H_Tilde)
					let KzHTilde = complexMultiply({ x: 0, y: -1 * maxK.y }, H_Tilde)

					fftData[index] = h0k.x
					fftData[index + 1] = h0k.y
					fftData[index + 2] = h0kConj.x
					fftData[index + 3] = h0kConj.y


					fftK[index] = K.x
					fftK[index + 1] = K.y
					fftK[index + 2] = maxK.x
					fftK[index + 3] = maxK.y
				}
			}

			for (let i = 0; i < IMG_SIZE; i++) {
				let angle = (2 * Math.PI * i) / IMG_SIZE
				wData[i * 4] = Math.cos(angle) // re
				wData[i * 4 + 1] = -Math.sin(angle) // im
			}

			let init = async () => {
				let ele = document.getElementById('shaderSea1')
				let engine = new BABYLON.WebGPUEngine(ele)
				await engine.initAsync()
				let scene = new BABYLON.Scene(engine)
				scene.useRightHandedSystem = false
				let camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 1.5, Math.PI / 2.2, 15, new BABYLON.Vector3(0, 0,
					0), scene)
				camera.upperBetaLimit = Math.PI / 2.2
				camera.wheelPrecision = 1.5
				camera.panningSensibility = 8
				camera.attachControl(ele, true)
				camera.setPosition(new BABYLON.Vector3(0, 560, -560))
				let light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(40, 40, 40), scene)
				light.direction = new BABYLON.Vector3(1.0, 0.0, 1.0)
				light.diffuse = new BABYLON.Color3(1.0, 0.95, 0.8)
				engine.runRenderLoop(function() {
					if (scene && scene.activeCamera) {
						scene.render()
					}
				})





				let rawTextureFft = new BABYLON.RawTexture(fftData, IMG_SIZE, IMG_SIZE, BABYLON.Constants.TEXTUREFORMAT_RGBA,
					scene, false,
					false, BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE)

				let rawTextureFftK = new BABYLON.RawTexture(fftK, IMG_SIZE, IMG_SIZE, BABYLON.Constants.TEXTUREFORMAT_RGBA,
					scene, false, false,
					BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE)

				let rawTextureW = new BABYLON.RawTexture(wData, IMG_SIZE, 1, BABYLON.Constants.TEXTUREFORMAT_RGBA, scene,
					false, false, BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE)



				let uniformBuffer = new BABYLON.UniformBuffer(engine)
				uniformBuffer.addUniform('uTime', 4)


				// phillips 相关
				let phillips = BABYLON.MeshBuilder.CreatePlane('phillips', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				// 对于 FFT 计算，通常使用 nearest 模式更合适，因为 FFT 是离散的
				// let phillipsTexture = RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false, Texture.NEAREST_SAMPLINGMODE, letants.TEXTURETYPE_FLOAT)
				let phillipsTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false,
					false,
					BABYLON.Texture.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_HALF_FLOAT)
				let shaderPhillips = new BABYLON.ComputeShader(
					'shaderPhillips',
					engine, { computeSource: Code_Phillips_Texture }, {
						bindingsMapping: {
							'src': { group: 0, binding: 1 },
							'phillipsTexture': { group: 0, binding: 2 },
							'uTime': { group: 0, binding: 3 },
							'fftK': { group: 1, binding: 1 },
						}
					}
				)
				shaderPhillips.setTexture('src', rawTextureFft)
				shaderPhillips.setTexture('fftK', rawTextureFftK)
				shaderPhillips.setStorageTexture('phillipsTexture', phillipsTexture)
				let phillipsMat = new BABYLON.StandardMaterial('phillipsMat', scene)
				phillipsMat.diffuseTexture = phillipsTexture
				phillips.material = phillipsMat
				phillips.position = new BABYLON.Vector3(-IMG_SIZE - 20, 0, 0)
				phillips.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)



				// row 相关
				let rowGround = BABYLON.MeshBuilder.CreatePlane('row', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				// let rowTexture = RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false, Texture.NEAREST_SAMPLINGMODE, letants.TEXTURETYPE_FLOAT)
				let rowTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false,
					BABYLON.Texture
					.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_HALF_FLOAT)
				let shaderRow = new BABYLON.ComputeShader(
					'shaderRow',
					engine, { computeSource: Code_Row }, {
						bindingsMapping: {
							'src': { group: 0, binding: 1 },
							'rowTexture': { group: 0, binding: 2 },
							'wData': { group: 1, binding: 1 },
						}
					}
				)
				shaderRow.setTexture('src', phillipsTexture)
				shaderRow.setTexture('wData', rawTextureW)
				shaderRow.setStorageTexture('rowTexture', rowTexture)
				let rowMat = new BABYLON.StandardMaterial('rowMat', scene)
				rowMat.diffuseTexture = rowTexture
				rowGround.material = rowMat
				rowGround.position = new BABYLON.Vector3(0, 0, 0)
				rowGround.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)



				// col 相关
				let colGround = BABYLON.MeshBuilder.CreatePlane('col', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				let colTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false,
					BABYLON.Texture
					.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_FLOAT)
				// let colTexture = RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false, Texture.NEAREST_SAMPLINGMODE, letants.TEXTURETYPE_HALF_FLOAT)
				let shaderCol = new BABYLON.ComputeShader(
					'shaderCol',
					engine, { computeSource: Code_Col }, {
						bindingsMapping: {
							'src': { group: 0, binding: 1 },
							'colTexture': { group: 0, binding: 2 },
							'wData': { group: 1, binding: 1 },
						}
					}
				)
				shaderCol.setTexture('src', rowTexture)
				shaderCol.setTexture('wData', rawTextureW)
				shaderCol.setStorageTexture('colTexture', colTexture)
				let colMat = new BABYLON.StandardMaterial('colMat', scene)
				colMat.diffuseTexture = colTexture
				colGround.material = colMat
				colGround.position = new BABYLON.Vector3(IMG_SIZE + 20, 0, 0)
				colGround.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)






				scene.registerBeforeRender(async () => {
					uTime += 0.02
					uniformBuffer.updateFloat('uTime', uTime)
					uniformBuffer.update()

					shaderPhillips.setUniformBuffer('uTime', uniformBuffer)

					// 计算 Phillips 纹理
					await shaderPhillips.dispatchWhenReady(phillipsTexture.getSize().width, phillipsTexture.getSize()
						.height, 1)

					// 计算 row 纹理
					await shaderRow.dispatchWhenReady(IMG_SIZE / workGroupSizeRowX, IMG_SIZE / workGroupSizeRowY, 1)

					// 计算 col 纹理
					await shaderCol.dispatchWhenReady(IMG_SIZE / workGroupSizeColX, IMG_SIZE / workGroupSizeColY, 1)

					// 查看像素值
					// if(uTime > 0.2 && uTime < 0.24) {
					//   let pixels = await colTexture.readPixels()
					//   console.log(pixels)
					// }
				})
			}
			init()
		</script>
	</body>
</html>