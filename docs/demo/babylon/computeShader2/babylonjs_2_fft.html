<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<title></title>
	</head>
	<body>
		<canvas id="shaderSea1" style="width: 800px;height: 800px;"></canvas>

		<script>
			let IMG_SIZE = 128
			let PI = 3.14159265358979323846
			let TWO_PI = 2 * PI
			let G = 9.8
			let logN = Math.log2(IMG_SIZE)
			let half = IMG_SIZE / 2
			let uTime = 0.02
			let workGroupSizeRowX = IMG_SIZE
			let workGroupSizeRowY = 1
			let workGroupSizeColX = 1
			let workGroupSizeColY = IMG_SIZE

			let wData = new Float32Array(IMG_SIZE * 4)
		</script>

		<script>
			let Code_Texture_Phillips = `
				const TWO_PI: f32 = 6.283185307179586;
			
				// 复数乘法
				fn complexMultiply(a: vec2<f32>, b: vec2<f32>) -> vec2<f32> {
					var result: vec2<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
					
				// 色散关系函数
				fn dispersion(k: vec2<f32>) -> f32 {
					return sqrt(9.8 * length(k));
				}
				
				// 快速随机函数
				fn randValueFast(uv: vec2<f32>, seed: f32) -> f32 {
					return fract(sin(dot(uv, vec2<f32>(12.9898, 78.12345)) + seed) * 43759.54321);
				}
				
				// 高斯图
				fn gauss(uv: vec2<f32>) -> vec2<f32> {
					var u1 = randValueFast(uv, 1753.21);
					var u2 = randValueFast(uv, 3547.15);
					
					if(u1 < 0.00001) {
						u1 = 0.00001;
					}
					
					let mag = sqrt(-2.0 * log(u1));
					let ang = TWO_PI * u2;
					
					return vec2<f32>(mag * cos(ang), mag * sin(ang));
				}
				
				// phillips图谱
				fn phillips(k: vec2<f32>) -> f32 {
					let windDir = vec2<f32>(1.0, -1.0); // 风向向量
					let windV = 10.3; // 风速
					let A = 10.5; // 振幅参数
					let G = 9.8;
					
					let L = windV * windV / G; // 最大波长
					let L2 = L * L;
					
					let kLen = max(0.0001, length(k));
					let kLen2 = kLen * kLen;
					let kLen4 = kLen2 * kLen2;
					
					var kNorm = vec2<f32>(0.0, 0.0);
					if(k.x == 0 && k.y == 0) {
						kNorm = vec2<f32>(0.0, 0.0);
					} else {
						kNorm = normalize(k);
					}
					let wNorm = normalize(windDir);
					let dotByKnormWnorm = dot(kNorm, wNorm);
					
					var phi = A * exp(-1.0 / (kLen2 * L2)) / kLen4; // 基础 Phillips 谱
					
					phi *= dotByKnormWnorm * dotByKnormWnorm; // 风向对齐项
					
					if (dotByKnormWnorm > 0.0) { // 仅保留与风向同方向的波
						phi *= windV;
					}
					
					return phi;
				}
				
				@group(0) @binding(1) var phillipsTexture: texture_storage_2d<rgba16float, write>;
				@group(0) @binding(2) var<uniform> uTime: f32;
				@compute @workgroup_size(8, 8, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>
				) {
					var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
					
					let x = f32(global_id.x);
					let y = f32(global_id.y);
					
					let gaussValue1 = gauss(vec2<f32>(x + 3.2, y + 5.3));
					let gaussValue2 = gauss(vec2<f32>(x + 7.2, y + 15.3));
					
					let size = f32(${IMG_SIZE});
					let nx = x - size / 2.0;
					let ny = y - size / 2.0;
					
					let k = vec2<f32>(TWO_PI * nx / size, TWO_PI * ny / size);
					
					let phillipsRes1 = sqrt(phillips(k) * 0.5);
					let h0k = vec2<f32>(gaussValue1.x * phillipsRes1, gaussValue2.y * phillipsRes1);
					
					let phillipsRes2 = sqrt(phillips(-1.0 * k) * 0.5);
					let h0kConj = vec2<f32>(gaussValue1.x * phillipsRes2, -1.0 * gaussValue2.y * phillipsRes2);
					
					let omega = dispersion(k) * uTime;
					let c = cos(omega);
					let s = sin(omega);
					
					let h1 = complexMultiply(h0k, vec2<f32>(c, s));
					let h2 = complexMultiply(h0kConj, vec2<f32>(c, -1.0 * s));
					
					let hTildeY = vec2<f32>(h1.x + h2.x, h1.y + h2.y); // 这个是y的
					
					// 下面是计算x和z的
					var kLen = length(k);
					if(kLen < 0.0001) {
						kLen = 0.0001;
					}
					let maxK = vec2<f32>(k.x / kLen, k.y / kLen);
					let hTildeX = complexMultiply(vec2<f32>(0, -1 * maxK.x), hTildeY);
					let hTildeZ = complexMultiply(vec2<f32>(0, -1 * maxK.y), hTildeY);
					
					
					// y的color
					color.r = hTildeY.r;
					color.g = hTildeY.g;
					
					// x的color
					// color.r = hTildeX.r;
					// color.g = hTildeX.g;
					
					// z的color
					// color.r = hTildeZ.r;
					// color.g = hTildeZ.g;
					
					textureStore(phillipsTexture, vec2<i32>(global_id.xy), color);
				}
			`
		</script>

		<script>
			let Code_Row = `
				fn complexMultiply(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {
					var result: vec4<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
				
				@group(0) @binding(0) var samplerSrc: sampler;
				@group(0) @binding(1) var src: texture_2d<f32>;
				@group(0) @binding(2) var rowTexture: texture_storage_2d<rgba16float, write>;
				@group(1) @binding(0) var samplerW: sampler;
				
				@group(1) @binding(1) var wData: texture_2d<f32>;
				
				var<workgroup> sharedData: array<vec4<f32>, ${IMG_SIZE}u>;
				var<workgroup> tempData: array<vec4<f32>, ${IMG_SIZE}u>;
				
				@compute @workgroup_size(${workGroupSizeRowX}, ${workGroupSizeRowY}, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>,
					@builtin(local_invocation_id) local_id: vec3<u32>
				) {
				
					let src_dims: vec2<f32> = vec2<f32>(textureDimensions(src, 0));
					let src_texture: vec4<f32> = textureSampleLevel(src, samplerSrc, vec2<f32>(global_id.xy) / src_dims, 0.0);
				
					let w_dims: vec2<f32> = vec2<f32>(textureDimensions(wData, 0));
					let w_texture: vec4<f32> = textureSampleLevel(wData, samplerW, vec2<f32>(global_id.xy) / w_dims, 0.0);
				
					// 该行存入到 sharedData 中
					// 使用 global_id.x 作为索引，因为要存储行数据
					sharedData[global_id.x] = textureLoad(src, vec2<i32>(i32(global_id.x), i32(global_id.y)), 0);
				
					
					// 开始计算
					for (var m = 0u; m < ${logN}u; m++) {
						workgroupBarrier(); // 同步点①：确保所有线程完成上一轮数据写入
				
						tempData[global_id.x] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
						
						workgroupBarrier(); // 同步点②：确保初始化完成
				
						var inputIndex = 0u;
						var step = 1u << m; // 等于pow
						var blockSize = 1u << (m + 1u);
						var blockNum = ${IMG_SIZE}u / blockSize;
						var kFor = blockSize / 2u;
				
						for (var n = 0u; n < blockNum; n++) {
							for(var k = 0u; k < kFor; k++) {
								var inputData1 = sharedData[inputIndex];
								var inputData2 = sharedData[inputIndex + ${half}u];
				
								var outputIndex1 = 2u * (inputIndex - (inputIndex % (1u << m))) + (inputIndex % (1u << m));
								var outputIndex2 = outputIndex1 + step;
				
								var indexW = k * (1u << (${logN}u - m - 1u));
								var w = textureLoad(wData, vec2<i32>(i32(indexW), 0), 0);
				
								var p1 = inputData1;
								var p2 = complexMultiply(inputData2, w);
				
								tempData[outputIndex1] = p1 + p2;
								tempData[outputIndex2] = p1 - p2;
				
								workgroupBarrier(); // 同步点③：确保所有蝶形运算完成
				
								inputIndex = inputIndex + 1u;
							}
						}
				
						workgroupBarrier(); // 同步点④：确保所有运算完成
				
						sharedData[global_id.x] = tempData[global_id.x];
				
						workgroupBarrier(); // 同步点⑤：确保交换完成
				
					}
				
					// 使用 clamp 函数，将值限制在 [0, 1] 范围内
					// var color = vec4<f32>(clamp(sharedData[global_id.x].r, 0.0, 1.0), clamp(sharedData[global_id.x].g, 0.0, 1.0), 0.0, 1.0);
					var color = vec4<f32>(sharedData[global_id.x].r, sharedData[global_id.x].g, 0.0, 1.0);
				
					textureStore(rowTexture, vec2<i32>(global_id.xy), color);
				}
			`
		</script>

		<script>
			let Code_Col = `
				fn complexMultiply(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {
					var result: vec4<f32>;
					result.x = a.x * b.x - a.y * b.y;  // 实部
					result.y = a.x * b.y + a.y * b.x;  // 虚部
					return result;
				}
				
				@group(0) @binding(0) var samplerSrc: sampler;
				@group(0) @binding(1) var src: texture_2d<f32>;
				@group(0) @binding(2) var colTexture: texture_storage_2d<rgba32float, write>;
				
				@group(1) @binding(0) var samplerW: sampler;
				@group(1) @binding(1) var wData: texture_2d<f32>;
				
				var<workgroup> sharedData: array<vec4<f32>, ${IMG_SIZE}u>;
				var<workgroup> tempData: array<vec4<f32>, ${IMG_SIZE}u>;
				
				@compute @workgroup_size(${workGroupSizeColX}, ${workGroupSizeColY}, 1)
				fn main(
					@builtin(global_invocation_id) global_id: vec3<u32>,
					@builtin(local_invocation_id) local_id: vec3<u32>
				) {
					let src_dims: vec2<f32> = vec2<f32>(textureDimensions(src, 0));
					let src_texture: vec4<f32> = textureSampleLevel(src, samplerSrc, vec2<f32>(global_id.xy) / src_dims, 0.0);
				
					let w_dims: vec2<f32> = vec2<f32>(textureDimensions(wData, 0));
					let w_texture: vec4<f32> = textureSampleLevel(wData, samplerW, vec2<f32>(global_id.xy) / w_dims, 0.0);
				
					// 该列存入到 sharedData 中
					// 使用 global_id.y 作为索引，因为要存储列数据
					sharedData[global_id.y] = textureLoad(src, vec2<i32>(i32(global_id.x), i32(global_id.y)), 0);
				
				
					// 开始计算
					for (var m = 0u; m < ${logN}u; m++) {
						workgroupBarrier(); // 同步点①：确保所有线程完成上一轮数据写入
				
						tempData[global_id.y] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
						
						workgroupBarrier(); // 同步点②：确保初始化完成
				
						var inputIndex = 0u;
						var step = 1u << m; // 等于pow
						var blockSize = 1u << (m + 1u);
						var blockNum = ${IMG_SIZE}u / blockSize;
						var kFor = blockSize / 2u;
				
						for (var n = 0u; n < blockNum; n++) {
							for(var k = 0u; k < kFor; k++) {
								var inputData1 = sharedData[inputIndex];
								var inputData2 = sharedData[inputIndex + ${half}u];
				
								var outputIndex1 = 2u * (inputIndex - (inputIndex % (1u << m))) + (inputIndex % (1u << m));
								var outputIndex2 = outputIndex1 + step;
				
								var indexW = k * (1u << (${logN}u - m - 1u));
								var w = textureLoad(wData, vec2<i32>(i32(indexW), 0), 0);
				
								var p1 = inputData1;
								var p2 = complexMultiply(inputData2, w);
				
								tempData[outputIndex1] = p1 + p2;
								tempData[outputIndex2] = p1 - p2;
				
								workgroupBarrier(); // 同步点③：确保所有蝶形运算完成
				
								inputIndex = inputIndex + 1u;
							}
						}
				
						workgroupBarrier(); // 同步点④：确保所有运算完成
				
						sharedData[global_id.y] = tempData[global_id.y];
				
						workgroupBarrier(); // 同步点⑤：确保交换完成
					}
				
					// 使用 clamp 函数，将值限制在 [0, 1] 范围内
					// var color = vec4<f32>(clamp(sharedData[global_id.y].r, 0.0, 1.0), clamp(sharedData[global_id.y].g, 0.0, 1.0), 0.0, 1.0);
					var color = vec4<f32>(sharedData[global_id.y].r, sharedData[global_id.y].g, 0.0, 1.0);
					// var color = vec4<f32>(sharedData[global_id.y].r, 0.0, 0.0, 1.0);
				
					textureStore(colTexture, vec2<i32>(global_id.xy), color);
				}
			`
		</script>


		<script>
			let init = async () => {
				let ele = document.getElementById('shaderSea1')
				let engine = new BABYLON.WebGPUEngine(ele)
				await engine.initAsync()
				let scene = new BABYLON.Scene(engine)
				scene.useRightHandedSystem = false
				let camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 1.5, Math.PI / 2.2, 15, new BABYLON.Vector3(0, 0,
					0), scene)
				camera.upperBetaLimit = Math.PI / 2.2
				camera.wheelPrecision = 1.5
				camera.panningSensibility = 8
				camera.attachControl(ele, true)
				camera.setPosition(new BABYLON.Vector3(0, IMG_SIZE, -IMG_SIZE))
				let light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(40, 40, 40), scene)
				light.direction = new BABYLON.Vector3(1.0, 0.0, 1.0)
				light.diffuse = new BABYLON.Color3(1.0, 0.95, 0.8)
				engine.runRenderLoop(function() {
					if (scene && scene.activeCamera) {
						scene.render()
					}
				})


				for (let i = 0; i < IMG_SIZE; i++) {
					let angle = (2 * Math.PI * i) / IMG_SIZE
					let re = Math.cos(angle)
					let im = Math.sin(angle)
					wData[i * 4] = re // re
					wData[i * 4 + 1] = im === 0 ? 0 : -1 * im // im
				}
				let rawTextureW = new BABYLON.RawTexture(wData, IMG_SIZE, 1, BABYLON.Constants.TEXTUREFORMAT_RGBA, scene,
					false, false, BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE)


				const uniformBuffer = new BABYLON.UniformBuffer(engine)
				uniformBuffer.addUniform('uTime', 4)


				// phillips 相关
				let phillips = BABYLON.MeshBuilder.CreatePlane('phillips', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				let phillipsTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false,
					false,
					BABYLON.Texture.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_HALF_FLOAT)

				let shaderPhillips = new BABYLON.ComputeShader(
					'shaderPhillips',
					engine, { computeSource: Code_Texture_Phillips }, {
						bindingsMapping: {
							'phillipsTexture': { group: 0, binding: 1 },
							'uTime': { group: 0, binding: 2 },
						}
					}
				)
				shaderPhillips.setStorageTexture('phillipsTexture', phillipsTexture)
				let phillipsMat = new BABYLON.StandardMaterial('phillipsMat', scene)
				phillipsMat.diffuseTexture = phillipsTexture
				phillips.material = phillipsMat
				phillips.position = new BABYLON.Vector3(-IMG_SIZE - 20, 0, -IMG_SIZE - 20)
				phillips.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)


				// row 相关
				let rowGround = BABYLON.MeshBuilder.CreatePlane('row', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				// let rowTexture = RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false, Texture.NEAREST_SAMPLINGMODE, letants.TEXTURETYPE_FLOAT)
				let rowTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false,
					BABYLON.Texture
					.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_HALF_FLOAT)
				let shaderRow = new BABYLON.ComputeShader(
					'shaderRow',
					engine, { computeSource: Code_Row }, {
						bindingsMapping: {
							'src': { group: 0, binding: 1 },
							'rowTexture': { group: 0, binding: 2 },
							'wData': { group: 1, binding: 1 },
						}
					}
				)
				shaderRow.setTexture('src', phillipsTexture)
				shaderRow.setTexture('wData', rawTextureW)
				shaderRow.setStorageTexture('rowTexture', rowTexture)
				let rowMat = new BABYLON.StandardMaterial('rowMat', scene)
				rowMat.diffuseTexture = rowTexture
				rowGround.material = rowMat
				rowGround.position = new BABYLON.Vector3(0, 0, -IMG_SIZE - 20)
				rowGround.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)


				// col 相关
				let colGround = BABYLON.MeshBuilder.CreatePlane('col', { width: IMG_SIZE, height: IMG_SIZE }, scene)
				let colTexture = BABYLON.RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false,
					BABYLON.Texture
					.NEAREST_SAMPLINGMODE, BABYLON.Constants.TEXTURETYPE_FLOAT)
				// let colTexture = RawTexture.CreateRGBAStorageTexture(null, IMG_SIZE, IMG_SIZE, scene, false, false, Texture.NEAREST_SAMPLINGMODE, letants.TEXTURETYPE_HALF_FLOAT)
				let shaderCol = new BABYLON.ComputeShader(
					'shaderCol',
					engine, { computeSource: Code_Col }, {
						bindingsMapping: {
							'src': { group: 0, binding: 1 },
							'colTexture': { group: 0, binding: 2 },
							'wData': { group: 1, binding: 1 },
						}
					}
				)
				shaderCol.setTexture('src', rowTexture)
				shaderCol.setTexture('wData', rawTextureW)
				shaderCol.setStorageTexture('colTexture', colTexture)
				let colMat = new BABYLON.StandardMaterial('colMat', scene)
				colMat.diffuseTexture = colTexture
				colGround.material = colMat
				colGround.position = new BABYLON.Vector3(IMG_SIZE + 20, 0, -IMG_SIZE - 20)
				colGround.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)





				BABYLON.Effect.ShadersStore['seaVertexShader'] = `
					precision highp float;
					
					attribute vec2 uv;
					attribute vec3 position;
					uniform mat4 worldViewProjection;
					
					varying vec2 vUV;
			
					void main(void) {
						vUV = uv;
						gl_Position = worldViewProjection * vec4(position, 1.0);
					}
				`

				BABYLON.Effect.ShadersStore['seaFragmentShader'] = `
					// 类似波浪的使用smoothstep？
				
					precision highp float;
					
					uniform sampler2D uSampler;
					uniform float uGridCount;
					uniform vec2 uResolution;
					
					varying vec2 vUV;
					
					void main() {
						vec2 uv = vUV;
						
						vec4 baseColor = texture(uSampler, uv);
						vec4 color = baseColor;
						
						vec2 pixel = uv * uResolution;
						vec2 grid = floor(pixel); // 向下取整，即当前index【0 ~ 127】
						vec2 local = fract(pixel); // 取小数
						
						vec4 c00 = texture(uSampler, (grid + vec2(0, 0)) / uResolution);
						vec4 c10 = texture(uSampler, (grid + vec2(1, 0)) / uResolution);
						vec4 c01 = texture(uSampler, (grid + vec2(0, 1)) / uResolution);
						vec4 c11 = texture(uSampler, (grid + vec2(1, 1)) / uResolution);
						
						// 使用局部坐标做双线性插值
						color = mix(mix(c00, c10, local.x), mix(c01, c11, local.x), local.y);
						
						gl_FragColor = color;
					}
				`
				
				
				const material = new BABYLON.ShaderMaterial(
					'sea',
					scene, {
						vertex: 'sea',
						fragment: 'sea'
					}, {
						attributes: ['position', 'uv'],
						uniforms: ['worldViewProjection', 'uSampler', 'uGridCount', 'uResolution'],
						samplers: ['uSampler'],
					}
				)

				const test = BABYLON.MeshBuilder.CreateGround('test', {
					width: IMG_SIZE,
					height: IMG_SIZE,
					subdivisions: IMG_SIZE
				}, scene)
				test.material = material
				test.position = new BABYLON.Vector3(0, 0, 0)
				material.setFloat('uGridCount', IMG_SIZE)
				material.setVector2('uResolution', new BABYLON.Vector2(IMG_SIZE, IMG_SIZE))
				material.setTexture('uSampler', colTexture)




				console.log('wData', wData)
				let a = 0

				scene.registerBeforeRender(async () => {
					a++
					uTime += 0.01
					uniformBuffer.updateFloat('uTime', uTime)
					uniformBuffer.update()

					shaderPhillips.setUniformBuffer('uTime', uniformBuffer)

					// 计算 Phillips 纹理
					await shaderPhillips.dispatchWhenReady(IMG_SIZE / 8, IMG_SIZE / 8, 1)

					// 计算 row 纹理
					await shaderRow.dispatchWhenReady(IMG_SIZE / workGroupSizeRowX, IMG_SIZE / workGroupSizeRowY, 1)

					// 计算 col 纹理
					await shaderCol.dispatchWhenReady(IMG_SIZE / workGroupSizeColX, IMG_SIZE / workGroupSizeColY, 1)


					// if (a > 12 && a < 14) {
					// 	const pixels = await phillipsTexture.readPixels()
					// 	console.log('phillips', pixels)
					// 	pixels.forEach((v, i) => {
					// 		if (isNaN(v)) console.log('phillips', v, i)
					// 	})
					// }

					// if (a > 20 && a < 22) {
					// 	const pixels = await rowTexture.readPixels()
					// 	console.log('row', pixels)
					// 	pixels.forEach(v => {
					// 		if (isNaN(v)) console.log('row', v)
					// 	})
					// }

					// if (a > 28 && a < 30) {
					// 	const pixels = await colTexture.readPixels()
					// 	console.log('col', pixels)
					// 	pixels.forEach(v => {
					// 		if (isNaN(v)) console.log('col', v)
					// 	})
					// }
				})
			}

			init()
		</script>
	</body>
</html>