import {
  require_babylon
} from "./chunk-4QPWKAW5.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/.pnpm/babylonjs-loaders@8.2.1/node_modules/babylonjs-loaders/babylonjs.loaders.js
var require_babylonjs_loaders = __commonJS({
  "node_modules/.pnpm/babylonjs-loaders@8.2.1/node_modules/babylonjs-loaders/babylonjs.loaders.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_babylon());
      else if (typeof define === "function" && define.amd)
        define("babylonjs-loaders", ["babylonjs"], factory);
      else if (typeof exports === "object")
        exports["babylonjs-loaders"] = factory(require_babylon());
      else
        root["LOADERS"] = factory(root["BABYLON"]);
    })(typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports, (__WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_tools__) => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = {
            /***/
            "../../../../node_modules/tslib/tslib.es6.mjs": (
              /*!****************************************************!*\
                !*** ../../../../node_modules/tslib/tslib.es6.mjs ***!
                \****************************************************/
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  __addDisposableResource: () => (
                    /* binding */
                    __addDisposableResource
                  ),
                  /* harmony export */
                  __assign: () => (
                    /* binding */
                    __assign
                  ),
                  /* harmony export */
                  __asyncDelegator: () => (
                    /* binding */
                    __asyncDelegator
                  ),
                  /* harmony export */
                  __asyncGenerator: () => (
                    /* binding */
                    __asyncGenerator
                  ),
                  /* harmony export */
                  __asyncValues: () => (
                    /* binding */
                    __asyncValues
                  ),
                  /* harmony export */
                  __await: () => (
                    /* binding */
                    __await
                  ),
                  /* harmony export */
                  __awaiter: () => (
                    /* binding */
                    __awaiter
                  ),
                  /* harmony export */
                  __classPrivateFieldGet: () => (
                    /* binding */
                    __classPrivateFieldGet
                  ),
                  /* harmony export */
                  __classPrivateFieldIn: () => (
                    /* binding */
                    __classPrivateFieldIn
                  ),
                  /* harmony export */
                  __classPrivateFieldSet: () => (
                    /* binding */
                    __classPrivateFieldSet
                  ),
                  /* harmony export */
                  __createBinding: () => (
                    /* binding */
                    __createBinding
                  ),
                  /* harmony export */
                  __decorate: () => (
                    /* binding */
                    __decorate
                  ),
                  /* harmony export */
                  __disposeResources: () => (
                    /* binding */
                    __disposeResources
                  ),
                  /* harmony export */
                  __esDecorate: () => (
                    /* binding */
                    __esDecorate
                  ),
                  /* harmony export */
                  __exportStar: () => (
                    /* binding */
                    __exportStar
                  ),
                  /* harmony export */
                  __extends: () => (
                    /* binding */
                    __extends
                  ),
                  /* harmony export */
                  __generator: () => (
                    /* binding */
                    __generator
                  ),
                  /* harmony export */
                  __importDefault: () => (
                    /* binding */
                    __importDefault
                  ),
                  /* harmony export */
                  __importStar: () => (
                    /* binding */
                    __importStar
                  ),
                  /* harmony export */
                  __makeTemplateObject: () => (
                    /* binding */
                    __makeTemplateObject
                  ),
                  /* harmony export */
                  __metadata: () => (
                    /* binding */
                    __metadata
                  ),
                  /* harmony export */
                  __param: () => (
                    /* binding */
                    __param
                  ),
                  /* harmony export */
                  __propKey: () => (
                    /* binding */
                    __propKey
                  ),
                  /* harmony export */
                  __read: () => (
                    /* binding */
                    __read
                  ),
                  /* harmony export */
                  __rest: () => (
                    /* binding */
                    __rest
                  ),
                  /* harmony export */
                  __rewriteRelativeImportExtension: () => (
                    /* binding */
                    __rewriteRelativeImportExtension
                  ),
                  /* harmony export */
                  __runInitializers: () => (
                    /* binding */
                    __runInitializers
                  ),
                  /* harmony export */
                  __setFunctionName: () => (
                    /* binding */
                    __setFunctionName
                  ),
                  /* harmony export */
                  __spread: () => (
                    /* binding */
                    __spread
                  ),
                  /* harmony export */
                  __spreadArray: () => (
                    /* binding */
                    __spreadArray
                  ),
                  /* harmony export */
                  __spreadArrays: () => (
                    /* binding */
                    __spreadArrays
                  ),
                  /* harmony export */
                  __values: () => (
                    /* binding */
                    __values
                  ),
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var extendStatics = function(d, b) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                    d2.__proto__ = b2;
                  } || function(d2, b2) {
                    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
                  };
                  return extendStatics(d, b);
                };
                function __extends(d, b) {
                  if (typeof b !== "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                }
                var __assign = function() {
                  __assign = Object.assign || function __assign2(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                      s = arguments[i];
                      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                    }
                    return t;
                  };
                  return __assign.apply(this, arguments);
                };
                function __rest(s, e) {
                  var t = {};
                  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                  if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                        t[p[i]] = s[p[i]];
                    }
                  return t;
                }
                function __decorate(decorators, target, key, desc) {
                  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                  return c > 3 && r && Object.defineProperty(target, key, r), r;
                }
                function __param(paramIndex, decorator) {
                  return function(target, key) {
                    decorator(target, key, paramIndex);
                  };
                }
                function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
                  function accept(f) {
                    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
                    return f;
                  }
                  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
                  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
                  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
                  var _, done = false;
                  for (var i = decorators.length - 1; i >= 0; i--) {
                    var context = {};
                    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
                    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
                    context.addInitializer = function(f) {
                      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
                      extraInitializers.push(accept(f || null));
                    };
                    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
                    if (kind === "accessor") {
                      if (result === void 0) continue;
                      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                      if (_ = accept(result.get)) descriptor.get = _;
                      if (_ = accept(result.set)) descriptor.set = _;
                      if (_ = accept(result.init)) initializers.unshift(_);
                    } else if (_ = accept(result)) {
                      if (kind === "field") initializers.unshift(_);
                      else descriptor[key] = _;
                    }
                  }
                  if (target) Object.defineProperty(target, contextIn.name, descriptor);
                  done = true;
                }
                ;
                function __runInitializers(thisArg, initializers, value) {
                  var useValue = arguments.length > 2;
                  for (var i = 0; i < initializers.length; i++) {
                    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
                  }
                  return useValue ? value : void 0;
                }
                ;
                function __propKey(x) {
                  return typeof x === "symbol" ? x : "".concat(x);
                }
                ;
                function __setFunctionName(f, name2, prefix) {
                  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
                  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
                }
                ;
                function __metadata(metadataKey, metadataValue) {
                  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
                }
                function __awaiter(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                }
                function __generator(thisArg, body) {
                  var _ = { label: 0, sent: function() {
                    if (t[0] & 1) throw t[1];
                    return t[1];
                  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
                  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                    return this;
                  }), g;
                  function verb(n) {
                    return function(v) {
                      return step([n, v]);
                    };
                  }
                  function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (g && (g = 0, op[0] && (_ = 0)), _) try {
                      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                      if (y = 0, t) op = [op[0] & 2, t.value];
                      switch (op[0]) {
                        case 0:
                        case 1:
                          t = op;
                          break;
                        case 4:
                          _.label++;
                          return { value: op[1], done: false };
                        case 5:
                          _.label++;
                          y = op[1];
                          op = [0];
                          continue;
                        case 7:
                          op = _.ops.pop();
                          _.trys.pop();
                          continue;
                        default:
                          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                          }
                          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                          }
                          if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                          }
                          if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                          }
                          if (t[2]) _.ops.pop();
                          _.trys.pop();
                          continue;
                      }
                      op = body.call(thisArg, _);
                    } catch (e) {
                      op = [6, e];
                      y = 0;
                    } finally {
                      f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return { value: op[0] ? op[1] : void 0, done: true };
                  }
                }
                var __createBinding = Object.create ? function(o, m, k, k2) {
                  if (k2 === void 0) k2 = k;
                  var desc = Object.getOwnPropertyDescriptor(m, k);
                  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = { enumerable: true, get: function() {
                      return m[k];
                    } };
                  }
                  Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                  if (k2 === void 0) k2 = k;
                  o[k2] = m[k];
                };
                function __exportStar(m, o) {
                  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
                }
                function __values(o) {
                  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                  if (m) return m.call(o);
                  if (o && typeof o.length === "number") return {
                    next: function() {
                      if (o && i >= o.length) o = void 0;
                      return { value: o && o[i++], done: !o };
                    }
                  };
                  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
                }
                function __read(o, n) {
                  var m = typeof Symbol === "function" && o[Symbol.iterator];
                  if (!m) return o;
                  var i = m.call(o), r, ar = [], e;
                  try {
                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                  } catch (error) {
                    e = { error };
                  } finally {
                    try {
                      if (r && !r.done && (m = i["return"])) m.call(i);
                    } finally {
                      if (e) throw e.error;
                    }
                  }
                  return ar;
                }
                function __spread() {
                  for (var ar = [], i = 0; i < arguments.length; i++)
                    ar = ar.concat(__read(arguments[i]));
                  return ar;
                }
                function __spreadArrays() {
                  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                  for (var r = Array(s), k = 0, i = 0; i < il; i++)
                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                      r[k] = a[j];
                  return r;
                }
                function __spreadArray(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                    if (ar || !(i in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                      ar[i] = from[i];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                }
                function __await(v) {
                  return this instanceof __await ? (this.v = v, this) : new __await(v);
                }
                function __asyncGenerator(thisArg, _arguments, generator) {
                  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                  var g = generator.apply(thisArg, _arguments || []), i, q = [];
                  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
                    return this;
                  }, i;
                  function awaitReturn(f) {
                    return function(v) {
                      return Promise.resolve(v).then(f, reject);
                    };
                  }
                  function verb(n, f) {
                    if (g[n]) {
                      i[n] = function(v) {
                        return new Promise(function(a, b) {
                          q.push([n, v, a, b]) > 1 || resume(n, v);
                        });
                      };
                      if (f) i[n] = f(i[n]);
                    }
                  }
                  function resume(n, v) {
                    try {
                      step(g[n](v));
                    } catch (e) {
                      settle(q[0][3], e);
                    }
                  }
                  function step(r) {
                    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                  }
                  function fulfill(value) {
                    resume("next", value);
                  }
                  function reject(value) {
                    resume("throw", value);
                  }
                  function settle(f, v) {
                    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
                  }
                }
                function __asyncDelegator(o) {
                  var i, p;
                  return i = {}, verb("next"), verb("throw", function(e) {
                    throw e;
                  }), verb("return"), i[Symbol.iterator] = function() {
                    return this;
                  }, i;
                  function verb(n, f) {
                    i[n] = o[n] ? function(v) {
                      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
                    } : f;
                  }
                }
                function __asyncValues(o) {
                  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                  var m = o[Symbol.asyncIterator], i;
                  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                    return this;
                  }, i);
                  function verb(n) {
                    i[n] = o[n] && function(v) {
                      return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                      });
                    };
                  }
                  function settle(resolve, reject, d, v) {
                    Promise.resolve(v).then(function(v2) {
                      resolve({ value: v2, done: d });
                    }, reject);
                  }
                }
                function __makeTemplateObject(cooked, raw) {
                  if (Object.defineProperty) {
                    Object.defineProperty(cooked, "raw", { value: raw });
                  } else {
                    cooked.raw = raw;
                  }
                  return cooked;
                }
                ;
                var __setModuleDefault = Object.create ? function(o, v) {
                  Object.defineProperty(o, "default", { enumerable: true, value: v });
                } : function(o, v) {
                  o["default"] = v;
                };
                var ownKeys = function(o) {
                  ownKeys = Object.getOwnPropertyNames || function(o2) {
                    var ar = [];
                    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
                    return ar;
                  };
                  return ownKeys(o);
                };
                function __importStar(mod) {
                  if (mod && mod.__esModule) return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
                  }
                  __setModuleDefault(result, mod);
                  return result;
                }
                function __importDefault(mod) {
                  return mod && mod.__esModule ? mod : { default: mod };
                }
                function __classPrivateFieldGet(receiver, state, kind, f) {
                  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
                  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
                }
                function __classPrivateFieldSet(receiver, state, value, kind, f) {
                  if (kind === "m") throw new TypeError("Private method is not writable");
                  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
                  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
                }
                function __classPrivateFieldIn(state, receiver) {
                  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
                  return typeof state === "function" ? receiver === state : state.has(receiver);
                }
                function __addDisposableResource(env, value, async) {
                  if (value !== null && value !== void 0) {
                    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
                    var dispose, inner;
                    if (async) {
                      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                      dispose = value[Symbol.asyncDispose];
                    }
                    if (dispose === void 0) {
                      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                      dispose = value[Symbol.dispose];
                      if (async) inner = dispose;
                    }
                    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
                    if (inner) dispose = function() {
                      try {
                        inner.call(this);
                      } catch (e) {
                        return Promise.reject(e);
                      }
                    };
                    env.stack.push({ value, dispose, async });
                  } else if (async) {
                    env.stack.push({ async: true });
                  }
                  return value;
                }
                var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
                  var e = new Error(message);
                  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
                };
                function __disposeResources(env) {
                  function fail(e) {
                    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
                    env.hasError = true;
                  }
                  var r, s = 0;
                  function next() {
                    while (r = env.stack.pop()) {
                      try {
                        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                        if (r.dispose) {
                          var result = r.dispose.call(r.value);
                          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                          });
                        } else s |= 1;
                      } catch (e) {
                        fail(e);
                      }
                    }
                    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
                    if (env.hasError) throw env.error;
                  }
                  return next();
                }
                function __rewriteRelativeImportExtension(path, preserveJsx) {
                  if (typeof path === "string" && /^\.\.?\//.test(path)) {
                    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
                      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
                    });
                  }
                  return path;
                }
                const __WEBPACK_DEFAULT_EXPORT__ = {
                  __extends,
                  __assign,
                  __rest,
                  __decorate,
                  __param,
                  __esDecorate,
                  __runInitializers,
                  __propKey,
                  __setFunctionName,
                  __metadata,
                  __awaiter,
                  __generator,
                  __createBinding,
                  __exportStar,
                  __values,
                  __read,
                  __spread,
                  __spreadArrays,
                  __spreadArray,
                  __await,
                  __asyncGenerator,
                  __asyncDelegator,
                  __asyncValues,
                  __makeTemplateObject,
                  __importStar,
                  __importDefault,
                  __classPrivateFieldGet,
                  __classPrivateFieldSet,
                  __classPrivateFieldIn,
                  __addDisposableResource,
                  __disposeResources,
                  __rewriteRelativeImportExtension
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/index.ts": (
              /*!*********************************************!*\
                !*** ../../../dev/loaders/src/OBJ/index.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    _objFileLoader__WEBPACK_IMPORTED_MODULE_3__.OBJFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    _solidParser__WEBPACK_IMPORTED_MODULE_2__.SolidParser
                  )
                  /* harmony export */
                });
                var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./mtlFileLoader */
                  "../../../dev/loaders/src/OBJ/mtlFileLoader.ts"
                );
                var _objLoadingOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./objLoadingOptions */
                  "../../../dev/loaders/src/OBJ/objLoadingOptions.ts"
                );
                var _solidParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./solidParser */
                  "../../../dev/loaders/src/OBJ/solidParser.ts"
                );
                var _objFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./objFileLoader */
                  "../../../dev/loaders/src/OBJ/objFileLoader.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/mtlFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/mtlFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* binding */
                    MTLFileLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/standardMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var MTLFileLoader = (
                  /** @class */
                  function() {
                    function MTLFileLoader2() {
                      this.materials = [];
                    }
                    MTLFileLoader2.prototype.parseMTL = function(scene, data, rootUrl, assetContainer) {
                      if (data instanceof ArrayBuffer) {
                        return;
                      }
                      var lines = data.split("\n");
                      var delimiter_pattern = /\s+/;
                      var color;
                      var material = null;
                      for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line.length === 0 || line.charAt(0) === "#") {
                          continue;
                        }
                        var pos = line.indexOf(" ");
                        var key = pos >= 0 ? line.substring(0, pos) : line;
                        key = key.toLowerCase();
                        var value = pos >= 0 ? line.substring(pos + 1).trim() : "";
                        if (key === "newmtl") {
                          if (material) {
                            this.materials.push(material);
                          }
                          scene._blockEntityCollection = !!assetContainer;
                          material = new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(value, scene);
                          material._parentContainer = assetContainer;
                          scene._blockEntityCollection = false;
                        } else if (key === "kd" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.diffuseColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ka" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.ambientColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ks" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.specularColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ke" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.emissiveColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ns" && material) {
                          material.specularPower = parseFloat(value);
                        } else if (key === "d" && material) {
                          material.alpha = parseFloat(value);
                        } else if (key === "map_ka" && material) {
                          material.ambientTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_kd" && material) {
                          material.diffuseTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_ks" && material) {
                          material.specularTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_ns") {
                        } else if (key === "map_bump" && material) {
                          var values = value.split(delimiter_pattern);
                          var bumpMultiplierIndex = values.indexOf("-bm");
                          var bumpMultiplier = null;
                          if (bumpMultiplierIndex >= 0) {
                            bumpMultiplier = values[bumpMultiplierIndex + 1];
                            values.splice(bumpMultiplierIndex, 2);
                          }
                          material.bumpTexture = MTLFileLoader2._GetTexture(rootUrl, values.join(" "), scene);
                          if (material.bumpTexture && bumpMultiplier !== null) {
                            material.bumpTexture.level = parseFloat(bumpMultiplier);
                          }
                        } else if (key === "map_d" && material) {
                          material.opacityTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "illum") {
                          if (value === "0") {
                          } else if (value === "1") {
                          } else if (value === "2") {
                          } else if (value === "3") {
                          } else if (value === "4") {
                          } else if (value === "5") {
                          } else if (value === "6") {
                          } else if (value === "7") {
                          } else if (value === "8") {
                          } else if (value === "9") {
                          } else if (value === "10") {
                          }
                        } else {
                        }
                      }
                      if (material) {
                        this.materials.push(material);
                      }
                    };
                    MTLFileLoader2._GetTexture = function(rootUrl, value, scene) {
                      if (!value) {
                        return null;
                      }
                      var url = rootUrl;
                      if (rootUrl === "file:") {
                        var lastDelimiter = value.lastIndexOf("\\");
                        if (lastDelimiter === -1) {
                          lastDelimiter = value.lastIndexOf("/");
                        }
                        if (lastDelimiter > -1) {
                          url += value.substring(lastDelimiter + 1);
                        } else {
                          url += value;
                        }
                      } else {
                        url += value;
                      }
                      return new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Texture(url, scene, false, MTLFileLoader2.INVERT_TEXTURE_Y);
                    };
                    MTLFileLoader2.INVERT_TEXTURE_Y = true;
                    return MTLFileLoader2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts": (
              /*!**************************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts ***!
                \**************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  OBJFileLoaderMetadata: () => (
                    /* binding */
                    OBJFileLoaderMetadata
                  )
                  /* harmony export */
                });
                var OBJFileLoaderMetadata = {
                  name: "obj",
                  extensions: ".obj"
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/objFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/objFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* binding */
                    OBJFileLoader
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/standardMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./objFileLoader.metadata */
                  "../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts"
                );
                var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./mtlFileLoader */
                  "../../../dev/loaders/src/OBJ/mtlFileLoader.ts"
                );
                var _solidParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./solidParser */
                  "../../../dev/loaders/src/OBJ/solidParser.ts"
                );
                var OBJFileLoader = (
                  /** @class */
                  function() {
                    function OBJFileLoader2(loadingOptions) {
                      this.name = _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.name;
                      this.extensions = _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.extensions;
                      this._assetContainer = null;
                      this._loadingOptions = (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, OBJFileLoader2._DefaultLoadingOptions), loadingOptions !== null && loadingOptions !== void 0 ? loadingOptions : {});
                    }
                    Object.defineProperty(OBJFileLoader2, "INVERT_TEXTURE_Y", {
                      /**
                       * Invert Y-Axis of referenced textures on load
                       */
                      get: function() {
                        return _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader.INVERT_TEXTURE_Y;
                      },
                      set: function(value) {
                        _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader.INVERT_TEXTURE_Y = value;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(OBJFileLoader2, "_DefaultLoadingOptions", {
                      get: function() {
                        return {
                          computeNormals: OBJFileLoader2.COMPUTE_NORMALS,
                          optimizeNormals: OBJFileLoader2.OPTIMIZE_NORMALS,
                          importVertexColors: OBJFileLoader2.IMPORT_VERTEX_COLORS,
                          invertY: OBJFileLoader2.INVERT_Y,
                          invertTextureY: OBJFileLoader2.INVERT_TEXTURE_Y,
                          // eslint-disable-next-line @typescript-eslint/naming-convention
                          UVScaling: OBJFileLoader2.UV_SCALING,
                          materialLoadingFailsSilently: OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY,
                          optimizeWithUV: OBJFileLoader2.OPTIMIZE_WITH_UV,
                          skipMaterials: OBJFileLoader2.SKIP_MATERIALS,
                          useLegacyBehavior: OBJFileLoader2.USE_LEGACY_BEHAVIOR
                        };
                      },
                      enumerable: false,
                      configurable: true
                    });
                    OBJFileLoader2.prototype._loadMTL = function(url, rootUrl, onSuccess, onFailure) {
                      var pathOfFile = rootUrl + url;
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadFile(pathOfFile, onSuccess, void 0, void 0, false, function(request, exception) {
                        onFailure(pathOfFile, exception);
                      });
                    };
                    OBJFileLoader2.prototype.createPlugin = function(options) {
                      return new OBJFileLoader2(options[_objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.name]);
                    };
                    OBJFileLoader2.prototype.canDirectLoad = function() {
                      return false;
                    };
                    OBJFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl) {
                      return this._parseSolid(meshesNames, scene, data, rootUrl).then(function(meshes) {
                        return {
                          meshes,
                          particleSystems: [],
                          skeletons: [],
                          animationGroups: [],
                          transformNodes: [],
                          geometries: [],
                          lights: [],
                          spriteManagers: []
                        };
                      });
                    };
                    OBJFileLoader2.prototype.loadAsync = function(scene, data, rootUrl) {
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function() {
                      });
                    };
                    OBJFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl) {
                      var _this = this;
                      var container = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                      this._assetContainer = container;
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function(result) {
                        result.meshes.forEach(function(mesh) {
                          return container.meshes.push(mesh);
                        });
                        result.meshes.forEach(function(mesh) {
                          var material = mesh.material;
                          if (material) {
                            if (container.materials.indexOf(material) == -1) {
                              container.materials.push(material);
                              var textures = material.getActiveTextures();
                              textures.forEach(function(t) {
                                if (container.textures.indexOf(t) == -1) {
                                  container.textures.push(t);
                                }
                              });
                            }
                          }
                        });
                        _this._assetContainer = null;
                        return container;
                      }).catch(function(ex) {
                        _this._assetContainer = null;
                        throw ex;
                      });
                    };
                    OBJFileLoader2.prototype._parseSolid = function(meshesNames, scene, data, rootUrl) {
                      var _this = this;
                      var fileToLoad = "";
                      var materialsFromMTLFile = new _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader();
                      var materialToUse = [];
                      var babylonMeshesArray = [];
                      data = data.replace(/#.*$/gm, "").trim();
                      var solidParser = new _solidParser__WEBPACK_IMPORTED_MODULE_3__.SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);
                      solidParser.parse(meshesNames, data, scene, this._assetContainer, function(fileName) {
                        fileToLoad = fileName;
                      });
                      var mtlPromises = [];
                      if (fileToLoad !== "" && !this._loadingOptions.skipMaterials) {
                        mtlPromises.push(new Promise(function(resolve, reject) {
                          _this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {
                            try {
                              materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._assetContainer);
                              for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {
                                var startIndex = 0;
                                var _indices = [];
                                var _index = void 0;
                                while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {
                                  _indices.push(_index);
                                  startIndex = _index + 1;
                                }
                                if (_index === -1 && _indices.length === 0) {
                                  materialsFromMTLFile.materials[n].dispose();
                                } else {
                                  for (var o = 0; o < _indices.length; o++) {
                                    var mesh = babylonMeshesArray[_indices[o]];
                                    var material = materialsFromMTLFile.materials[n];
                                    mesh.material = material;
                                    if (!mesh.getTotalIndices()) {
                                      material.pointsCloud = true;
                                    }
                                  }
                                }
                              }
                              resolve();
                            } catch (e) {
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error processing MTL file: '".concat(fileToLoad, "'"));
                              if (_this._loadingOptions.materialLoadingFailsSilently) {
                                resolve();
                              } else {
                                reject(e);
                              }
                            }
                          }, function(pathOfFile, exception) {
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error downloading MTL file: '".concat(fileToLoad, "'"));
                            if (_this._loadingOptions.materialLoadingFailsSilently) {
                              resolve();
                            } else {
                              reject(exception);
                            }
                          });
                        }));
                      }
                      return Promise.all(mtlPromises).then(function() {
                        var isLine = function(mesh) {
                          var _a, _b;
                          return Boolean((_b = (_a = mesh._internalMetadata) === null || _a === void 0 ? void 0 : _a["_isLine"]) !== null && _b !== void 0 ? _b : false);
                        };
                        babylonMeshesArray.forEach(function(mesh) {
                          var _a, _b;
                          if (isLine(mesh)) {
                            var mat = (_a = mesh.material) !== null && _a !== void 0 ? _a : new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(mesh.name + "_line", scene);
                            var needClone = mat.getBindedMeshes().filter(function(e) {
                              return !isLine(e);
                            }).length > 0;
                            if (needClone) {
                              mat = (_b = mat.clone(mat.name + "_line")) !== null && _b !== void 0 ? _b : mat;
                            }
                            mat.wireframe = true;
                            mesh.material = mat;
                            if (mesh._internalMetadata) {
                              mesh._internalMetadata["_isLine"] = void 0;
                            }
                          }
                        });
                        return babylonMeshesArray;
                      });
                    };
                    OBJFileLoader2.OPTIMIZE_WITH_UV = true;
                    OBJFileLoader2.INVERT_Y = false;
                    OBJFileLoader2.IMPORT_VERTEX_COLORS = false;
                    OBJFileLoader2.COMPUTE_NORMALS = false;
                    OBJFileLoader2.OPTIMIZE_NORMALS = false;
                    OBJFileLoader2.UV_SCALING = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);
                    OBJFileLoader2.SKIP_MATERIALS = false;
                    OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY = true;
                    OBJFileLoader2.USE_LEGACY_BEHAVIOR = false;
                    return OBJFileLoader2;
                  }()
                );
                (0, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new OBJFileLoader());
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/objLoadingOptions.ts": (
              /*!*********************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/objLoadingOptions.ts ***!
                \*********************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/solidParser.ts": (
              /*!***************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/solidParser.ts ***!
                \***************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  SolidParser: () => (
                    /* binding */
                    SolidParser
                  )
                  /* harmony export */
                });
                var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/logger */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__);
                var SolidParser = (
                  /** @class */
                  function() {
                    function SolidParser2(materialToUse, babylonMeshesArray, loadingOptions) {
                      this._positions = [];
                      this._normals = [];
                      this._uvs = [];
                      this._colors = [];
                      this._extColors = [];
                      this._meshesFromObj = [];
                      this._indicesForBabylon = [];
                      this._wrappedPositionForBabylon = [];
                      this._wrappedUvsForBabylon = [];
                      this._wrappedColorsForBabylon = [];
                      this._wrappedNormalsForBabylon = [];
                      this._tuplePosNorm = [];
                      this._curPositionInIndices = 0;
                      this._hasMeshes = false;
                      this._unwrappedPositionsForBabylon = [];
                      this._unwrappedColorsForBabylon = [];
                      this._unwrappedNormalsForBabylon = [];
                      this._unwrappedUVForBabylon = [];
                      this._triangles = [];
                      this._materialNameFromObj = "";
                      this._objMeshName = "";
                      this._increment = 1;
                      this._isFirstMaterial = true;
                      this._grayColor = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(0.5, 0.5, 0.5, 1);
                      this._hasLineData = false;
                      this._materialToUse = materialToUse;
                      this._babylonMeshesArray = babylonMeshesArray;
                      this._loadingOptions = loadingOptions;
                    }
                    SolidParser2.prototype._isInArray = function(arr, obj) {
                      if (!arr[obj[0]]) {
                        arr[obj[0]] = { normals: [], idx: [] };
                      }
                      var idx = arr[obj[0]].normals.indexOf(obj[1]);
                      return idx === -1 ? -1 : arr[obj[0]].idx[idx];
                    };
                    SolidParser2.prototype._isInArrayUV = function(arr, obj) {
                      if (!arr[obj[0]]) {
                        arr[obj[0]] = { normals: [], idx: [], uv: [] };
                      }
                      var idx = arr[obj[0]].normals.indexOf(obj[1]);
                      if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {
                        return arr[obj[0]].idx[idx];
                      }
                      return -1;
                    };
                    SolidParser2.prototype._setData = function(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {
                      var _index;
                      if (this._loadingOptions.optimizeWithUV) {
                        _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);
                      } else {
                        _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);
                      }
                      if (_index === -1) {
                        this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);
                        this._wrappedPositionForBabylon.push(positionVectorFromOBJ);
                        textureVectorFromOBJ = textureVectorFromOBJ !== null && textureVectorFromOBJ !== void 0 ? textureVectorFromOBJ : new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
                        this._wrappedUvsForBabylon.push(textureVectorFromOBJ);
                        this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);
                        if (positionColorsFromOBJ !== void 0) {
                          this._wrappedColorsForBabylon.push(positionColorsFromOBJ);
                        }
                        this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);
                        this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);
                        if (this._loadingOptions.optimizeWithUV) {
                          this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);
                        }
                      } else {
                        this._indicesForBabylon.push(_index);
                      }
                    };
                    SolidParser2.prototype._unwrapData = function() {
                      try {
                        for (var l = 0; l < this._wrappedPositionForBabylon.length; l++) {
                          this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);
                          this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);
                          this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y);
                          if (this._loadingOptions.importVertexColors) {
                            this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);
                          }
                        }
                        this._wrappedPositionForBabylon.length = 0;
                        this._wrappedNormalsForBabylon.length = 0;
                        this._wrappedUvsForBabylon.length = 0;
                        this._wrappedColorsForBabylon.length = 0;
                        this._tuplePosNorm.length = 0;
                        this._curPositionInIndices = 0;
                      } catch (e) {
                        throw new Error("Unable to unwrap data while parsing OBJ data.");
                      }
                    };
                    SolidParser2.prototype._getTriangles = function(faces, v) {
                      for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {
                        this._pushTriangle(faces, faceIndex);
                      }
                    };
                    SolidParser2.prototype._getColor = function(index) {
                      var _a;
                      if (this._loadingOptions.importVertexColors) {
                        return (_a = this._extColors[index]) !== null && _a !== void 0 ? _a : this._colors[index];
                      } else {
                        return void 0;
                      }
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern1 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var indicePositionFromObj = parseInt(this._triangles[k]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          0,
                          0,
                          // In the pattern 1, normals and uvs are not defined
                          this._positions[indicePositionFromObj],
                          // Get the vectors data
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(),
                          // Create default vectors
                          this._getColor(indicePositionFromObj)
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern2 = function(face, v) {
                      var _a;
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceUvsFromObj = parseInt(point[1]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          0,
                          //Default value for normals
                          this._positions[indicePositionFromObj],
                          //Get the values for each element
                          (_a = this._uvs[indiceUvsFromObj]) !== null && _a !== void 0 ? _a : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(),
                          //Default value for normals
                          this._getColor(indicePositionFromObj)
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern3 = function(face, v) {
                      var _a, _b;
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceUvsFromObj = parseInt(point[1]) - 1;
                        var indiceNormalFromObj = parseInt(point[2]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          (_a = this._uvs[indiceUvsFromObj]) !== null && _a !== void 0 ? _a : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          (_b = this._normals[indiceNormalFromObj]) !== null && _b !== void 0 ? _b : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up()
                          //Set the vector for each component
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern4 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("//");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceNormalFromObj = parseInt(point[1]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          1,
                          //Default value for uv
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          //Get each vector of data
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          this._normals[indiceNormalFromObj],
                          this._getColor(indicePositionFromObj)
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern5 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = this._positions.length + parseInt(point[0]);
                        var indiceUvsFromObj = this._uvs.length + parseInt(point[1]);
                        var indiceNormalFromObj = this._normals.length + parseInt(point[2]);
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          this._uvs[indiceUvsFromObj],
                          this._normals[indiceNormalFromObj],
                          //Set the vector for each component
                          this._getColor(indicePositionFromObj)
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._addPreviousObjMesh = function() {
                      if (this._meshesFromObj.length > 0) {
                        this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
                        this._unwrapData();
                        if (this._loadingOptions.useLegacyBehavior) {
                          this._indicesForBabylon.reverse();
                        }
                        this._handledMesh.indices = this._indicesForBabylon.slice();
                        this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();
                        this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();
                        this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();
                        this._handledMesh.hasLines = this._hasLineData;
                        if (this._loadingOptions.importVertexColors) {
                          this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();
                        }
                        this._indicesForBabylon.length = 0;
                        this._unwrappedPositionsForBabylon.length = 0;
                        this._unwrappedColorsForBabylon.length = 0;
                        this._unwrappedNormalsForBabylon.length = 0;
                        this._unwrappedUVForBabylon.length = 0;
                        this._hasLineData = false;
                      }
                    };
                    SolidParser2.prototype._optimizeNormals = function(mesh) {
                      var positions = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                      var normals = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                      var mapVertices = {};
                      if (!positions || !normals) {
                        return;
                      }
                      for (var i = 0; i < positions.length / 3; i++) {
                        var x = positions[i * 3 + 0];
                        var y = positions[i * 3 + 1];
                        var z = positions[i * 3 + 2];
                        var key = x + "_" + y + "_" + z;
                        var lst = mapVertices[key];
                        if (!lst) {
                          lst = [];
                          mapVertices[key] = lst;
                        }
                        lst.push(i);
                      }
                      var normal = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                      for (var key in mapVertices) {
                        var lst = mapVertices[key];
                        if (lst.length < 2) {
                          continue;
                        }
                        var v0Idx = lst[0];
                        for (var i = 1; i < lst.length; ++i) {
                          var vIdx = lst[i];
                          normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];
                          normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];
                          normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];
                        }
                        normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);
                        normal.normalize();
                        for (var i = 0; i < lst.length; ++i) {
                          var vIdx = lst[i];
                          normals[vIdx * 3 + 0] = normal.x;
                          normals[vIdx * 3 + 1] = normal.y;
                          normals[vIdx * 3 + 2] = normal.z;
                        }
                      }
                      mesh.setVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                    };
                    SolidParser2._IsLineElement = function(line) {
                      return line.startsWith("l");
                    };
                    SolidParser2._IsObjectElement = function(line) {
                      return line.startsWith("o");
                    };
                    SolidParser2._IsGroupElement = function(line) {
                      return line.startsWith("g");
                    };
                    SolidParser2._GetZbrushMRGB = function(line, notParse) {
                      if (!line.startsWith("mrgb"))
                        return null;
                      line = line.replace("mrgb", "").trim();
                      if (notParse)
                        return [];
                      var regex = /[a-z0-9]/g;
                      var regArray = line.match(regex);
                      if (!regArray || regArray.length % 8 !== 0) {
                        return [];
                      }
                      var array = [];
                      for (var regIndex = 0; regIndex < regArray.length / 8; regIndex++) {
                        var r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];
                        var g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];
                        var b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];
                        array.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));
                      }
                      return array;
                    };
                    SolidParser2.prototype.parse = function(meshesNames, data, scene, assetContainer, onFileToLoadFound) {
                      var _this = this;
                      var _a, _b;
                      data = data.replace(/#MRGB/g, "mrgb");
                      data = data.replace(/#.*$/gm, "").trim();
                      if (this._loadingOptions.useLegacyBehavior) {
                        this._pushTriangle = function(faces, faceIndex) {
                          return _this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
                        };
                        this._handednessSign = 1;
                      } else if (scene.useRightHandedSystem) {
                        this._pushTriangle = function(faces, faceIndex) {
                          return _this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);
                        };
                        this._handednessSign = 1;
                      } else {
                        this._pushTriangle = function(faces, faceIndex) {
                          return _this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
                        };
                        this._handednessSign = -1;
                      }
                      var linesOBJ = data.split("\n");
                      var lineLines = [];
                      var currentGroup = [];
                      lineLines.push(currentGroup);
                      for (var i = 0; i < linesOBJ.length; i++) {
                        var line = linesOBJ[i].trim().replace(/\s\s/g, " ");
                        if (line.length === 0 || line.charAt(0) === "#") {
                          continue;
                        }
                        if (SolidParser2._IsGroupElement(line) || SolidParser2._IsObjectElement(line)) {
                          currentGroup = [];
                          lineLines.push(currentGroup);
                        }
                        if (SolidParser2._IsLineElement(line)) {
                          var lineValues = line.split(" ");
                          for (var i_1 = 1; i_1 < lineValues.length - 1; i_1++) {
                            currentGroup.push("l ".concat(lineValues[i_1], " ").concat(lineValues[i_1 + 1]));
                          }
                        } else {
                          currentGroup.push(line);
                        }
                      }
                      var lines = lineLines.flat();
                      for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim().replace(/\s\s/g, " ");
                        var result = void 0;
                        if (line.length === 0 || line.charAt(0) === "#") {
                          continue;
                        } else if (SolidParser2.VertexPattern.test(line)) {
                          result = line.match(/[^ ]+/g);
                          this._positions.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
                          if (this._loadingOptions.importVertexColors) {
                            if (result.length >= 7) {
                              var r = parseFloat(result[4]);
                              var g = parseFloat(result[5]);
                              var b = parseFloat(result[6]);
                              this._colors.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === void 0 ? 1 : parseFloat(result[7])));
                            } else {
                              this._colors.push(this._grayColor);
                            }
                          }
                        } else if ((result = SolidParser2.NormalPattern.exec(line)) !== null) {
                          this._normals.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
                        } else if ((result = SolidParser2.UVPattern.exec(line)) !== null) {
                          this._uvs.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));
                        } else if ((result = SolidParser2.FacePattern3.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern3(
                            result[1].trim().split(" "),
                            // ["1/1/1", "2/2/2", "3/3/3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern4.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern4(
                            result[1].trim().split(" "),
                            // ["1//1", "2//2", "3//3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern5.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern5(
                            result[1].trim().split(" "),
                            // ["-1/-1/-1", "-2/-2/-2", "-3/-3/-3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern2.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern2(
                            result[1].trim().split(" "),
                            // ["1/1", "2/2", "3/3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern1.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern1(
                            result[1].trim().split(" "),
                            // ["1", "2", "3"]
                            1
                          );
                        } else if ((result = SolidParser2.LinePattern1.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern1(
                            result[1].trim().split(" "),
                            // ["1", "2"]
                            0
                          );
                          this._hasLineData = true;
                        } else if ((result = SolidParser2.LinePattern2.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern2(
                            result[1].trim().split(" "),
                            // ["1/1", "2/2"]
                            0
                          );
                          this._hasLineData = true;
                        } else if (result = SolidParser2._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors)) {
                          result.forEach(function(element) {
                            _this._extColors.push(element);
                          });
                        } else if ((result = SolidParser2.LinePattern3.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern3(
                            result[1].trim().split(" "),
                            // ["1/1/1", "2/2/2"]
                            0
                          );
                          this._hasLineData = true;
                        } else if (SolidParser2.GroupDescriptor.test(line) || SolidParser2.ObjectDescriptor.test(line)) {
                          var objMesh = {
                            name: line.substring(2).trim(),
                            //Set the name of the current obj mesh
                            indices: null,
                            positions: null,
                            normals: null,
                            uvs: null,
                            colors: null,
                            materialName: this._materialNameFromObj,
                            isObject: SolidParser2.ObjectDescriptor.test(line)
                          };
                          this._addPreviousObjMesh();
                          this._meshesFromObj.push(objMesh);
                          this._hasMeshes = true;
                          this._isFirstMaterial = true;
                          this._increment = 1;
                        } else if (SolidParser2.UseMtlDescriptor.test(line)) {
                          this._materialNameFromObj = line.substring(7).trim();
                          if (!this._isFirstMaterial || !this._hasMeshes) {
                            this._addPreviousObjMesh();
                            var objMesh = (
                              //Set the name of the current obj mesh
                              {
                                name: (this._objMeshName || "mesh") + "_mm" + this._increment.toString(),
                                //Set the name of the current obj mesh
                                indices: null,
                                positions: null,
                                normals: null,
                                uvs: null,
                                colors: null,
                                materialName: this._materialNameFromObj,
                                isObject: false
                              }
                            );
                            this._increment++;
                            this._meshesFromObj.push(objMesh);
                            this._hasMeshes = true;
                          }
                          if (this._hasMeshes && this._isFirstMaterial) {
                            this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;
                            this._isFirstMaterial = false;
                          }
                        } else if (SolidParser2.MtlLibGroupDescriptor.test(line)) {
                          onFileToLoadFound(line.substring(7).trim());
                        } else if (SolidParser2.SmoothDescriptor.test(line)) {
                        } else {
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Logger.Log("Unhandled expression at line : " + line);
                        }
                      }
                      if (this._hasMeshes) {
                        this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
                        if (this._loadingOptions.useLegacyBehavior) {
                          this._indicesForBabylon.reverse();
                        }
                        this._unwrapData();
                        this._handledMesh.indices = this._indicesForBabylon;
                        this._handledMesh.positions = this._unwrappedPositionsForBabylon;
                        this._handledMesh.normals = this._unwrappedNormalsForBabylon;
                        this._handledMesh.uvs = this._unwrappedUVForBabylon;
                        this._handledMesh.hasLines = this._hasLineData;
                        if (this._loadingOptions.importVertexColors) {
                          this._handledMesh.colors = this._unwrappedColorsForBabylon;
                        }
                      }
                      if (!this._hasMeshes) {
                        var newMaterial = null;
                        if (this._indicesForBabylon.length) {
                          if (this._loadingOptions.useLegacyBehavior) {
                            this._indicesForBabylon.reverse();
                          }
                          this._unwrapData();
                        } else {
                          for (var _i = 0, _c = this._positions; _i < _c.length; _i++) {
                            var pos = _c[_i];
                            this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);
                          }
                          if (this._normals.length) {
                            for (var _d = 0, _e = this._normals; _d < _e.length; _d++) {
                              var normal = _e[_d];
                              this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);
                            }
                          }
                          if (this._uvs.length) {
                            for (var _f = 0, _g = this._uvs; _f < _g.length; _f++) {
                              var uv = _g[_f];
                              this._unwrappedUVForBabylon.push(uv.x, uv.y);
                            }
                          }
                          if (this._extColors.length) {
                            for (var _h = 0, _j = this._extColors; _h < _j.length; _h++) {
                              var color = _j[_h];
                              this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
                            }
                          } else {
                            if (this._colors.length) {
                              for (var _k = 0, _l = this._colors; _k < _l.length; _k++) {
                                var color = _l[_k];
                                this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
                              }
                            }
                          }
                          if (!this._materialNameFromObj) {
                            newMaterial = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(), scene);
                            newMaterial.pointsCloud = true;
                            this._materialNameFromObj = newMaterial.name;
                            if (!this._normals.length) {
                              newMaterial.disableLighting = true;
                              newMaterial.emissiveColor = babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                            }
                          }
                        }
                        this._meshesFromObj.push({
                          name: babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(),
                          indices: this._indicesForBabylon,
                          positions: this._unwrappedPositionsForBabylon,
                          colors: this._unwrappedColorsForBabylon,
                          normals: this._unwrappedNormalsForBabylon,
                          uvs: this._unwrappedUVForBabylon,
                          materialName: this._materialNameFromObj,
                          directMaterial: newMaterial,
                          isObject: true,
                          hasLines: this._hasLineData
                        });
                      }
                      for (var j = 0; j < this._meshesFromObj.length; j++) {
                        if (meshesNames && this._meshesFromObj[j].name) {
                          if (meshesNames instanceof Array) {
                            if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {
                              continue;
                            }
                          } else {
                            if (this._meshesFromObj[j].name !== meshesNames) {
                              continue;
                            }
                          }
                        }
                        this._handledMesh = this._meshesFromObj[j];
                        scene._blockEntityCollection = !!assetContainer;
                        var babylonMesh = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Mesh(this._meshesFromObj[j].name, scene);
                        babylonMesh._parentContainer = assetContainer;
                        scene._blockEntityCollection = false;
                        this._handledMesh._babylonMesh = babylonMesh;
                        if (!this._handledMesh.isObject) {
                          for (var k = j - 1; k >= 0; --k) {
                            if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {
                              babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;
                              break;
                            }
                          }
                        }
                        this._materialToUse.push(this._meshesFromObj[j].materialName);
                        if (this._handledMesh.hasLines) {
                          (_a = babylonMesh._internalMetadata) !== null && _a !== void 0 ? _a : babylonMesh._internalMetadata = {};
                          babylonMesh._internalMetadata["_isLine"] = true;
                        }
                        if (((_b = this._handledMesh.positions) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                          this._babylonMeshesArray.push(babylonMesh);
                          continue;
                        }
                        var vertexData = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData();
                        vertexData.uvs = this._handledMesh.uvs;
                        vertexData.indices = this._handledMesh.indices;
                        vertexData.positions = this._handledMesh.positions;
                        if (this._loadingOptions.computeNormals) {
                          var normals = new Array();
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);
                          vertexData.normals = normals;
                        } else {
                          vertexData.normals = this._handledMesh.normals;
                        }
                        if (this._loadingOptions.importVertexColors) {
                          vertexData.colors = this._handledMesh.colors;
                        }
                        vertexData.applyToMesh(babylonMesh);
                        if (this._loadingOptions.invertY) {
                          babylonMesh.scaling.y *= -1;
                        }
                        if (this._loadingOptions.optimizeNormals) {
                          this._optimizeNormals(babylonMesh);
                        }
                        this._babylonMeshesArray.push(babylonMesh);
                        if (this._handledMesh.directMaterial) {
                          babylonMesh.material = this._handledMesh.directMaterial;
                        }
                      }
                    };
                    SolidParser2.ObjectDescriptor = /^o/;
                    SolidParser2.GroupDescriptor = /^g/;
                    SolidParser2.MtlLibGroupDescriptor = /^mtllib /;
                    SolidParser2.UseMtlDescriptor = /^usemtl /;
                    SolidParser2.SmoothDescriptor = /^s /;
                    SolidParser2.VertexPattern = /^v(\s+[\d|.|+|\-|e|E]+){3,7}/;
                    SolidParser2.NormalPattern = /^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
                    SolidParser2.UVPattern = /^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
                    SolidParser2.FacePattern1 = /^f\s+(([\d]{1,}[\s]?){3,})+/;
                    SolidParser2.FacePattern2 = /^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern3 = /^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern4 = /^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern5 = /^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.LinePattern1 = /^l\s+(([\d]{1,}[\s]?){2,})+/;
                    SolidParser2.LinePattern2 = /^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
                    SolidParser2.LinePattern3 = /^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
                    return SolidParser2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/SPLAT/index.ts": (
              /*!***********************************************!*\
                !*** ../../../dev/loaders/src/SPLAT/index.ts ***!
                \***********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  SPLATFileLoader: () => (
                    /* reexport safe */
                    _splatFileLoader__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoader
                  )
                  /* harmony export */
                });
                var _splatLoadingOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./splatLoadingOptions */
                  "../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts"
                );
                var _splatFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./splatFileLoader */
                  "../../../dev/loaders/src/SPLAT/splatFileLoader.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts": (
              /*!******************************************************************!*\
                !*** ../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts ***!
                \******************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  SPLATFileLoaderMetadata: () => (
                    /* binding */
                    SPLATFileLoaderMetadata
                  )
                  /* harmony export */
                });
                var SPLATFileLoaderMetadata = {
                  name: "splat",
                  extensions: {
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".splat": { isBinary: true },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".ply": { isBinary: true },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".spz": { isBinary: true }
                  }
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/SPLAT/splatFileLoader.ts": (
              /*!*********************************************************!*\
                !*** ../../../dev/loaders/src/SPLAT/splatFileLoader.ts ***!
                \*********************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  SPLATFileLoader: () => (
                    /* binding */
                    SPLATFileLoader
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.scalar */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__);
                var _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./splatFileLoader.metadata */
                  "../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts"
                );
                var Mode;
                (function(Mode2) {
                  Mode2[Mode2["Splat"] = 0] = "Splat";
                  Mode2[Mode2["PointCloud"] = 1] = "PointCloud";
                  Mode2[Mode2["Mesh"] = 2] = "Mesh";
                  Mode2[Mode2["Reject"] = 3] = "Reject";
                })(Mode || (Mode = {}));
                var SPLATFileLoader = (
                  /** @class */
                  function() {
                    function SPLATFileLoader2(loadingOptions) {
                      if (loadingOptions === void 0) {
                        loadingOptions = SPLATFileLoader2._DefaultLoadingOptions;
                      }
                      this.name = _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.name;
                      this._assetContainer = null;
                      this.extensions = _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.extensions;
                      this._loadingOptions = loadingOptions;
                    }
                    SPLATFileLoader2.prototype.createPlugin = function(options) {
                      return new SPLATFileLoader2(options[_splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.name]);
                    };
                    SPLATFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl, onProgress, fileName) {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function() {
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_a) {
                          return [2, this._parse(meshesNames, scene, data, rootUrl).then(function(meshes) {
                            return {
                              meshes,
                              particleSystems: [],
                              skeletons: [],
                              animationGroups: [],
                              transformNodes: [],
                              geometries: [],
                              lights: [],
                              spriteManagers: []
                            };
                          })];
                        });
                      });
                    };
                    SPLATFileLoader2._BuildPointCloud = function(pointcloud, data) {
                      if (!data.byteLength) {
                        return false;
                      }
                      var uBuffer = new Uint8Array(data);
                      var fBuffer = new Float32Array(data);
                      var rowLength = 3 * 4 + 3 * 4 + 4 + 4;
                      var vertexCount = uBuffer.length / rowLength;
                      var pointcloudfunc = function(particle, i) {
                        var x = fBuffer[8 * i + 0];
                        var y = fBuffer[8 * i + 1];
                        var z = fBuffer[8 * i + 2];
                        particle.position = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);
                        var r = uBuffer[rowLength * i + 24 + 0] / 255;
                        var g = uBuffer[rowLength * i + 24 + 1] / 255;
                        var b = uBuffer[rowLength * i + 24 + 2] / 255;
                        particle.color = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Color4(r, g, b, 1);
                      };
                      pointcloud.addPoints(vertexCount, pointcloudfunc);
                      return true;
                    };
                    SPLATFileLoader2._BuildMesh = function(scene, parsedPLY) {
                      var mesh = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Mesh("PLYMesh", scene);
                      var uBuffer = new Uint8Array(parsedPLY.data);
                      var fBuffer = new Float32Array(parsedPLY.data);
                      var rowLength = 3 * 4 + 3 * 4 + 4 + 4;
                      var vertexCount = uBuffer.length / rowLength;
                      var positions = [];
                      var vertexData = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.VertexData();
                      for (var i = 0; i < vertexCount; i++) {
                        var x = fBuffer[8 * i + 0];
                        var y = fBuffer[8 * i + 1];
                        var z = fBuffer[8 * i + 2];
                        positions.push(x, y, z);
                      }
                      if (parsedPLY.hasVertexColors) {
                        var colors = new Float32Array(vertexCount * 4);
                        for (var i = 0; i < vertexCount; i++) {
                          var r = uBuffer[rowLength * i + 24 + 0] / 255;
                          var g = uBuffer[rowLength * i + 24 + 1] / 255;
                          var b = uBuffer[rowLength * i + 24 + 2] / 255;
                          colors[i * 4 + 0] = r;
                          colors[i * 4 + 1] = g;
                          colors[i * 4 + 2] = b;
                          colors[i * 4 + 3] = 1;
                        }
                        vertexData.colors = colors;
                      }
                      vertexData.positions = positions;
                      vertexData.indices = parsedPLY.faces;
                      vertexData.applyToMesh(mesh);
                      return mesh;
                    };
                    SPLATFileLoader2.prototype._parseSPZ = function(data, scene) {
                      var ubuf = new Uint8Array(data);
                      var ubufu32 = new Uint32Array(data.slice(0, 12));
                      var splatCount = ubufu32[2];
                      var shDegree = ubuf[12];
                      var fractionalBits = ubuf[13];
                      var reserved = ubuf[15];
                      if (reserved || ubufu32[0] != 1347635022 || ubufu32[1] != 2) {
                        return new Promise(function(resolve) {
                          resolve({ mode: 3, data: buffer, hasVertexColors: false });
                        });
                      }
                      var rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
                      var buffer = new ArrayBuffer(rowOutputLength * splatCount);
                      var positionScale = 1 / (1 << fractionalBits);
                      var int32View = new Int32Array(1);
                      var uint8View = new Uint8Array(int32View.buffer);
                      var read24bComponent = function(u8, offset) {
                        uint8View[0] = u8[offset + 0];
                        uint8View[1] = u8[offset + 1];
                        uint8View[2] = u8[offset + 2];
                        uint8View[3] = u8[offset + 2] & 128 ? 255 : 0;
                        return int32View[0] * positionScale;
                      };
                      var byteOffset = 16;
                      var position = new Float32Array(buffer);
                      var scale = new Float32Array(buffer);
                      var rgba = new Uint8ClampedArray(buffer);
                      var rot = new Uint8ClampedArray(buffer);
                      var coordinateSign = 1;
                      var quaternionOffset = 0;
                      if (!this._loadingOptions.flipY) {
                        coordinateSign = -1;
                        quaternionOffset = 255;
                      }
                      for (var i = 0; i < splatCount; i++) {
                        position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);
                        position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);
                        position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);
                        byteOffset += 9;
                      }
                      var SH_C0 = 0.282;
                      for (var i = 0; i < splatCount; i++) {
                        for (var component = 0; component < 3; component++) {
                          var byteValue = ubuf[byteOffset + splatCount + i * 3 + component];
                          var value = (byteValue - 127.5) / (0.15 * 255);
                          rgba[i * 32 + 24 + component] = babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Scalar.Clamp((0.5 + SH_C0 * value) * 255, 0, 255);
                        }
                        rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];
                      }
                      byteOffset += splatCount * 4;
                      for (var i = 0; i < splatCount; i++) {
                        scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16 - 10);
                        scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16 - 10);
                        scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16 - 10);
                        byteOffset += 3;
                      }
                      for (var i = 0; i < splatCount; i++) {
                        var x = ubuf[byteOffset + 0];
                        var y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;
                        var z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;
                        var nx = x / 127.5 - 1;
                        var ny = y / 127.5 - 1;
                        var nz = z / 127.5 - 1;
                        rot[i * 32 + 28 + 1] = x;
                        rot[i * 32 + 28 + 2] = y;
                        rot[i * 32 + 28 + 3] = z;
                        var v = 1 - (nx * nx + ny * ny + nz * nz);
                        rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;
                        byteOffset += 3;
                      }
                      if (shDegree) {
                        var shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
                        var shComponentCount = shVectorCount * 3;
                        var textureCount = Math.ceil(shComponentCount / 16);
                        var shIndexRead = byteOffset;
                        var sh_1 = [];
                        var engine = scene.getEngine();
                        var width = engine.getCaps().maxTextureSize;
                        var height = Math.ceil(splatCount / width);
                        for (var textureIndex = 0; textureIndex < textureCount; textureIndex++) {
                          var texture = new Uint8Array(height * width * 4 * 4);
                          sh_1.push(texture);
                        }
                        for (var i = 0; i < splatCount; i++) {
                          for (var shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {
                            var shValue = ubuf[shIndexRead++];
                            var textureIndex = Math.floor(shIndexWrite / 16);
                            var shArray = sh_1[textureIndex];
                            var byteIndexInTexture = shIndexWrite % 16;
                            var offsetPerSplat = i * 16;
                            shArray[byteIndexInTexture + offsetPerSplat] = shValue;
                          }
                        }
                        return new Promise(function(resolve) {
                          resolve({ mode: 0, data: buffer, hasVertexColors: false, sh: sh_1 });
                        });
                      }
                      return new Promise(function(resolve) {
                        resolve({ mode: 0, data: buffer, hasVertexColors: false });
                      });
                    };
                    SPLATFileLoader2.prototype._parse = function(meshesNames, scene, data, rootUrl) {
                      var _this = this;
                      var babylonMeshesArray = [];
                      var readableStream = new ReadableStream({
                        start: function(controller) {
                          controller.enqueue(new Uint8Array(data));
                          controller.close();
                        }
                      });
                      var decompressionStream = new DecompressionStream("gzip");
                      var decompressedStream = readableStream.pipeThrough(decompressionStream);
                      return new Promise(function(resolve) {
                        new Response(decompressedStream).arrayBuffer().then(function(buffer) {
                          _this._parseSPZ(buffer, scene).then(function(parsedSPZ) {
                            scene._blockEntityCollection = !!_this._assetContainer;
                            var gaussianSplatting = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh("GaussianSplatting", null, scene, _this._loadingOptions.keepInRam);
                            gaussianSplatting._parentContainer = _this._assetContainer;
                            babylonMeshesArray.push(gaussianSplatting);
                            gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);
                            scene._blockEntityCollection = false;
                            resolve(babylonMeshesArray);
                          });
                        }).catch(function() {
                          SPLATFileLoader2._ConvertPLYToSplat(data).then(function(parsedPLY) {
                            return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function() {
                              var _a, gaussianSplatting, pointcloud;
                              return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_b) {
                                switch (_b.label) {
                                  case 0:
                                    scene._blockEntityCollection = !!this._assetContainer;
                                    _a = parsedPLY.mode;
                                    switch (_a) {
                                      case 0:
                                        return [3, 1];
                                      case 1:
                                        return [3, 2];
                                      case 2:
                                        return [3, 6];
                                    }
                                    return [3, 7];
                                  case 1:
                                    {
                                      gaussianSplatting = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
                                      gaussianSplatting._parentContainer = this._assetContainer;
                                      babylonMeshesArray.push(gaussianSplatting);
                                      gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);
                                    }
                                    return [3, 8];
                                  case 2:
                                    pointcloud = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.PointsCloudSystem("PointCloud", 1, scene);
                                    if (!SPLATFileLoader2._BuildPointCloud(pointcloud, parsedPLY.data)) return [3, 4];
                                    return [4, pointcloud.buildMeshAsync().then(function(mesh) {
                                      babylonMeshesArray.push(mesh);
                                    })];
                                  case 3:
                                    _b.sent();
                                    return [3, 5];
                                  case 4:
                                    pointcloud.dispose();
                                    _b.label = 5;
                                  case 5:
                                    return [3, 8];
                                  case 6:
                                    {
                                      if (parsedPLY.faces) {
                                        babylonMeshesArray.push(SPLATFileLoader2._BuildMesh(scene, parsedPLY));
                                      } else {
                                        throw new Error("PLY mesh doesn't contain face informations.");
                                      }
                                    }
                                    return [3, 8];
                                  case 7:
                                    throw new Error("Unsupported Splat mode");
                                  case 8:
                                    scene._blockEntityCollection = false;
                                    resolve(babylonMeshesArray);
                                    return [
                                      2
                                      /*return*/
                                    ];
                                }
                              });
                            });
                          });
                        });
                      });
                    };
                    SPLATFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl) {
                      var _this = this;
                      var container = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                      this._assetContainer = container;
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function(result) {
                        result.meshes.forEach(function(mesh) {
                          return container.meshes.push(mesh);
                        });
                        _this._assetContainer = null;
                        return container;
                      }).catch(function(ex) {
                        _this._assetContainer = null;
                        throw ex;
                      });
                    };
                    SPLATFileLoader2.prototype.loadAsync = function(scene, data, rootUrl) {
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function() {
                      });
                    };
                    SPLATFileLoader2._ConvertPLYToSplat = function(data) {
                      var ubuf = new Uint8Array(data);
                      var header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
                      var headerEnd = "end_header\n";
                      var headerEndIndex = header.indexOf(headerEnd);
                      if (headerEndIndex < 0 || !header) {
                        return new Promise(function(resolve) {
                          resolve({ mode: 0, data });
                        });
                      }
                      var vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
                      var faceElement = /element face (\d+)\n/.exec(header);
                      var faceCount = 0;
                      if (faceElement) {
                        faceCount = parseInt(faceElement[1]);
                      }
                      var chunkElement = /element chunk (\d+)\n/.exec(header);
                      var chunkCount = 0;
                      if (chunkElement) {
                        chunkCount = parseInt(chunkElement[1]);
                      }
                      var rowVertexOffset = 0;
                      var rowChunkOffset = 0;
                      var offsets = {
                        double: 8,
                        int: 4,
                        uint: 4,
                        float: 4,
                        short: 2,
                        ushort: 2,
                        uchar: 1,
                        list: 0
                      };
                      var ElementMode;
                      (function(ElementMode2) {
                        ElementMode2[ElementMode2["Vertex"] = 0] = "Vertex";
                        ElementMode2[ElementMode2["Chunk"] = 1] = "Chunk";
                      })(ElementMode || (ElementMode = {}));
                      var chunkMode = 1;
                      var vertexProperties = [];
                      var chunkProperties = [];
                      var filtered = header.slice(0, headerEndIndex).split("\n");
                      for (var _i = 0, filtered_1 = filtered; _i < filtered_1.length; _i++) {
                        var prop = filtered_1[_i];
                        if (prop.startsWith("property ")) {
                          var _a = prop.split(" "), type = _a[1], name_1 = _a[2];
                          if (chunkMode == 1) {
                            chunkProperties.push({ name: name_1, type, offset: rowChunkOffset });
                            rowChunkOffset += offsets[type];
                          } else if (chunkMode == 0) {
                            vertexProperties.push({ name: name_1, type, offset: rowVertexOffset });
                            rowVertexOffset += offsets[type];
                          }
                          if (!offsets[type]) {
                            babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Unsupported property type: ".concat(type, "."));
                          }
                        } else if (prop.startsWith("element ")) {
                          var _b = prop.split(" "), type = _b[1];
                          if (type == "chunk") {
                            chunkMode = 1;
                          } else if (type == "vertex") {
                            chunkMode = 0;
                          }
                        }
                      }
                      var rowVertexLength = rowVertexOffset;
                      var rowChunkLength = rowChunkOffset;
                      return babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(function(splatsData) {
                        var dataView = new DataView(data, headerEndIndex + headerEnd.length);
                        var offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;
                        var faces = [];
                        if (faceCount) {
                          for (var i = 0; i < faceCount; i++) {
                            var faceVertexCount = dataView.getUint8(offset);
                            if (faceVertexCount != 3) {
                              continue;
                            }
                            offset += 1;
                            for (var j = 0; j < faceVertexCount; j++) {
                              var vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true);
                              faces.push(vertexIndex);
                            }
                            offset += 12;
                          }
                        }
                        if (chunkCount) {
                          return new Promise(function(resolve) {
                            resolve({ mode: 0, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: false });
                          });
                        }
                        var propertyCount = 0;
                        var propertyColorCount = 0;
                        var splatProperties = ["x", "y", "z", "scale_0", "scale_1", "scale_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3"];
                        var splatColorProperties = ["red", "green", "blue", "f_dc_0", "f_dc_1", "f_dc_2"];
                        for (var propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {
                          var property = vertexProperties[propertyIndex];
                          if (splatProperties.includes(property.name)) {
                            propertyCount++;
                          }
                          if (splatColorProperties.includes(property.name)) {
                            propertyColorCount++;
                          }
                        }
                        var hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;
                        var currentMode = faceCount ? 2 : hasMandatoryProperties ? 0 : 1;
                        return new Promise(function(resolve) {
                          resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: !!propertyColorCount });
                        });
                      });
                    };
                    SPLATFileLoader2._DefaultLoadingOptions = {
                      keepInRam: false,
                      flipY: false
                    };
                    return SPLATFileLoader2;
                  }()
                );
                (0, babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new SPLATFileLoader());
              }
            ),
            /***/
            "../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts": (
              /*!*************************************************************!*\
                !*** ../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts ***!
                \*************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/STL/index.ts": (
              /*!*********************************************!*\
                !*** ../../../dev/loaders/src/STL/index.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  )
                  /* harmony export */
                });
                var _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./stlFileLoader */
                  "../../../dev/loaders/src/STL/stlFileLoader.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/STL/stlFileLoader.metadata.ts": (
              /*!**************************************************************!*\
                !*** ../../../dev/loaders/src/STL/stlFileLoader.metadata.ts ***!
                \**************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoaderMetadata: () => (
                    /* binding */
                    STLFileLoaderMetadata
                  )
                  /* harmony export */
                });
                var STLFileLoaderMetadata = {
                  name: "stl",
                  extensions: {
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".stl": { isBinary: true }
                  }
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/STL/stlFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/STL/stlFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* binding */
                    STLFileLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/standardMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);
                var _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./stlFileLoader.metadata */
                  "../../../dev/loaders/src/STL/stlFileLoader.metadata.ts"
                );
                var STLFileLoader = (
                  /** @class */
                  function() {
                    function STLFileLoader2() {
                      this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
                      this.facetsPattern = /facet([\s\S]*?)endfacet/g;
                      this.normalPattern = /normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
                      this.vertexPattern = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
                      this.name = _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.STLFileLoaderMetadata.name;
                      this.extensions = _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.STLFileLoaderMetadata.extensions;
                    }
                    STLFileLoader2.prototype.importMesh = function(meshesNames, scene, data, rootUrl, meshes) {
                      var matches;
                      if (typeof data !== "string") {
                        if (this._isBinary(data)) {
                          var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh("stlmesh", scene);
                          this._parseBinary(babylonMesh, data);
                          if (meshes) {
                            meshes.push(babylonMesh);
                          }
                          return true;
                        }
                        data = new TextDecoder().decode(new Uint8Array(data));
                      }
                      while (matches = this.solidPattern.exec(data)) {
                        var meshName = matches[1];
                        var meshNameFromEnd = matches[3];
                        if (meshNameFromEnd && meshName != meshNameFromEnd) {
                          babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.Error("Error in STL, solid name != endsolid name");
                          return false;
                        }
                        if (meshesNames && meshName) {
                          if (meshesNames instanceof Array) {
                            if (!meshesNames.indexOf(meshName)) {
                              continue;
                            }
                          } else {
                            if (meshName !== meshesNames) {
                              continue;
                            }
                          }
                        }
                        meshName = meshName || "stlmesh";
                        var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh(meshName, scene);
                        this._parseASCII(babylonMesh, matches[2]);
                        if (meshes) {
                          meshes.push(babylonMesh);
                        }
                      }
                      return true;
                    };
                    STLFileLoader2.prototype.load = function(scene, data, rootUrl) {
                      var result = this.importMesh(null, scene, data, rootUrl, null);
                      return result;
                    };
                    STLFileLoader2.prototype.loadAssetContainer = function(scene, data, rootUrl) {
                      var container = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                      scene._blockEntityCollection = true;
                      this.importMesh(null, scene, data, rootUrl, container.meshes);
                      scene._blockEntityCollection = false;
                      return container;
                    };
                    STLFileLoader2.prototype._isBinary = function(data) {
                      var reader = new DataView(data);
                      if (reader.byteLength <= 80) {
                        return false;
                      }
                      var faceSize = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
                      var nFaces = reader.getUint32(80, true);
                      if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
                        return true;
                      }
                      var ascii = [115, 111, 108, 105, 100];
                      for (var off = 0; off < 5; off++) {
                        if (reader.getUint8(off) !== ascii[off]) {
                          return true;
                        }
                      }
                      return false;
                    };
                    STLFileLoader2.prototype._parseBinary = function(mesh, data) {
                      var reader = new DataView(data);
                      var faces = reader.getUint32(80, true);
                      var dataOffset = 84;
                      var faceLength = 12 * 4 + 2;
                      var offset = 0;
                      var positions = new Float32Array(faces * 3 * 3);
                      var normals = new Float32Array(faces * 3 * 3);
                      var indices = new Uint32Array(faces * 3);
                      var indicesCount = 0;
                      for (var face = 0; face < faces; face++) {
                        var start = dataOffset + face * faceLength;
                        var normalX = reader.getFloat32(start, true);
                        var normalY = reader.getFloat32(start + 4, true);
                        var normalZ = reader.getFloat32(start + 8, true);
                        for (var i = 1; i <= 3; i++) {
                          var vertexstart = start + i * 12;
                          positions[offset] = reader.getFloat32(vertexstart, true);
                          normals[offset] = normalX;
                          if (!STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                            positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
                            positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
                            normals[offset + 2] = normalY;
                            normals[offset + 1] = normalZ;
                          } else {
                            positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);
                            positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);
                            normals[offset + 1] = normalY;
                            normals[offset + 2] = normalZ;
                          }
                          offset += 3;
                        }
                        if (STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                          indices[indicesCount] = indicesCount;
                          indices[indicesCount + 1] = indicesCount + 2;
                          indices[indicesCount + 2] = indicesCount + 1;
                          indicesCount += 3;
                        } else {
                          indices[indicesCount] = indicesCount++;
                          indices[indicesCount] = indicesCount++;
                          indices[indicesCount] = indicesCount++;
                        }
                      }
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                      mesh.setIndices(indices);
                      mesh.computeWorldMatrix(true);
                    };
                    STLFileLoader2.prototype._parseASCII = function(mesh, solidData) {
                      var positions = [];
                      var normals = [];
                      var indices = [];
                      var indicesCount = 0;
                      var matches;
                      while (matches = this.facetsPattern.exec(solidData)) {
                        var facet = matches[1];
                        var normalMatches = this.normalPattern.exec(facet);
                        this.normalPattern.lastIndex = 0;
                        if (!normalMatches) {
                          continue;
                        }
                        var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
                        var vertexMatch = void 0;
                        while (vertexMatch = this.vertexPattern.exec(facet)) {
                          if (!STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                            positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
                            normals.push(normal[0], normal[1], normal[2]);
                          } else {
                            positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));
                            normals.push(normal[0], normal[2], normal[1]);
                          }
                        }
                        if (STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
                          indicesCount += 3;
                        } else {
                          indices.push(indicesCount++, indicesCount++, indicesCount++);
                        }
                        this.vertexPattern.lastIndex = 0;
                      }
                      this.facetsPattern.lastIndex = 0;
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                      mesh.setIndices(indices);
                      mesh.computeWorldMatrix(true);
                    };
                    STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES = false;
                    return STLFileLoader2;
                  }()
                );
                (0, babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new STLFileLoader());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFBinaryExtension: () => (
                    /* binding */
                    GLTFBinaryExtension
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var BinaryExtensionBufferName = "binary_glTF";
                var GLTFBinaryExtension = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(GLTFBinaryExtension2, _super);
                    function GLTFBinaryExtension2() {
                      return _super.call(this, "KHR_binary_glTF") || this;
                    }
                    GLTFBinaryExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess) {
                      var extensionsUsed = data.json.extensionsUsed;
                      if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
                        return false;
                      }
                      this._bin = data.bin;
                      onSuccess(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
                        return false;
                      }
                      if (id !== BinaryExtensionBufferName) {
                        return false;
                      }
                      this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, function(error) {
                        return onError(error.message);
                      });
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess) {
                      var texture = gltfRuntime.textures[id];
                      var source = gltfRuntime.images[texture.source];
                      if (!source.extensions || !(this.name in source.extensions)) {
                        return false;
                      }
                      var sourceExt = source.extensions[this.name];
                      var bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
                      var buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
                      onSuccess(buffer);
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess) {
                      var shader = gltfRuntime.shaders[id];
                      if (!shader.extensions || !(this.name in shader.extensions)) {
                        return false;
                      }
                      var binaryExtensionShader = shader.extensions[this.name];
                      var bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
                      var shaderBytes = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
                      setTimeout(function() {
                        var shaderString = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.DecodeBufferToText(shaderBytes);
                        onSuccess(shaderString);
                      });
                      return true;
                    };
                    return GLTFBinaryExtension2;
                  }(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension)
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFBinaryExtension());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFLoader: () => (
                    /* binding */
                    GLTFLoader
                  ),
                  /* harmony export */
                  GLTFLoaderBase: () => (
                    /* binding */
                    GLTFLoaderBase
                  ),
                  /* harmony export */
                  GLTFLoaderExtension: () => (
                    /* binding */
                    GLTFLoaderExtension
                  )
                  /* harmony export */
                });
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Engines/constants */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var ETokenType;
                (function(ETokenType2) {
                  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
                  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
                  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
                })(ETokenType || (ETokenType = {}));
                var Tokenizer = (
                  /** @class */
                  function() {
                    function Tokenizer2(toParse) {
                      this._pos = 0;
                      this.currentToken = ETokenType.UNKNOWN;
                      this.currentIdentifier = "";
                      this.currentString = "";
                      this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
                      this._toParse = toParse;
                      this._maxPos = toParse.length;
                    }
                    Tokenizer2.prototype.getNextToken = function() {
                      if (this.isEnd()) {
                        return ETokenType.END_OF_INPUT;
                      }
                      this.currentString = this.read();
                      this.currentToken = ETokenType.UNKNOWN;
                      if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
                        this.currentToken = ETokenType.IDENTIFIER;
                        this.currentIdentifier = this.currentString;
                        while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
                          this.currentIdentifier += this.currentString;
                          this.forward();
                        }
                      }
                      return this.currentToken;
                    };
                    Tokenizer2.prototype.peek = function() {
                      return this._toParse[this._pos];
                    };
                    Tokenizer2.prototype.read = function() {
                      return this._toParse[this._pos++];
                    };
                    Tokenizer2.prototype.forward = function() {
                      this._pos++;
                    };
                    Tokenizer2.prototype.isEnd = function() {
                      return this._pos >= this._maxPos;
                    };
                    return Tokenizer2;
                  }()
                );
                var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
                var babylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
                var glTFAnimationPaths = ["translation", "rotation", "scale"];
                var babylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
                var parseBuffers = function(parsedBuffers, gltfRuntime) {
                  for (var buf in parsedBuffers) {
                    var parsedBuffer = parsedBuffers[buf];
                    gltfRuntime.buffers[buf] = parsedBuffer;
                    gltfRuntime.buffersCount++;
                  }
                };
                var parseShaders = function(parsedShaders, gltfRuntime) {
                  for (var sha in parsedShaders) {
                    var parsedShader = parsedShaders[sha];
                    gltfRuntime.shaders[sha] = parsedShader;
                    gltfRuntime.shaderscount++;
                  }
                };
                var parseObject = function(parsedObjects, runtimeProperty, gltfRuntime) {
                  for (var object in parsedObjects) {
                    var parsedObject = parsedObjects[object];
                    gltfRuntime[runtimeProperty][object] = parsedObject;
                  }
                };
                var normalizeUVs = function(buffer) {
                  if (!buffer) {
                    return;
                  }
                  for (var i = 0; i < buffer.length / 2; i++) {
                    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
                  }
                };
                var getAttribute = function(attributeParameter) {
                  if (attributeParameter.semantic === "NORMAL") {
                    return "normal";
                  } else if (attributeParameter.semantic === "POSITION") {
                    return "position";
                  } else if (attributeParameter.semantic === "JOINT") {
                    return "matricesIndices";
                  } else if (attributeParameter.semantic === "WEIGHT") {
                    return "matricesWeights";
                  } else if (attributeParameter.semantic === "COLOR") {
                    return "color";
                  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
                    var channel = Number(attributeParameter.semantic.split("_")[1]);
                    return "uv" + (channel === 0 ? "" : channel + 1);
                  }
                  return null;
                };
                var loadAnimations = function(gltfRuntime) {
                  for (var anim in gltfRuntime.animations) {
                    var animation = gltfRuntime.animations[anim];
                    if (!animation.channels || !animation.samplers) {
                      continue;
                    }
                    var lastAnimation = null;
                    for (var i = 0; i < animation.channels.length; i++) {
                      var channel = animation.channels[i];
                      var sampler = animation.samplers[channel.sampler];
                      if (!sampler) {
                        continue;
                      }
                      var inputData = null;
                      var outputData = null;
                      if (animation.parameters) {
                        inputData = animation.parameters[sampler.input];
                        outputData = animation.parameters[sampler.output];
                      } else {
                        inputData = sampler.input;
                        outputData = sampler.output;
                      }
                      var bufferInput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
                      var bufferOutput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
                      var targetId = channel.target.id;
                      var targetNode = gltfRuntime.scene.getNodeById(targetId);
                      if (targetNode === null) {
                        targetNode = gltfRuntime.scene.getNodeByName(targetId);
                      }
                      if (targetNode === null) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
                        continue;
                      }
                      var isBone = targetNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone;
                      var targetPath = channel.target.path;
                      var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
                      if (targetPathIndex !== -1) {
                        targetPath = babylonAnimationPaths[targetPathIndex];
                      }
                      var animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_MATRIX;
                      if (!isBone) {
                        if (targetPath === "rotationQuaternion") {
                          animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_QUATERNION;
                          targetNode.rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                        } else {
                          animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_VECTOR3;
                        }
                      }
                      var babylonAnimation = null;
                      var keys = [];
                      var arrayOffset = 0;
                      var modifyKey = false;
                      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
                        babylonAnimation = lastAnimation;
                        modifyKey = true;
                      }
                      if (!modifyKey) {
                        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                        babylonAnimation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONLOOPMODE_CYCLE);
                        gltfRuntime.scene._blockEntityCollection = false;
                      }
                      for (var j = 0; j < bufferInput.length; j++) {
                        var value = null;
                        if (targetPath === "rotationQuaternion") {
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
                          arrayOffset += 4;
                        } else {
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
                          arrayOffset += 3;
                        }
                        if (isBone) {
                          var bone = targetNode;
                          var translation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                          var rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                          var scaling = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                          var mat = bone.getBaseMatrix();
                          if (modifyKey && lastAnimation) {
                            mat = lastAnimation.getKeys()[j].value;
                          }
                          mat.decompose(scaling, rotationQuaternion, translation);
                          if (targetPath === "position") {
                            translation = value;
                          } else if (targetPath === "rotationQuaternion") {
                            rotationQuaternion = value;
                          } else {
                            scaling = value;
                          }
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scaling, rotationQuaternion, translation);
                        }
                        if (!modifyKey) {
                          keys.push({
                            frame: bufferInput[j],
                            value
                          });
                        } else if (lastAnimation) {
                          lastAnimation.getKeys()[j].value = value;
                        }
                      }
                      if (!modifyKey && babylonAnimation) {
                        babylonAnimation.setKeys(keys);
                        targetNode.animations.push(babylonAnimation);
                      }
                      lastAnimation = babylonAnimation;
                      gltfRuntime.scene.stopAnimation(targetNode);
                      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
                    }
                  }
                };
                var configureBoneTransformation = function(node) {
                  var mat = null;
                  if (node.translation || node.rotation || node.scale) {
                    var scale = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale || [1, 1, 1]);
                    var rotation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
                    var position = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation || [0, 0, 0]);
                    mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scale, rotation, position);
                  } else {
                    mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
                  }
                  return mat;
                };
                var getParentBone = function(gltfRuntime, skins, jointName, newSkeleton) {
                  for (var i = 0; i < newSkeleton.bones.length; i++) {
                    if (newSkeleton.bones[i].name === jointName) {
                      return newSkeleton.bones[i];
                    }
                  }
                  var nodes = gltfRuntime.nodes;
                  for (var nde in nodes) {
                    var node = nodes[nde];
                    if (!node.jointName) {
                      continue;
                    }
                    var children = node.children;
                    for (var i = 0; i < children.length; i++) {
                      var child = gltfRuntime.nodes[children[i]];
                      if (!child.jointName) {
                        continue;
                      }
                      if (child.jointName === jointName) {
                        var mat = configureBoneTransformation(node);
                        var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
                        bone.id = nde;
                        return bone;
                      }
                    }
                  }
                  return null;
                };
                var getNodeToRoot = function(nodesToRoot, id) {
                  for (var i = 0; i < nodesToRoot.length; i++) {
                    var nodeToRoot = nodesToRoot[i];
                    for (var j = 0; j < nodeToRoot.node.children.length; j++) {
                      var child = nodeToRoot.node.children[j];
                      if (child === id) {
                        return nodeToRoot.bone;
                      }
                    }
                  }
                  return null;
                };
                var getJointNode = function(gltfRuntime, jointName) {
                  var nodes = gltfRuntime.nodes;
                  var node = nodes[jointName];
                  if (node) {
                    return {
                      node,
                      id: jointName
                    };
                  }
                  for (var nde in nodes) {
                    node = nodes[nde];
                    if (node.jointName === jointName) {
                      return {
                        node,
                        id: nde
                      };
                    }
                  }
                  return null;
                };
                var nodeIsInJoints = function(skins, id) {
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    if (skins.jointNames[i] === id) {
                      return true;
                    }
                  }
                  return false;
                };
                var getNodesToRoot = function(gltfRuntime, newSkeleton, skins, nodesToRoot) {
                  for (var nde in gltfRuntime.nodes) {
                    var node = gltfRuntime.nodes[nde];
                    var id = nde;
                    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {
                      continue;
                    }
                    var mat = configureBoneTransformation(node);
                    var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, null, mat);
                    bone.id = id;
                    nodesToRoot.push({ bone, node, id });
                  }
                  for (var i = 0; i < nodesToRoot.length; i++) {
                    var nodeToRoot = nodesToRoot[i];
                    var children = nodeToRoot.node.children;
                    for (var j = 0; j < children.length; j++) {
                      var child = null;
                      for (var k = 0; k < nodesToRoot.length; k++) {
                        if (nodesToRoot[k].id === children[j]) {
                          child = nodesToRoot[k];
                          break;
                        }
                      }
                      if (child) {
                        child.bone._parent = nodeToRoot.bone;
                        nodeToRoot.bone.children.push(child.bone);
                      }
                    }
                  }
                };
                var importSkeleton = function(gltfRuntime, skins, mesh, newSkeleton) {
                  if (!newSkeleton) {
                    newSkeleton = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton(skins.name || "", "", gltfRuntime.scene);
                  }
                  if (!skins.babylonSkeleton) {
                    return newSkeleton;
                  }
                  var nodesToRoot = [];
                  var nodesToRootToAdd = [];
                  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
                  newSkeleton.bones = [];
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
                    if (!jointNode) {
                      continue;
                    }
                    var node = jointNode.node;
                    if (!node) {
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
                      continue;
                    }
                    var id = jointNode.id;
                    var existingBone = gltfRuntime.scene.getBoneById(id);
                    if (existingBone) {
                      newSkeleton.bones.push(existingBone);
                      continue;
                    }
                    var foundBone = false;
                    var parentBone = null;
                    for (var j = 0; j < i; j++) {
                      var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);
                      if (!jointNode_1) {
                        continue;
                      }
                      var joint = jointNode_1.node;
                      if (!joint) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
                        continue;
                      }
                      var children = joint.children;
                      if (!children) {
                        continue;
                      }
                      foundBone = false;
                      for (var k = 0; k < children.length; k++) {
                        if (children[k] === id) {
                          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
                          foundBone = true;
                          break;
                        }
                      }
                      if (foundBone) {
                        break;
                      }
                    }
                    var mat = configureBoneTransformation(node);
                    if (!parentBone && nodesToRoot.length > 0) {
                      parentBone = getNodeToRoot(nodesToRoot, id);
                      if (parentBone) {
                        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
                          nodesToRootToAdd.push(parentBone);
                        }
                      }
                    }
                    var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.jointName || "", newSkeleton, parentBone, mat);
                    bone.id = id;
                  }
                  var bones = newSkeleton.bones;
                  newSkeleton.bones = [];
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
                    if (!jointNode) {
                      continue;
                    }
                    for (var j = 0; j < bones.length; j++) {
                      if (bones[j].id === jointNode.id) {
                        newSkeleton.bones.push(bones[j]);
                        break;
                      }
                    }
                  }
                  newSkeleton.prepare();
                  for (var i = 0; i < nodesToRootToAdd.length; i++) {
                    newSkeleton.bones.push(nodesToRootToAdd[i]);
                  }
                  return newSkeleton;
                };
                var importMesh = function(gltfRuntime, node, meshes, id, newMesh) {
                  if (!newMesh) {
                    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                    newMesh = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
                    newMesh._parentContainer = gltfRuntime.assetContainer;
                    gltfRuntime.scene._blockEntityCollection = false;
                    newMesh.id = id;
                  }
                  if (!node.babylonNode) {
                    return newMesh;
                  }
                  var subMaterials = [];
                  var vertexData = null;
                  var verticesStarts = [];
                  var verticesCounts = [];
                  var indexStarts = [];
                  var indexCounts = [];
                  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
                    var meshId = meshes[meshIndex];
                    var mesh = gltfRuntime.meshes[meshId];
                    if (!mesh) {
                      continue;
                    }
                    for (var i = 0; i < mesh.primitives.length; i++) {
                      var tempVertexData = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexData();
                      var primitive = mesh.primitives[i];
                      if (primitive.mode !== 4) {
                      }
                      var attributes = primitive.attributes;
                      var accessor = null;
                      var buffer = null;
                      for (var semantic in attributes) {
                        accessor = gltfRuntime.accessors[attributes[semantic]];
                        buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                        if (semantic === "NORMAL") {
                          tempVertexData.normals = new Float32Array(buffer.length);
                          tempVertexData.normals.set(buffer);
                        } else if (semantic === "POSITION") {
                          if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.HomogeneousCoordinates) {
                            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
                            for (var j = 0; j < buffer.length; j += 4) {
                              tempVertexData.positions[j] = buffer[j];
                              tempVertexData.positions[j + 1] = buffer[j + 1];
                              tempVertexData.positions[j + 2] = buffer[j + 2];
                            }
                          } else {
                            tempVertexData.positions = new Float32Array(buffer.length);
                            tempVertexData.positions.set(buffer);
                          }
                          verticesCounts.push(tempVertexData.positions.length);
                        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
                          var channel = Number(semantic.split("_")[1]);
                          var uvKind = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
                          var uvs = new Float32Array(buffer.length);
                          uvs.set(buffer);
                          normalizeUVs(uvs);
                          tempVertexData.set(uvs, uvKind);
                        } else if (semantic === "JOINT") {
                          tempVertexData.matricesIndices = new Float32Array(buffer.length);
                          tempVertexData.matricesIndices.set(buffer);
                        } else if (semantic === "WEIGHT") {
                          tempVertexData.matricesWeights = new Float32Array(buffer.length);
                          tempVertexData.matricesWeights.set(buffer);
                        } else if (semantic === "COLOR") {
                          tempVertexData.colors = new Float32Array(buffer.length);
                          tempVertexData.colors.set(buffer);
                        }
                      }
                      accessor = gltfRuntime.accessors[primitive.indices];
                      if (accessor) {
                        buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                        tempVertexData.indices = new Int32Array(buffer.length);
                        tempVertexData.indices.set(buffer);
                        indexCounts.push(tempVertexData.indices.length);
                      } else {
                        var indices = [];
                        for (var j = 0; j < tempVertexData.positions.length / 3; j++) {
                          indices.push(j);
                        }
                        tempVertexData.indices = new Int32Array(indices);
                        indexCounts.push(tempVertexData.indices.length);
                      }
                      if (!vertexData) {
                        vertexData = tempVertexData;
                      } else {
                        vertexData.merge(tempVertexData);
                      }
                      var material_1 = gltfRuntime.scene.getMaterialById(primitive.material);
                      subMaterials.push(material_1 === null ? _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1);
                      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
                      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
                    }
                  }
                  var material;
                  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                  if (subMaterials.length > 1) {
                    material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.MultiMaterial("multimat" + id, gltfRuntime.scene);
                    material.subMaterials = subMaterials;
                  } else {
                    material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial("multimat" + id, gltfRuntime.scene);
                  }
                  if (subMaterials.length === 1) {
                    material = subMaterials[0];
                  }
                  material._parentContainer = gltfRuntime.assetContainer;
                  if (!newMesh.material) {
                    newMesh.material = material;
                  }
                  new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
                  newMesh.computeWorldMatrix(true);
                  gltfRuntime.scene._blockEntityCollection = false;
                  newMesh.subMeshes = [];
                  var index = 0;
                  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
                    var meshId = meshes[meshIndex];
                    var mesh = gltfRuntime.meshes[meshId];
                    if (!mesh) {
                      continue;
                    }
                    for (var i = 0; i < mesh.primitives.length; i++) {
                      if (mesh.primitives[i].mode !== 4) {
                      }
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
                      index++;
                    }
                  }
                  return newMesh;
                };
                var configureNode = function(newNode, position, rotation, scaling) {
                  if (newNode.position) {
                    newNode.position = position;
                  }
                  if (newNode.rotationQuaternion || newNode.rotation) {
                    newNode.rotationQuaternion = rotation;
                  }
                  if (newNode.scaling) {
                    newNode.scaling = scaling;
                  }
                };
                var configureNodeFromMatrix = function(newNode, node) {
                  if (node.matrix) {
                    var position = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    var rotation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                    var scaling = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    var mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
                    mat.decompose(scaling, rotation, position);
                    configureNode(newNode, position, rotation, scaling);
                  } else if (node.translation && node.rotation && node.scale) {
                    configureNode(newNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale));
                  }
                  newNode.computeWorldMatrix(true);
                };
                var importNode = function(gltfRuntime, node, id) {
                  var lastNode = null;
                  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
                    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
                      return null;
                    }
                  }
                  if (node.skin) {
                    if (node.meshes) {
                      var skin = gltfRuntime.skins[node.skin];
                      var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
                      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
                      if (newMesh.skeleton === null) {
                        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
                        if (!skin.babylonSkeleton) {
                          skin.babylonSkeleton = newMesh.skeleton;
                        }
                      }
                      lastNode = newMesh;
                    }
                  } else if (node.meshes) {
                    var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
                    lastNode = newMesh;
                  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
                    var light = gltfRuntime.lights[node.light];
                    if (light) {
                      if (light.type === "ambient") {
                        var ambienLight = light[light.type];
                        var hemiLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        hemiLight.name = node.name || "";
                        if (ambienLight.color) {
                          hemiLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambienLight.color);
                        }
                        lastNode = hemiLight;
                      } else if (light.type === "directional") {
                        var directionalLight = light[light.type];
                        var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        dirLight.name = node.name || "";
                        if (directionalLight.color) {
                          dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directionalLight.color);
                        }
                        lastNode = dirLight;
                      } else if (light.type === "point") {
                        var pointLight = light[light.type];
                        var ptLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        ptLight.name = node.name || "";
                        if (pointLight.color) {
                          ptLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(pointLight.color);
                        }
                        lastNode = ptLight;
                      } else if (light.type === "spot") {
                        var spotLight = light[light.type];
                        var spLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), 0, 0, gltfRuntime.scene);
                        spLight.name = node.name || "";
                        if (spotLight.color) {
                          spLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spotLight.color);
                        }
                        if (spotLight.fallOfAngle) {
                          spLight.angle = spotLight.fallOfAngle;
                        }
                        if (spotLight.fallOffExponent) {
                          spLight.exponent = spotLight.fallOffExponent;
                        }
                        lastNode = spLight;
                      }
                    }
                  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
                    var camera = gltfRuntime.cameras[node.camera];
                    if (camera) {
                      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                      if (camera.type === "orthographic") {
                        var orthoCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                        orthoCamera.name = node.name || "";
                        orthoCamera.mode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Camera.ORTHOGRAPHIC_CAMERA;
                        orthoCamera.attachControl();
                        lastNode = orthoCamera;
                        orthoCamera._parentContainer = gltfRuntime.assetContainer;
                      } else if (camera.type === "perspective") {
                        var perspectiveCamera = camera[camera.type];
                        var persCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                        persCamera.name = node.name || "";
                        persCamera.attachControl();
                        if (!perspectiveCamera.aspectRatio) {
                          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
                        }
                        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
                          persCamera.maxZ = perspectiveCamera.zfar;
                          persCamera.minZ = perspectiveCamera.znear;
                        }
                        lastNode = persCamera;
                        persCamera._parentContainer = gltfRuntime.assetContainer;
                      }
                      gltfRuntime.scene._blockEntityCollection = false;
                    }
                  }
                  if (!node.jointName) {
                    if (node.babylonNode) {
                      return node.babylonNode;
                    } else if (lastNode === null) {
                      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                      var dummy = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
                      dummy._parentContainer = gltfRuntime.assetContainer;
                      gltfRuntime.scene._blockEntityCollection = false;
                      node.babylonNode = dummy;
                      lastNode = dummy;
                    }
                  }
                  if (lastNode !== null) {
                    if (node.matrix && lastNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
                      configureNodeFromMatrix(lastNode, node);
                    } else {
                      var translation = node.translation || [0, 0, 0];
                      var rotation = node.rotation || [0, 0, 0, 1];
                      var scale = node.scale || [1, 1, 1];
                      configureNode(lastNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(scale));
                    }
                    lastNode.updateCache(true);
                    node.babylonNode = lastNode;
                  }
                  return lastNode;
                };
                var traverseNodes = function(gltfRuntime, id, parent, meshIncluded) {
                  if (meshIncluded === void 0) {
                    meshIncluded = false;
                  }
                  var node = gltfRuntime.nodes[id];
                  var newNode = null;
                  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
                    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
                      meshIncluded = true;
                    } else {
                      meshIncluded = false;
                    }
                  } else {
                    meshIncluded = true;
                  }
                  if (!node.jointName && meshIncluded) {
                    newNode = importNode(gltfRuntime, node, id);
                    if (newNode !== null) {
                      newNode.id = id;
                      newNode.parent = parent;
                    }
                  }
                  if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
                    }
                  }
                };
                var postLoad = function(gltfRuntime) {
                  var currentScene = gltfRuntime.currentScene;
                  if (currentScene) {
                    for (var i = 0; i < currentScene.nodes.length; i++) {
                      traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                    }
                  } else {
                    for (var thing in gltfRuntime.scenes) {
                      currentScene = gltfRuntime.scenes[thing];
                      for (var i = 0; i < currentScene.nodes.length; i++) {
                        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                      }
                    }
                  }
                  loadAnimations(gltfRuntime);
                  for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
                    var skeleton = gltfRuntime.scene.skeletons[i];
                    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
                  }
                };
                var onBindShaderMaterial = function(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {
                  var materialValues = material.values || technique.parameters;
                  for (var unif in unTreatedUniforms) {
                    var uniform = unTreatedUniforms[unif];
                    var type = uniform.type;
                    if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4) {
                      if (uniform.semantic && !uniform.source && !uniform.node) {
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
                      } else if (uniform.semantic && (uniform.source || uniform.node)) {
                        var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
                        if (source === null) {
                          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
                        }
                        if (source === null) {
                          continue;
                        }
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
                      }
                    } else {
                      var value = materialValues[technique.uniforms[unif]];
                      if (!value) {
                        continue;
                      }
                      if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                        var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
                        if (texture === null || texture === void 0) {
                          continue;
                        }
                        shaderMaterial.getEffect().setTexture(unif, texture);
                      } else {
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
                      }
                    }
                  }
                  onSuccess(shaderMaterial);
                };
                var prepareShaderMaterialUniforms = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {
                  var materialValues = material.values || technique.parameters;
                  var techniqueUniforms = technique.uniforms;
                  var _loop_1 = function(unif2) {
                    var uniform = unTreatedUniforms[unif2];
                    var type = uniform.type;
                    var value = materialValues[techniqueUniforms[unif2]];
                    if (value === void 0) {
                      value = uniform.value;
                    }
                    if (!value) {
                      return "continue";
                    }
                    var onLoadTexture = function(uniformName) {
                      return function(texture) {
                        if (uniform.value && uniformName) {
                          shaderMaterial.setTexture(uniformName, texture);
                          delete unTreatedUniforms[uniformName];
                        }
                      };
                    };
                    if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif2), function() {
                        return onLoadTexture(null);
                      });
                    } else {
                      if (uniform.value && _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial, unif2, material.values ? value : uniform.value, type)) {
                        delete unTreatedUniforms[unif2];
                      }
                    }
                  };
                  for (var unif in unTreatedUniforms) {
                    _loop_1(unif);
                  }
                };
                var onShaderCompileError = function(program, shaderMaterial, onError) {
                  return function(effect, error) {
                    shaderMaterial.dispose(true);
                    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
                  };
                };
                var onShaderCompileSuccess = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {
                  return function(_) {
                    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
                    shaderMaterial.onBind = function(mesh) {
                      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
                    };
                  };
                };
                var parseShaderUniforms = function(tokenizer, technique, unTreatedUniforms) {
                  for (var unif in technique.uniforms) {
                    var uniform = technique.uniforms[unif];
                    var uniformParameter = technique.parameters[uniform];
                    if (tokenizer.currentIdentifier === unif) {
                      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
                        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                        if (transformIndex !== -1) {
                          delete unTreatedUniforms[unif];
                          return babylonTransforms[transformIndex];
                        }
                      }
                    }
                  }
                  return tokenizer.currentIdentifier;
                };
                var importMaterials = function(gltfRuntime) {
                  for (var mat in gltfRuntime.materials) {
                    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function() {
                    }, function() {
                    });
                  }
                };
                var GLTFLoaderBase = (
                  /** @class */
                  function() {
                    function GLTFLoaderBase2() {
                    }
                    GLTFLoaderBase2.CreateRuntime = function(parsedData, scene, rootUrl) {
                      var gltfRuntime = {
                        extensions: {},
                        accessors: {},
                        buffers: {},
                        bufferViews: {},
                        meshes: {},
                        lights: {},
                        cameras: {},
                        nodes: {},
                        images: {},
                        textures: {},
                        shaders: {},
                        programs: {},
                        samplers: {},
                        techniques: {},
                        materials: {},
                        animations: {},
                        skins: {},
                        extensionsUsed: [],
                        scenes: {},
                        buffersCount: 0,
                        shaderscount: 0,
                        scene,
                        rootUrl,
                        loadedBufferCount: 0,
                        loadedBufferViews: {},
                        loadedShaderCount: 0,
                        importOnlyMeshes: false,
                        dummyNodes: [],
                        assetContainer: null
                      };
                      if (parsedData.extensions) {
                        parseObject(parsedData.extensions, "extensions", gltfRuntime);
                      }
                      if (parsedData.extensionsUsed) {
                        parseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
                      }
                      if (parsedData.buffers) {
                        parseBuffers(parsedData.buffers, gltfRuntime);
                      }
                      if (parsedData.bufferViews) {
                        parseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
                      }
                      if (parsedData.accessors) {
                        parseObject(parsedData.accessors, "accessors", gltfRuntime);
                      }
                      if (parsedData.meshes) {
                        parseObject(parsedData.meshes, "meshes", gltfRuntime);
                      }
                      if (parsedData.lights) {
                        parseObject(parsedData.lights, "lights", gltfRuntime);
                      }
                      if (parsedData.cameras) {
                        parseObject(parsedData.cameras, "cameras", gltfRuntime);
                      }
                      if (parsedData.nodes) {
                        parseObject(parsedData.nodes, "nodes", gltfRuntime);
                      }
                      if (parsedData.images) {
                        parseObject(parsedData.images, "images", gltfRuntime);
                      }
                      if (parsedData.textures) {
                        parseObject(parsedData.textures, "textures", gltfRuntime);
                      }
                      if (parsedData.shaders) {
                        parseShaders(parsedData.shaders, gltfRuntime);
                      }
                      if (parsedData.programs) {
                        parseObject(parsedData.programs, "programs", gltfRuntime);
                      }
                      if (parsedData.samplers) {
                        parseObject(parsedData.samplers, "samplers", gltfRuntime);
                      }
                      if (parsedData.techniques) {
                        parseObject(parsedData.techniques, "techniques", gltfRuntime);
                      }
                      if (parsedData.materials) {
                        parseObject(parsedData.materials, "materials", gltfRuntime);
                      }
                      if (parsedData.animations) {
                        parseObject(parsedData.animations, "animations", gltfRuntime);
                      }
                      if (parsedData.skins) {
                        parseObject(parsedData.skins, "skins", gltfRuntime);
                      }
                      if (parsedData.scenes) {
                        gltfRuntime.scenes = parsedData.scenes;
                      }
                      if (parsedData.scene && parsedData.scenes) {
                        gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
                      }
                      return gltfRuntime;
                    };
                    GLTFLoaderBase2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      var buffer = gltfRuntime.buffers[id];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(buffer.uri)) {
                        setTimeout(function() {
                          return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(buffer.uri)));
                        });
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function(data) {
                          return onSuccess(new Uint8Array(data));
                        }, onProgress, void 0, true, function(request) {
                          if (request) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var texture = gltfRuntime.textures[id];
                      if (!texture || !texture.source) {
                        onError("");
                        return;
                      }
                      if (texture.babylonTexture) {
                        onSuccess(null);
                        return;
                      }
                      var source = gltfRuntime.images[texture.source];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(source.uri)) {
                        setTimeout(function() {
                          return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(source.uri)));
                        });
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function(data) {
                          return onSuccess(new Uint8Array(data));
                        }, void 0, void 0, true, function(request) {
                          if (request) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess) {
                      var texture = gltfRuntime.textures[id];
                      if (texture.babylonTexture) {
                        onSuccess(texture.babylonTexture);
                        return;
                      }
                      var sampler = gltfRuntime.samplers[texture.sampler];
                      var createMipMaps = sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR;
                      var samplingMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
                      var blob = buffer == null ? new Blob() : new Blob([buffer]);
                      var blobURL = URL.createObjectURL(blob);
                      var revokeBlobURL = function() {
                        return URL.revokeObjectURL(blobURL);
                      };
                      var newTexture = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
                      if (sampler.wrapS !== void 0) {
                        newTexture.wrapU = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapS);
                      }
                      if (sampler.wrapT !== void 0) {
                        newTexture.wrapV = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapT);
                      }
                      newTexture.name = id;
                      texture.babylonTexture = newTexture;
                      onSuccess(newTexture);
                    };
                    GLTFLoaderBase2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var shader = gltfRuntime.shaders[id];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(shader.uri)) {
                        var shaderString = atob(shader.uri.split(",")[1]);
                        if (onSuccess) {
                          onSuccess(shaderString);
                        }
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, function(request) {
                          if (request && onError) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var material = gltfRuntime.materials[id];
                      if (!material.technique) {
                        if (onError) {
                          onError("No technique found.");
                        }
                        return;
                      }
                      var technique = gltfRuntime.techniques[material.technique];
                      if (!technique) {
                        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                        var defaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
                        defaultMaterial._parentContainer = gltfRuntime.assetContainer;
                        gltfRuntime.scene._blockEntityCollection = false;
                        defaultMaterial.diffuseColor = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3(0.5, 0.5, 0.5);
                        defaultMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                        onSuccess(defaultMaterial);
                        return;
                      }
                      var program = gltfRuntime.programs[technique.program];
                      var states = technique.states;
                      var vertexShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + "VertexShader"];
                      var pixelShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + "PixelShader"];
                      var newVertexShader = "";
                      var newPixelShader = "";
                      var vertexTokenizer = new Tokenizer(vertexShader);
                      var pixelTokenizer = new Tokenizer(pixelShader);
                      var unTreatedUniforms = {};
                      var uniforms = [];
                      var attributes = [];
                      var samplers = [];
                      for (var unif in technique.uniforms) {
                        var uniform = technique.uniforms[unif];
                        var uniformParameter = technique.parameters[uniform];
                        unTreatedUniforms[unif] = uniformParameter;
                        if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
                          var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                          if (transformIndex !== -1) {
                            uniforms.push(babylonTransforms[transformIndex]);
                            delete unTreatedUniforms[unif];
                          } else {
                            uniforms.push(unif);
                          }
                        } else if (uniformParameter.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                          samplers.push(unif);
                        } else {
                          uniforms.push(unif);
                        }
                      }
                      for (var attr in technique.attributes) {
                        var attribute = technique.attributes[attr];
                        var attributeParameter = technique.parameters[attribute];
                        if (attributeParameter.semantic) {
                          var name_1 = getAttribute(attributeParameter);
                          if (name_1) {
                            attributes.push(name_1);
                          }
                        }
                      }
                      while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
                        var tokenType = vertexTokenizer.currentToken;
                        if (tokenType !== ETokenType.IDENTIFIER) {
                          newVertexShader += vertexTokenizer.currentString;
                          continue;
                        }
                        var foundAttribute = false;
                        for (var attr in technique.attributes) {
                          var attribute = technique.attributes[attr];
                          var attributeParameter = technique.parameters[attribute];
                          if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
                            newVertexShader += getAttribute(attributeParameter);
                            foundAttribute = true;
                            break;
                          }
                        }
                        if (foundAttribute) {
                          continue;
                        }
                        newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
                      }
                      while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
                        var tokenType = pixelTokenizer.currentToken;
                        if (tokenType !== ETokenType.IDENTIFIER) {
                          newPixelShader += pixelTokenizer.currentString;
                          continue;
                        }
                        newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
                      }
                      var shaderPath = {
                        vertex: program.vertexShader + id,
                        fragment: program.fragmentShader + id
                      };
                      var options = {
                        attributes,
                        uniforms,
                        samplers,
                        needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
                      };
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
                      var shaderMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
                      shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);
                      shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
                      shaderMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                      if (states && states.functions) {
                        var functions = states.functions;
                        if (functions.cullFace && functions.cullFace[0] !== _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ECullingType.BACK) {
                          shaderMaterial.backFaceCulling = false;
                        }
                        var blendFunc = functions.blendFuncSeparate;
                        if (blendFunc) {
                          if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_COMBINE;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ONEONE;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ADD;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_SUBTRACT;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.DST_COLOR && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MULTIPLY;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MAXIMIZED;
                          }
                        }
                      }
                    };
                    return GLTFLoaderBase2;
                  }()
                );
                var GLTFLoader = (
                  /** @class */
                  function() {
                    function GLTFLoader2() {
                    }
                    GLTFLoader2.RegisterExtension = function(extension) {
                      if (GLTFLoader2.Extensions[extension.name]) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error('Tool with the same name "' + extension.name + '" already exists');
                        return;
                      }
                      GLTFLoader2.Extensions[extension.name] = extension;
                    };
                    GLTFLoader2.prototype.dispose = function() {
                    };
                    GLTFLoader2.prototype._importMeshAsync = function(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
                      var _this = this;
                      scene.useRightHandedSystem = true;
                      GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
                        gltfRuntime.assetContainer = assetContainer;
                        gltfRuntime.importOnlyMeshes = true;
                        if (meshesNames === "") {
                          gltfRuntime.importMeshesNames = [];
                        } else if (typeof meshesNames === "string") {
                          gltfRuntime.importMeshesNames = [meshesNames];
                        } else if (meshesNames && !(meshesNames instanceof Array)) {
                          gltfRuntime.importMeshesNames = [meshesNames];
                        } else {
                          gltfRuntime.importMeshesNames = [];
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Argument meshesNames must be of type string or string[]");
                        }
                        _this._createNodes(gltfRuntime);
                        var meshes = [];
                        var skeletons = [];
                        for (var nde in gltfRuntime.nodes) {
                          var node = gltfRuntime.nodes[nde];
                          if (node.babylonNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.AbstractMesh) {
                            meshes.push(node.babylonNode);
                          }
                        }
                        for (var skl in gltfRuntime.skins) {
                          var skin = gltfRuntime.skins[skl];
                          if (skin.babylonSkeleton instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton) {
                            skeletons.push(skin.babylonSkeleton);
                          }
                        }
                        _this._loadBuffersAsync(gltfRuntime, function() {
                          _this._loadShadersAsync(gltfRuntime, function() {
                            importMaterials(gltfRuntime);
                            postLoad(gltfRuntime);
                            if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                              onSuccess(meshes, skeletons);
                            }
                          });
                        });
                        if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                          onSuccess(meshes, skeletons);
                        }
                      }, onError);
                      return true;
                    };
                    GLTFLoader2.prototype.importMeshAsync = function(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, function(meshes, skeletons) {
                          resolve({
                            meshes,
                            particleSystems: [],
                            skeletons,
                            animationGroups: [],
                            lights: [],
                            transformNodes: [],
                            geometries: [],
                            spriteManagers: []
                          });
                        }, onProgress, function(message) {
                          reject(new Error(message));
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAsync = function(scene, data, rootUrl, onSuccess, onProgress, onError) {
                      var _this = this;
                      scene.useRightHandedSystem = true;
                      GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
                        GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function() {
                          _this._createNodes(gltfRuntime);
                          _this._loadBuffersAsync(gltfRuntime, function() {
                            _this._loadShadersAsync(gltfRuntime, function() {
                              importMaterials(gltfRuntime);
                              postLoad(gltfRuntime);
                              if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                                onSuccess();
                              }
                            });
                          });
                          if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                            onSuccess();
                          }
                        }, onError);
                      }, onError);
                    };
                    GLTFLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress) {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this._loadAsync(scene, data, rootUrl, function() {
                          resolve();
                        }, onProgress, function(message) {
                          reject(new Error(message));
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadShadersAsync = function(gltfRuntime, onload) {
                      var hasShaders = false;
                      var processShader = function(sha2, shader2) {
                        GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha2, function(shaderString) {
                          if (shaderString instanceof ArrayBuffer) {
                            return;
                          }
                          gltfRuntime.loadedShaderCount++;
                          if (shaderString) {
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[sha2 + (shader2.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
                          }
                          if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
                            onload();
                          }
                        }, function() {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading shader program named " + sha2 + " located at " + shader2.uri);
                        });
                      };
                      for (var sha in gltfRuntime.shaders) {
                        hasShaders = true;
                        var shader = gltfRuntime.shaders[sha];
                        if (shader) {
                          processShader.bind(this, sha, shader)();
                        } else {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No shader named: " + sha);
                        }
                      }
                      if (!hasShaders) {
                        onload();
                      }
                    };
                    GLTFLoader2.prototype._loadBuffersAsync = function(gltfRuntime, onLoad) {
                      var hasBuffers = false;
                      var processBuffer = function(buf2, buffer2) {
                        GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf2, function(bufferView) {
                          gltfRuntime.loadedBufferCount++;
                          if (bufferView) {
                            if (bufferView.byteLength != gltfRuntime.buffers[buf2].byteLength) {
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Buffer named " + buf2 + " is length " + bufferView.byteLength + ". Expected: " + buffer2.byteLength);
                            }
                            gltfRuntime.loadedBufferViews[buf2] = bufferView;
                          }
                          if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
                            onLoad();
                          }
                        }, function() {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading buffer named " + buf2 + " located at " + buffer2.uri);
                        });
                      };
                      for (var buf in gltfRuntime.buffers) {
                        hasBuffers = true;
                        var buffer = gltfRuntime.buffers[buf];
                        if (buffer) {
                          processBuffer.bind(this, buf, buffer)();
                        } else {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No buffer named: " + buf);
                        }
                      }
                      if (!hasBuffers) {
                        onLoad();
                      }
                    };
                    GLTFLoader2.prototype._createNodes = function(gltfRuntime) {
                      var currentScene = gltfRuntime.currentScene;
                      if (currentScene) {
                        for (var i = 0; i < currentScene.nodes.length; i++) {
                          traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                        }
                      } else {
                        for (var thing in gltfRuntime.scenes) {
                          currentScene = gltfRuntime.scenes[thing];
                          for (var i = 0; i < currentScene.nodes.length; i++) {
                            traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                          }
                        }
                      }
                    };
                    GLTFLoader2.Extensions = {};
                    return GLTFLoader2;
                  }()
                );
                var GLTFLoaderExtension = (
                  /** @class */
                  function() {
                    function GLTFLoaderExtension2(name2) {
                      this._name = name2;
                    }
                    Object.defineProperty(GLTFLoaderExtension2.prototype, "name", {
                      get: function() {
                        return this._name;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFLoaderExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.createTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.LoadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
                      }, function() {
                        setTimeout(function() {
                          if (!onSuccess) {
                            return;
                          }
                          onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
                        });
                      });
                    };
                    GLTFLoaderExtension2.LoadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
                      }, function() {
                        setTimeout(function() {
                          onSuccess();
                        });
                      });
                    };
                    GLTFLoaderExtension2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
                      }, function() {
                        GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
                      });
                    };
                    GLTFLoaderExtension2.LoadTextureAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
                        if (buffer) {
                          GLTFLoaderExtension2._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
                        }
                      }, onError);
                    };
                    GLTFLoaderExtension2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2._LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2._CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
                      });
                    };
                    GLTFLoaderExtension2._ApplyExtensions = function(func, defaultFunc) {
                      for (var extensionName in GLTFLoader.Extensions) {
                        var loaderExtension = GLTFLoader.Extensions[extensionName];
                        if (func(loaderExtension)) {
                          return;
                        }
                      }
                      defaultFunc();
                    };
                    return GLTFLoaderExtension2;
                  }()
                );
                _glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader._CreateGLTF1Loader = function() {
                  return new GLTFLoader();
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts": (
              /*!*****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts ***!
                \*****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EBlendingFunction: () => (
                    /* binding */
                    EBlendingFunction
                  ),
                  /* harmony export */
                  EComponentType: () => (
                    /* binding */
                    EComponentType
                  ),
                  /* harmony export */
                  ECullingType: () => (
                    /* binding */
                    ECullingType
                  ),
                  /* harmony export */
                  EParameterType: () => (
                    /* binding */
                    EParameterType
                  ),
                  /* harmony export */
                  EShaderType: () => (
                    /* binding */
                    EShaderType
                  ),
                  /* harmony export */
                  ETextureFilterType: () => (
                    /* binding */
                    ETextureFilterType
                  ),
                  /* harmony export */
                  ETextureFormat: () => (
                    /* binding */
                    ETextureFormat
                  ),
                  /* harmony export */
                  ETextureWrapMode: () => (
                    /* binding */
                    ETextureWrapMode
                  )
                  /* harmony export */
                });
                var EComponentType;
                (function(EComponentType2) {
                  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
                  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
                  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
                  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
                  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
                })(EComponentType || (EComponentType = {}));
                var EShaderType;
                (function(EShaderType2) {
                  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
                  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
                })(EShaderType || (EShaderType = {}));
                var EParameterType;
                (function(EParameterType2) {
                  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
                  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
                  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
                  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
                  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
                  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
                  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
                  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
                  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
                  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
                  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
                  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
                  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
                  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
                  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
                  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
                  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
                  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
                  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
                  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
                  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
                })(EParameterType || (EParameterType = {}));
                var ETextureWrapMode;
                (function(ETextureWrapMode2) {
                  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
                  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
                  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
                })(ETextureWrapMode || (ETextureWrapMode = {}));
                var ETextureFilterType;
                (function(ETextureFilterType2) {
                  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
                  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
                  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
                  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
                  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
                  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
                })(ETextureFilterType || (ETextureFilterType = {}));
                var ETextureFormat;
                (function(ETextureFormat2) {
                  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
                  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
                  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
                  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
                  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
                })(ETextureFormat || (ETextureFormat = {}));
                var ECullingType;
                (function(ECullingType2) {
                  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
                  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
                  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
                })(ECullingType || (ECullingType = {}));
                var EBlendingFunction;
                (function(EBlendingFunction2) {
                  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
                  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
                  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
                  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
                  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
                  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
                })(EBlendingFunction || (EBlendingFunction = {}));
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts": (
              /*!************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts ***!
                \************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFUtils: () => (
                    /* binding */
                    GLTFUtils
                  )
                  /* harmony export */
                });
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/texture */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var GLTFUtils = (
                  /** @class */
                  function() {
                    function GLTFUtils2() {
                    }
                    GLTFUtils2.SetMatrix = function(scene, source, parameter, uniformName, shaderMaterial) {
                      var mat = null;
                      if (parameter.semantic === "MODEL") {
                        mat = source.getWorldMatrix();
                      } else if (parameter.semantic === "PROJECTION") {
                        mat = scene.getProjectionMatrix();
                      } else if (parameter.semantic === "VIEW") {
                        mat = scene.getViewMatrix();
                      } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
                        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
                      } else if (parameter.semantic === "MODELVIEW") {
                        mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
                      } else if (parameter.semantic === "MODELVIEWPROJECTION") {
                        mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
                      } else if (parameter.semantic === "MODELINVERSE") {
                        mat = source.getWorldMatrix().invert();
                      } else if (parameter.semantic === "VIEWINVERSE") {
                        mat = scene.getViewMatrix().invert();
                      } else if (parameter.semantic === "PROJECTIONINVERSE") {
                        mat = scene.getProjectionMatrix().invert();
                      } else if (parameter.semantic === "MODELVIEWINVERSE") {
                        mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
                      } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
                        mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
                      } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
                        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().invert());
                      }
                      if (mat) {
                        switch (parameter.type) {
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2:
                            shaderMaterial.setMatrix2x2(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix2x2(mat));
                            break;
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3:
                            shaderMaterial.setMatrix3x3(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix3x3(mat));
                            break;
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4:
                            shaderMaterial.setMatrix(uniformName, mat);
                            break;
                          default:
                            break;
                        }
                      }
                    };
                    GLTFUtils2.SetUniform = function(shaderMaterial, uniform, value, type) {
                      switch (type) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT:
                          shaderMaterial.setFloat(uniform, value);
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC2:
                          shaderMaterial.setVector2(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2.FromArray(value));
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC3:
                          shaderMaterial.setVector3(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(value));
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC4:
                          shaderMaterial.setVector4(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector4.FromArray(value));
                          return true;
                        default:
                          return false;
                      }
                    };
                    GLTFUtils2.GetWrapMode = function(mode) {
                      switch (mode) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.CLAMP_TO_EDGE:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_ADDRESSMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.MIRRORED_REPEAT:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.MIRROR_ADDRESSMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.REPEAT:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
                        default:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
                      }
                    };
                    GLTFUtils2.GetByteStrideFromType = function(accessor) {
                      var type = accessor.type;
                      switch (type) {
                        case "VEC2":
                          return 2;
                        case "VEC3":
                          return 3;
                        case "VEC4":
                          return 4;
                        case "MAT2":
                          return 4;
                        case "MAT3":
                          return 9;
                        case "MAT4":
                          return 16;
                        default:
                          return 1;
                      }
                    };
                    GLTFUtils2.GetTextureFilterMode = function(mode) {
                      switch (mode) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.TRILINEAR_SAMPLINGMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.NEAREST_SAMPLINGMODE;
                        default:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
                      }
                    };
                    GLTFUtils2.GetBufferFromBufferView = function(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
                      byteOffset = bufferView.byteOffset + byteOffset;
                      var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
                      if (byteOffset + byteLength > loadedBufferView.byteLength) {
                        throw new Error("Buffer access is out of range");
                      }
                      var buffer = loadedBufferView.buffer;
                      byteOffset += loadedBufferView.byteOffset;
                      switch (componentType) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.BYTE:
                          return new Int8Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_BYTE:
                          return new Uint8Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.SHORT:
                          return new Int16Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_SHORT:
                          return new Uint16Array(buffer, byteOffset, byteLength);
                        default:
                          return new Float32Array(buffer, byteOffset, byteLength);
                      }
                    };
                    GLTFUtils2.GetBufferFromAccessor = function(gltfRuntime, accessor) {
                      var bufferView = gltfRuntime.bufferViews[accessor.bufferView];
                      var byteLength = accessor.count * GLTFUtils2.GetByteStrideFromType(accessor);
                      return GLTFUtils2.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
                    };
                    GLTFUtils2.DecodeBufferToText = function(view) {
                      var result = "";
                      var length = view.byteLength;
                      for (var i = 0; i < length; ++i) {
                        result += String.fromCharCode(view[i]);
                      }
                      return result;
                    };
                    GLTFUtils2.GetDefaultMaterial = function(scene) {
                      if (!GLTFUtils2._DefaultMaterial) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
                          "precision highp float;",
                          "",
                          "uniform mat4 worldView;",
                          "uniform mat4 projection;",
                          "",
                          "attribute vec3 position;",
                          "",
                          "void main(void)",
                          "{",
                          "    gl_Position = projection * worldView * vec4(position, 1.0);",
                          "}"
                        ].join("\n");
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
                          "precision highp float;",
                          "",
                          "uniform vec4 u_emission;",
                          "",
                          "void main(void)",
                          "{",
                          "    gl_FragColor = u_emission;",
                          "}"
                        ].join("\n");
                        var shaderPath = {
                          vertex: "GLTFDefaultMaterial",
                          fragment: "GLTFDefaultMaterial"
                        };
                        var options = {
                          attributes: ["position"],
                          uniforms: ["worldView", "projection", "u_emission"],
                          samplers: new Array(),
                          needAlphaBlending: false
                        };
                        GLTFUtils2._DefaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
                        GLTFUtils2._DefaultMaterial.setColor4("u_emission", new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color4(0.5, 0.5, 0.5, 1));
                      }
                      return GLTFUtils2._DefaultMaterial;
                    };
                    GLTFUtils2._DefaultMaterial = null;
                    return GLTFUtils2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts": (
              /*!*************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts ***!
                \*************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFMaterialsCommonExtension: () => (
                    /* binding */
                    GLTFMaterialsCommonExtension
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Lights/spotLight */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var GLTFMaterialsCommonExtension = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(GLTFMaterialsCommonExtension2, _super);
                    function GLTFMaterialsCommonExtension2() {
                      return _super.call(this, "KHR_materials_common") || this;
                    }
                    GLTFMaterialsCommonExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime) {
                      if (!gltfRuntime.extensions) {
                        return false;
                      }
                      var extension = gltfRuntime.extensions[this.name];
                      if (!extension) {
                        return false;
                      }
                      var lights = extension.lights;
                      if (lights) {
                        for (var thing in lights) {
                          var light = lights[thing];
                          switch (light.type) {
                            case "ambient": {
                              var ambientLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), gltfRuntime.scene);
                              var ambient = light.ambient;
                              if (ambient) {
                                ambientLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambient.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "point": {
                              var pointLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(10, 10, 10), gltfRuntime.scene);
                              var point = light.point;
                              if (point) {
                                pointLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(point.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "directional": {
                              var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), gltfRuntime.scene);
                              var directional = light.directional;
                              if (directional) {
                                dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directional.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "spot": {
                              var spot = light.spot;
                              if (spot) {
                                var spotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 10, 0), new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
                                spotLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spot.color || [1, 1, 1]);
                              }
                              break;
                            }
                            default:
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn('GLTF Material Common extension: light type "' + light.type + "” not supported");
                              break;
                          }
                        }
                      }
                      return false;
                    };
                    GLTFMaterialsCommonExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var material = gltfRuntime.materials[id];
                      if (!material || !material.extensions) {
                        return false;
                      }
                      var extension = material.extensions[this.name];
                      if (!extension) {
                        return false;
                      }
                      var standardMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
                      standardMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                      if (extension.technique === "CONSTANT") {
                        standardMaterial.disableLighting = true;
                      }
                      standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
                      standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
                      standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
                      if (typeof extension.values.ambient === "string") {
                        this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
                      } else {
                        standardMaterial.ambientColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.ambient || [0, 0, 0]);
                      }
                      if (typeof extension.values.diffuse === "string") {
                        this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
                      } else {
                        standardMaterial.diffuseColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
                      }
                      if (typeof extension.values.emission === "string") {
                        this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
                      } else {
                        standardMaterial.emissiveColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.emission || [0, 0, 0]);
                      }
                      if (typeof extension.values.specular === "string") {
                        this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
                      } else {
                        standardMaterial.specularColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.specular || [0, 0, 0]);
                      }
                      return true;
                    };
                    GLTFMaterialsCommonExtension2.prototype._loadTexture = function(gltfRuntime, id, material, propertyPath, onError) {
                      _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function(texture) {
                          return material[propertyPath] = texture;
                        });
                      }, onError);
                    };
                    return GLTFMaterialsCommonExtension2;
                  }(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension)
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/index.ts": (
              /*!**************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/index.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EBlendingFunction: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EBlendingFunction
                  ),
                  /* harmony export */
                  EComponentType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType
                  ),
                  /* harmony export */
                  ECullingType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ECullingType
                  ),
                  /* harmony export */
                  EParameterType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EParameterType
                  ),
                  /* harmony export */
                  EShaderType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EShaderType
                  ),
                  /* harmony export */
                  ETextureFilterType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFilterType
                  ),
                  /* harmony export */
                  ETextureFormat: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFormat
                  ),
                  /* harmony export */
                  ETextureWrapMode: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureWrapMode
                  ),
                  /* harmony export */
                  GLTFBinaryExtension: () => (
                    /* reexport safe */
                    _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__.GLTFBinaryExtension
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader
                  ),
                  /* harmony export */
                  GLTFLoaderBase: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderBase
                  ),
                  /* harmony export */
                  GLTFLoaderExtension: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderExtension
                  ),
                  /* harmony export */
                  GLTFMaterialsCommonExtension: () => (
                    /* reexport safe */
                    _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__.GLTFMaterialsCommonExtension
                  ),
                  /* harmony export */
                  GLTFUtils: () => (
                    /* reexport safe */
                    _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__.GLTFUtils
                  )
                  /* harmony export */
                });
                var _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFBinaryExtension */
                  "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./glTFMaterialsCommonExtension */
                  "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts": (
              /*!**********************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts ***!
                \**********************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_lights_ies: () => (
                    /* binding */
                    EXT_lights_ies
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/texture */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_lights_ies";
                var EXT_lights_ies = (
                  /** @class */
                  function() {
                    function EXT_lights_ies2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    EXT_lights_ies2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._lights;
                    };
                    EXT_lights_ies2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._lights = extension.lights;
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._lights);
                      }
                    };
                    EXT_lights_ies2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function() {
                          var babylonSpotLight, light, transformNode, bufferData, bufferView;
                          var _this2 = this;
                          return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                this._loader._allMaterialsDirtyRequired = true;
                                return [4, this._loader.loadNodeAsync(context, node, function(babylonMesh) {
                                  light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this2._lights, extension.light);
                                  var name2 = light.name || babylonMesh.name;
                                  _this2._loader.babylonScene._blockEntityCollection = !!_this2._loader._assetContainer;
                                  babylonSpotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight(name2, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), 0, 1, _this2._loader.babylonScene);
                                  babylonSpotLight.angle = Math.PI / 2;
                                  babylonSpotLight.innerAngle = 0;
                                  babylonSpotLight._parentContainer = _this2._loader._assetContainer;
                                  _this2._loader.babylonScene._blockEntityCollection = false;
                                  light._babylonLight = babylonSpotLight;
                                  babylonSpotLight.falloffType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Light.FALLOFF_GLTF;
                                  babylonSpotLight.diffuse = extension.color ? babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(extension.color) : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                                  babylonSpotLight.intensity = extension.multiplier || 1;
                                  babylonSpotLight.range = Number.MAX_VALUE;
                                  babylonSpotLight.parent = babylonMesh;
                                  _this2._loader._babylonLights.push(babylonSpotLight);
                                  _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.AddPointerMetadata(babylonSpotLight, extensionContext);
                                  assign(babylonMesh);
                                })];
                              case 1:
                                transformNode = _a.sent();
                                if (!light.uri) return [3, 3];
                                return [4, this._loader.loadUriAsync(context, light, light.uri)];
                              case 2:
                                bufferData = _a.sent();
                                return [3, 5];
                              case 3:
                                bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/bufferView"), this._loader.gltf.bufferViews, light.bufferView);
                                return [4, this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView)];
                              case 4:
                                bufferData = _a.sent();
                                _a.label = 5;
                              case 5:
                                babylonSpotLight.iesProfileTexture = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Texture(name + "_iesProfile", this._loader.babylonScene, true, false, void 0, null, null, bufferData, true, void 0, void 0, void 0, void 0, ".ies");
                                return [2, transformNode];
                            }
                          });
                        });
                      });
                    };
                    return EXT_lights_ies2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_lights_ies(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* binding */
                    EXT_lights_image_based
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/rawCubeTexture */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_lights_image_based";
                var EXT_lights_image_based = (
                  /** @class */
                  function() {
                    function EXT_lights_image_based2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    EXT_lights_image_based2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._lights;
                    };
                    EXT_lights_image_based2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._lights = extension.lights;
                      }
                    };
                    EXT_lights_image_based2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
                        _this._loader._allMaterialsDirtyRequired = true;
                        var promises = new Array();
                        promises.push(_this._loader.loadSceneAsync(context, scene));
                        _this._loader.logOpen("".concat(extensionContext));
                        var light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/light"), _this._lights, extension.light);
                        promises.push(_this._loadLightAsync("/extensions/".concat(_this.name, "/lights/").concat(extension.light), light).then(function(texture) {
                          _this._loader.babylonScene.environmentTexture = texture;
                        }));
                        _this._loader.logClose();
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    EXT_lights_image_based2.prototype._loadLightAsync = function(context, light) {
                      var _this = this;
                      if (!light._loaded) {
                        var promises = new Array();
                        this._loader.logOpen("".concat(context));
                        var imageData_1 = new Array(light.specularImages.length);
                        var _loop_1 = function(mipmap2) {
                          var faces = light.specularImages[mipmap2];
                          imageData_1[mipmap2] = new Array(faces.length);
                          var _loop_2 = function(face2) {
                            var specularImageContext = "".concat(context, "/specularImages/").concat(mipmap2, "/").concat(face2);
                            this_1._loader.logOpen("".concat(specularImageContext));
                            var index = faces[face2];
                            var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);
                            promises.push(this_1._loader.loadImageAsync("/images/".concat(index), image).then(function(data) {
                              imageData_1[mipmap2][face2] = data;
                            }));
                            this_1._loader.logClose();
                          };
                          for (var face = 0; face < faces.length; face++) {
                            _loop_2(face);
                          }
                        };
                        var this_1 = this;
                        for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
                          _loop_1(mipmap);
                        }
                        this._loader.logClose();
                        light._loaded = Promise.all(promises).then(function() {
                          var babylonTexture = new babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.RawCubeTexture(_this._loader.babylonScene, null, light.specularImageSize);
                          babylonTexture.name = light.name || "environment";
                          light._babylonTexture = babylonTexture;
                          if (light.intensity != void 0) {
                            babylonTexture.level = light.intensity;
                          }
                          if (light.rotation) {
                            var rotation = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(light.rotation);
                            if (!_this._loader.babylonScene.useRightHandedSystem) {
                              rotation = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Inverse(rotation);
                            }
                            babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
                          }
                          if (!light.irradianceCoefficients) {
                            throw new Error("".concat(context, ": Irradiance coefficients are missing"));
                          }
                          var sphericalHarmonics = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics.FromArray(light.irradianceCoefficients);
                          sphericalHarmonics.scaleInPlace(light.intensity);
                          sphericalHarmonics.convertIrradianceToLambertianRadiance();
                          var sphericalPolynomial = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.SphericalPolynomial.FromHarmonics(sphericalHarmonics);
                          var lodGenerationScale = (imageData_1.length - 1) / Math.log2(light.specularImageSize);
                          return babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale);
                        });
                      }
                      return light._loaded.then(function() {
                        return light._babylonTexture;
                      });
                    };
                    return EXT_lights_image_based2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_lights_image_based(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* binding */
                    EXT_mesh_gpu_instancing
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Meshes/thinInstanceMesh */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_mesh_gpu_instancing";
                var EXT_mesh_gpu_instancing = (
                  /** @class */
                  function() {
                    function EXT_mesh_gpu_instancing2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    EXT_mesh_gpu_instancing2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_mesh_gpu_instancing2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        _this._loader._disableInstancedMesh++;
                        var promise = _this._loader.loadNodeAsync("/nodes/".concat(node.index), node, assign);
                        _this._loader._disableInstancedMesh--;
                        if (!node._primitiveBabylonMeshes) {
                          return promise;
                        }
                        var promises = new Array();
                        var instanceCount = 0;
                        var loadAttribute = function(attribute) {
                          if (extension.attributes[attribute] == void 0) {
                            promises.push(Promise.resolve(null));
                            return;
                          }
                          var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/attributes/").concat(attribute), _this._loader.gltf.accessors, extension.attributes[attribute]);
                          promises.push(_this._loader._loadFloatAccessorAsync("/accessors/".concat(accessor.bufferView), accessor));
                          if (instanceCount === 0) {
                            instanceCount = accessor.count;
                          } else if (instanceCount !== accessor.count) {
                            throw new Error("".concat(extensionContext, "/attributes: Instance buffer accessors do not have the same count."));
                          }
                        };
                        loadAttribute("TRANSLATION");
                        loadAttribute("ROTATION");
                        loadAttribute("SCALE");
                        return promise.then(function(babylonTransformNode) {
                          return Promise.all(promises).then(function(_a) {
                            var translationBuffer = _a[0], rotationBuffer = _a[1], scaleBuffer = _a[2];
                            var matrices = new Float32Array(instanceCount * 16);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
                            for (var i = 0; i < instanceCount; ++i) {
                              translationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(translationBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0]);
                              rotationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(rotationBuffer, i * 4, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0]);
                              scaleBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(scaleBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1]);
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.ComposeToRef(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
                            }
                            for (var _i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {
                              var babylonMesh = _b[_i];
                              babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
                            }
                            return babylonTransformNode;
                          });
                        });
                      });
                    };
                    return EXT_mesh_gpu_instancing2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_mesh_gpu_instancing(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* binding */
                    EXT_meshopt_compression
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Meshes/Compression/meshoptCompression */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__);
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_meshopt_compression";
                var EXT_meshopt_compression = (
                  /** @class */
                  function() {
                    function EXT_meshopt_compression2(loader) {
                      this.name = NAME;
                      this.enabled = loader.isExtensionUsed(NAME);
                      this._loader = loader;
                    }
                    EXT_meshopt_compression2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_meshopt_compression2.prototype.loadBufferViewAsync = function(context, bufferView) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, bufferView, this.name, function(extensionContext, extension) {
                        var bufferViewMeshopt = bufferView;
                        if (bufferViewMeshopt._meshOptData) {
                          return bufferViewMeshopt._meshOptData;
                        }
                        var buffer = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/buffer"), _this._loader.gltf.buffers, extension.buffer);
                        bufferViewMeshopt._meshOptData = _this._loader.loadBufferAsync("/buffers/".concat(buffer.index), buffer, extension.byteOffset || 0, extension.byteLength).then(function(buffer2) {
                          return babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__.MeshoptCompression.Default.decodeGltfBufferAsync(buffer2, extension.count, extension.byteStride, extension.mode, extension.filter);
                        });
                        return bufferViewMeshopt._meshOptData;
                      });
                    };
                    return EXT_meshopt_compression2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_meshopt_compression(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_texture_avif: () => (
                    /* binding */
                    EXT_texture_avif
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_texture_avif";
                var EXT_texture_avif = (
                  /** @class */
                  function() {
                    function EXT_texture_avif2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    EXT_texture_avif2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_texture_avif2.prototype._loadTextureAsync = function(context, texture, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
                        var sampler = texture.sampler == void 0 ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), _this._loader.gltf.samplers, texture.sampler);
                        var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), _this._loader.gltf.images, extension.source);
                        return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
                          assign(babylonTexture);
                        }, void 0, !texture._textureInfo.nonColorData);
                      });
                    };
                    return EXT_texture_avif2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_texture_avif(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* binding */
                    EXT_texture_webp
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "EXT_texture_webp";
                var EXT_texture_webp = (
                  /** @class */
                  function() {
                    function EXT_texture_webp2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    EXT_texture_webp2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_texture_webp2.prototype._loadTextureAsync = function(context, texture, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
                        var sampler = texture.sampler == void 0 ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), _this._loader.gltf.samplers, texture.sampler);
                        var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), _this._loader.gltf.images, extension.source);
                        return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
                          assign(babylonTexture);
                        }, void 0, !texture._textureInfo.nonColorData);
                      });
                    };
                    return EXT_texture_webp2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new EXT_texture_webp(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* binding */
                    ExtrasAsMetadata
                  )
                  /* harmony export */
                });
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "ExtrasAsMetadata";
                var ExtrasAsMetadata = (
                  /** @class */
                  function() {
                    function ExtrasAsMetadata2(loader) {
                      this.name = NAME;
                      this.enabled = true;
                      this._loader = loader;
                    }
                    ExtrasAsMetadata2.prototype._assignExtras = function(babylonObject, gltfProp) {
                      if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
                        var metadata = babylonObject.metadata = babylonObject.metadata || {};
                        var gltf = metadata.gltf = metadata.gltf || {};
                        gltf.extras = gltfProp.extras;
                      }
                    };
                    ExtrasAsMetadata2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    ExtrasAsMetadata2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return this._loader.loadNodeAsync(context, node, function(babylonTransformNode) {
                        _this._assignExtras(babylonTransformNode, node);
                        assign(babylonTransformNode);
                      });
                    };
                    ExtrasAsMetadata2.prototype.loadCameraAsync = function(context, camera, assign) {
                      var _this = this;
                      return this._loader.loadCameraAsync(context, camera, function(babylonCamera) {
                        _this._assignExtras(babylonCamera, camera);
                        assign(babylonCamera);
                      });
                    };
                    ExtrasAsMetadata2.prototype.createMaterial = function(context, material, babylonDrawMode) {
                      var babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
                      this._assignExtras(babylonMaterial, material);
                      return babylonMaterial;
                    };
                    return ExtrasAsMetadata2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, false, function(loader) {
                  return new ExtrasAsMetadata(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderAnimation */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                function getColor3(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(source, offset).scale(scale);
                }
                function getAlpha(_target, source, offset, scale) {
                  return source[offset + 3] * scale;
                }
                function getFloat(_target, source, offset, scale) {
                  return source[offset] * scale;
                }
                function getMinusFloat(_target, source, offset, scale) {
                  return -source[offset] * scale;
                }
                function getNextFloat(_target, source, offset, scale) {
                  return source[offset + 1] * scale;
                }
                function getFloatBy2(_target, source, offset, scale) {
                  return source[offset] * scale * 2;
                }
                function getTextureTransformTree(textureName) {
                  return {
                    scale: [
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uScale"), getFloat, function() {
                        return 2;
                      }),
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vScale"), getNextFloat, function() {
                        return 2;
                      })
                    ],
                    offset: [
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uOffset"), getFloat, function() {
                        return 2;
                      }),
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vOffset"), getNextFloat, function() {
                        return 2;
                      })
                    ],
                    rotation: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".wAng"), getMinusFloat, function() {
                      return 1;
                    })]
                  };
                }
                var CameraAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(CameraAnimationPropertyInfo2, _super);
                    function CameraAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    CameraAnimationPropertyInfo2.prototype.buildAnimations = function(target, name2, fps, keys) {
                      return [{ babylonAnimatable: target._babylonCamera, babylonAnimation: this._buildAnimation(name2, fps, keys) }];
                    };
                    return CameraAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                var MaterialAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(MaterialAnimationPropertyInfo2, _super);
                    function MaterialAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    MaterialAnimationPropertyInfo2.prototype.buildAnimations = function(target, name2, fps, keys) {
                      var babylonAnimations = [];
                      for (var fillMode in target._data) {
                        babylonAnimations.push({
                          babylonAnimatable: target._data[fillMode].babylonMaterial,
                          babylonAnimation: this._buildAnimation(name2, fps, keys)
                        });
                      }
                      return babylonAnimations;
                    };
                    return MaterialAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                var LightAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(LightAnimationPropertyInfo2, _super);
                    function LightAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    LightAnimationPropertyInfo2.prototype.buildAnimations = function(target, name2, fps, keys) {
                      return [{ babylonAnimatable: target._babylonLight, babylonAnimation: this._buildAnimation(name2, fps, keys) }];
                    };
                    return LightAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/xmag", [
                  new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat, function() {
                    return 1;
                  }),
                  new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/ymag", [
                  new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat, function() {
                    return 1;
                  }),
                  new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/zfar", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/znear", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/yfov", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "fov", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/zfar", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/znear", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3, function() {
                    return 4;
                  }),
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha, function() {
                    return 4;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallic", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "roughness", getFloat, function() {
                  return 1;
                })]);
                var baseColorTextureInterpolation = getTextureTransformTree("albedoTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale", baseColorTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset", baseColorTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/rotation", baseColorTextureInterpolation.rotation);
                var metallicRoughnessTextureInterpolation = getTextureTransformTree("metallicTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/scale", metallicRoughnessTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/offset", metallicRoughnessTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/rotation", metallicRoughnessTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3, function() {
                  return 3;
                })]);
                var normalTextureInterpolation = getTextureTransformTree("bumpTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/scale", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/scale", normalTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/offset", normalTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/rotation", normalTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/strength", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", getFloat, function() {
                  return 1;
                })]);
                var occlusionTextureInterpolation = getTextureTransformTree("ambientTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/scale", occlusionTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/offset", occlusionTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/rotation", occlusionTextureInterpolation.rotation);
                var emissiveTextureInterpolation = getTextureTransformTree("emissiveTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/scale", emissiveTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/offset", emissiveTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/rotation", emissiveTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyStrength", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.intensity", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyRotation", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.angle", getFloat, function() {
                    return 1;
                  })
                ]);
                var anisotropyTextureInterpolation = getTextureTransformTree("anisotropy.texture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/scale", anisotropyTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/offset", anisotropyTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/rotation", anisotropyTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", getFloat, function() {
                    return 1;
                  })
                ]);
                var clearcoatTextureInterpolation = getTextureTransformTree("clearCoat.texture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/scale", clearcoatTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/offset", clearcoatTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/rotation", clearcoatTextureInterpolation.rotation);
                var clearcoatNormalTextureInterpolation = getTextureTransformTree("clearCoat.bumpTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/scale", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.bumpTexture.level", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/scale", clearcoatNormalTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/offset", clearcoatNormalTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/rotation", clearcoatNormalTextureInterpolation.rotation);
                var clearcoatRoughnessTextureInterpolation = getTextureTransformTree("clearCoat.textureRoughness");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/scale", clearcoatRoughnessTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/offset", clearcoatRoughnessTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/rotation", clearcoatRoughnessTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_dispersion/dispersionFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.dispersion", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_emissive_strength/emissiveStrength", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_ior/ior", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceIor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMinimum", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMaximum", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", getFloat, function() {
                    return 1;
                  })
                ]);
                var iridescenceTextureInterpolation = getTextureTransformTree("iridescence.texture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/scale", iridescenceTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/offset", iridescenceTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/rotation", iridescenceTextureInterpolation.rotation);
                var iridescenceThicknessTextureInterpolation = getTextureTransformTree("iridescence.thicknessTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/scale", iridescenceThicknessTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/offset", iridescenceThicknessTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/rotation", iridescenceThicknessTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3, function() {
                    return 3;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness", getFloat, function() {
                    return 1;
                  })
                ]);
                var sheenTextureInterpolation = getTextureTransformTree("sheen.texture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/scale", sheenTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/offset", sheenTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/rotation", sheenTextureInterpolation.rotation);
                var sheenRoughnessTextureInterpolation = getTextureTransformTree("sheen.textureRoughness");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/scale", sheenRoughnessTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/offset", sheenRoughnessTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/rotation", sheenRoughnessTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3, function() {
                    return 3;
                  })
                ]);
                var specularTextureInterpolation = getTextureTransformTree("metallicReflectanceTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/scale", specularTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/offset", specularTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/rotation", specularTextureInterpolation.rotation);
                var specularColorTextureInterpolation = getTextureTransformTree("reflectanceTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/scale", specularColorTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/offset", specularColorTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/rotation", specularColorTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", getFloat, function() {
                    return 1;
                  })
                ]);
                var transmissionTextureInterpolation = getTextureTransformTree("subSurface.refractionIntensityTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/scale", transmissionTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/offset", transmissionTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/rotation", transmissionTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/attenuationColor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3, function() {
                    return 3;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/attenuationDistance", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", getFloat, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", getFloat, function() {
                    return 1;
                  })
                ]);
                var thicknessTextureInterpolation = getTextureTransformTree("subSurface.thicknessTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/scale", thicknessTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/offset", thicknessTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/rotation", thicknessTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.translucencyIntensity", getFloat, function() {
                    return 1;
                  })
                ]);
                var diffuseTransmissionTextureInterpolation = getTextureTransformTree("subSurface.translucencyIntensityTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorFactor", [
                  new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "subSurface.translucencyColor", getColor3, function() {
                    return 3;
                  })
                ]);
                var diffuseTransmissionColorTextureInterpolation = getTextureTransformTree("subSurface.translucencyColorTexture");
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionColorTextureInterpolation.scale);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionColorTextureInterpolation.offset);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionColorTextureInterpolation.rotation);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/color", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, function() {
                  return 3;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/intensity", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/range", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "range", getFloat, function() {
                  return 1;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/spot/innerConeAngle", [
                  new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/spot/outerConeAngle", [
                  new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2, function() {
                    return 1;
                  })
                ]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/nodes/{}/extensions/EXT_lights_ies/color", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, function() {
                  return 3;
                })]);
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/nodes/{}/extensions/EXT_lights_ies/multiplier", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, function() {
                  return 1;
                })]);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* binding */
                    KHR_animation_pointer
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/logger */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var _KHR_animation_pointer_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./KHR_animation_pointer.data */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts"
                );
                var NAME = "KHR_animation_pointer";
                var KHR_animation_pointer = (
                  /** @class */
                  function() {
                    function KHR_animation_pointer2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this._pathToObjectConverter = (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.GetPathToObjectConverter)(this._loader.gltf);
                    }
                    Object.defineProperty(KHR_animation_pointer2.prototype, "enabled", {
                      /**
                       * Defines whether this extension is enabled.
                       */
                      get: function() {
                        return this._loader.isExtensionUsed(NAME);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    KHR_animation_pointer2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._pathToObjectConverter;
                    };
                    KHR_animation_pointer2.prototype._loadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      var _a;
                      var extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;
                      if (!extension || !this._pathToObjectConverter) {
                        return null;
                      }
                      if (channel.target.path !== "pointer") {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/target/path: Value (").concat(channel.target.path, ") must be (").concat("pointer", ") when using the ").concat(this.name, " extension"));
                      }
                      if (channel.target.node != void 0) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/target/node: Value (").concat(channel.target.node, ") must not be present when using the ").concat(this.name, " extension"));
                      }
                      var extensionContext = "".concat(context, "/extensions/").concat(this.name);
                      var pointer = extension.pointer;
                      if (!pointer) {
                        throw new Error("".concat(extensionContext, ": Pointer is missing"));
                      }
                      try {
                        var obj = this._pathToObjectConverter.convert(pointer);
                        if (!obj.info.interpolation) {
                          throw new Error("".concat(extensionContext, "/pointer: Interpolation is missing"));
                        }
                        return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, {
                          object: obj.object,
                          info: obj.info.interpolation
                        }, onLoad);
                      } catch (e) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(extensionContext, "/pointer: Invalid pointer (").concat(pointer, ") skipped"));
                        return null;
                      }
                    };
                    return KHR_animation_pointer2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_animation_pointer(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* binding */
                    KHR_draco_mesh_compression
                  )
                  /* harmony export */
                });
                var babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Buffers/buffer */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_draco_mesh_compression";
                var KHR_draco_mesh_compression = (
                  /** @class */
                  function() {
                    function KHR_draco_mesh_compression2(loader) {
                      this.name = NAME;
                      this.useNormalizedFlagFromAccessor = true;
                      this._loader = loader;
                      this.enabled = babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);
                    }
                    KHR_draco_mesh_compression2.prototype.dispose = function() {
                      delete this.dracoDecoder;
                      this._loader = null;
                    };
                    KHR_draco_mesh_compression2.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
                        if (primitive.mode != void 0) {
                          if (primitive.mode !== 4 && primitive.mode !== 5) {
                            throw new Error("".concat(context, ": Unsupported mode ").concat(primitive.mode));
                          }
                        }
                        var attributes = {};
                        var normalized = {};
                        var loadAttribute = function(name2, kind) {
                          var uniqueId = extension.attributes[name2];
                          if (uniqueId == void 0) {
                            return;
                          }
                          babylonMesh._delayInfo = babylonMesh._delayInfo || [];
                          if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                            babylonMesh._delayInfo.push(kind);
                          }
                          attributes[kind] = uniqueId;
                          if (_this.useNormalizedFlagFromAccessor) {
                            var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.TryGet(_this._loader.gltf.accessors, primitive.attributes[name2]);
                            if (accessor) {
                              normalized[kind] = accessor.normalized || false;
                            }
                          }
                        };
                        loadAttribute("POSITION", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                        loadAttribute("NORMAL", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                        loadAttribute("TANGENT", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
                        loadAttribute("TEXCOORD_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
                        loadAttribute("TEXCOORD_1", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
                        loadAttribute("TEXCOORD_2", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
                        loadAttribute("TEXCOORD_3", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
                        loadAttribute("TEXCOORD_4", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
                        loadAttribute("TEXCOORD_5", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
                        loadAttribute("JOINTS_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
                        loadAttribute("WEIGHTS_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
                        loadAttribute("COLOR_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind);
                        var bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._loader.gltf.bufferViews, extension.bufferView);
                        if (!bufferView._dracoBabylonGeometry) {
                          bufferView._dracoBabylonGeometry = _this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                            var dracoDecoder = _this.dracoDecoder || babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.DracoDecoder.Default;
                            var positionAccessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.TryGet(_this._loader.gltf.accessors, primitive.attributes["POSITION"]);
                            var babylonBoundingInfo = !_this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? (0, _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.LoadBoundingInfoFromPositionAccessor)(positionAccessor) : null;
                            return dracoDecoder._decodeMeshToGeometryForGltfAsync(babylonMesh.name, _this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo).catch(function(error) {
                              throw new Error("".concat(context, ": ").concat(error.message));
                            });
                          });
                        }
                        return bufferView._dracoBabylonGeometry;
                      });
                    };
                    return KHR_draco_mesh_compression2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_draco_mesh_compression(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts": (
              /*!*************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts ***!
                \*************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_interactivity: () => (
                    /* binding */
                    KHR_interactivity
                  ),
                  /* harmony export */
                  _AddInteractivityObjectModel: () => (
                    /* binding */
                    _AddInteractivityObjectModel
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.vector */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var _KHR_interactivity_interactivityGraphParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./KHR_interactivity/interactivityGraphParser */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts"
                );
                var NAME = "KHR_interactivity";
                var KHR_interactivity = (
                  /** @class */
                  function() {
                    function KHR_interactivity2(_loader) {
                      this._loader = _loader;
                      this.name = NAME;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      this._pathConverter = (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.GetPathToObjectConverter)(this._loader.gltf);
                      _loader._skipStartAnimationStep = true;
                      var scene = _loader.babylonScene;
                      if (scene) {
                        _AddInteractivityObjectModel(scene);
                      }
                    }
                    KHR_interactivity2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._pathConverter;
                    };
                    KHR_interactivity2.prototype.onReady = function() {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function() {
                        var scene, interactivityDefinition, coordinator, graphs;
                        var _this = this;
                        var _a;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_b) {
                          switch (_b.label) {
                            case 0:
                              if (!this._loader.babylonScene || !this._pathConverter) {
                                return [
                                  2
                                  /*return*/
                                ];
                              }
                              scene = this._loader.babylonScene;
                              interactivityDefinition = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_interactivity;
                              if (!interactivityDefinition) {
                                return [
                                  2
                                  /*return*/
                                ];
                              }
                              coordinator = new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.FlowGraphCoordinator({ scene });
                              coordinator.dispatchEventsSynchronously = false;
                              graphs = interactivityDefinition.graphs.map(function(graph) {
                                var parser = new _KHR_interactivity_interactivityGraphParser__WEBPACK_IMPORTED_MODULE_3__.InteractivityGraphToFlowGraphParser(graph, _this._loader.gltf, _this._loader);
                                return parser.serializeToFlowGraph();
                              });
                              return [4, Promise.all(graphs.map(function(graph) {
                                return (0, babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.ParseFlowGraphAsync)(graph, { coordinator, pathConverter: _this._pathConverter });
                              }))];
                            case 1:
                              _b.sent();
                              coordinator.start();
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    };
                    return KHR_interactivity2;
                  }()
                );
                function _AddInteractivityObjectModel(scene) {
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/extensions/KHR_interactivity/?/activeCamera/rotation", {
                    get: function() {
                      if (!scene.activeCamera) {
                        return new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Quaternion(NaN, NaN, NaN, NaN);
                      }
                      return babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();
                    },
                    type: "Quaternion",
                    getTarget: function() {
                      return scene.activeCamera;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/extensions/KHR_interactivity/?/activeCamera/position", {
                    get: function() {
                      if (!scene.activeCamera) {
                        return new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Vector3(NaN, NaN, NaN);
                      }
                      return scene.activeCamera.position;
                    },
                    type: "Vector3",
                    getTarget: function() {
                      return scene.activeCamera;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/isPlaying", {
                    get: function(animation) {
                      var _a, _b;
                      return (_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.isPlaying) !== null && _b !== void 0 ? _b : false;
                    },
                    type: "boolean",
                    getTarget: function(animation) {
                      return animation._babylonAnimationGroup;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/minTime", {
                    get: function(animation) {
                      var _a, _b;
                      return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.from) !== null && _b !== void 0 ? _b : 0) / 60;
                    },
                    type: "number",
                    getTarget: function(animation) {
                      return animation._babylonAnimationGroup;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/maxTime", {
                    get: function(animation) {
                      var _a, _b;
                      return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : 0) / 60;
                    },
                    type: "number",
                    getTarget: function(animation) {
                      return animation._babylonAnimationGroup;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/playhead", {
                    get: function(animation) {
                      var _a, _b;
                      return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.getCurrentFrame()) !== null && _b !== void 0 ? _b : 0) / 60;
                    },
                    type: "number",
                    getTarget: function(animation) {
                      return animation._babylonAnimationGroup;
                    }
                  });
                  (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/virtualPlayhead", {
                    get: function(animation) {
                      var _a, _b;
                      return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.getCurrentFrame()) !== null && _b !== void 0 ? _b : 0) / 60;
                    },
                    type: "number",
                    getTarget: function(animation) {
                      return animation._babylonAnimationGroup;
                    }
                  });
                }
                (0, babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.addToBlockFactory)(NAME, "FlowGraphGLTFDataProvider", function() {
                  return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(void 0, void 0, void 0, function() {
                    return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_a) {
                      switch (_a.label) {
                        case 0:
                          return [4, Promise.resolve(
                            /*! import() */
                          ).then(__webpack_require__2.bind(
                            __webpack_require__2,
                            /*! ./KHR_interactivity/flowGraphGLTFDataProvider */
                            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts"
                          ))];
                        case 1:
                          return [2, _a.sent().FlowGraphGLTFDataProvider];
                      }
                    });
                  });
                });
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_interactivity(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts": (
              /*!*******************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts ***!
                \*******************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  addNewInteractivityFlowGraphMapping: () => (
                    /* binding */
                    addNewInteractivityFlowGraphMapping
                  ),
                  /* harmony export */
                  getAllSupportedNativeNodeTypes: () => (
                    /* binding */
                    getAllSupportedNativeNodeTypes
                  ),
                  /* harmony export */
                  getMappingForDeclaration: () => (
                    /* binding */
                    getMappingForDeclaration
                  ),
                  /* harmony export */
                  getMappingForFullOperationName: () => (
                    /* binding */
                    getMappingForFullOperationName
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/FlowGraph/flowGraphRichTypes */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);
                function getMappingForFullOperationName(fullOperationName) {
                  var _a = fullOperationName.split(":"), op = _a[0], extension = _a[1];
                  return getMappingForDeclaration({ op, extension });
                }
                function getMappingForDeclaration(declaration, returnNoOpIfNotAvailable) {
                  var _a;
                  if (returnNoOpIfNotAvailable === void 0) {
                    returnNoOpIfNotAvailable = true;
                  }
                  var mapping = declaration.extension ? (_a = gltfExtensionsToFlowGraphMapping[declaration.extension]) === null || _a === void 0 ? void 0 : _a[declaration.op] : gltfToFlowGraphMapping[declaration.op];
                  if (!mapping) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("No mapping found for operation ".concat(declaration.op, " and extension ").concat(declaration.extension || "KHR_interactivity"));
                    if (returnNoOpIfNotAvailable) {
                      var inputs = {};
                      var outputs_1 = {
                        flows: {}
                      };
                      if (declaration.inputValueSockets) {
                        inputs.values = {};
                        for (var key in declaration.inputValueSockets) {
                          inputs.values[key] = {
                            name: key
                          };
                        }
                      }
                      if (declaration.outputValueSockets) {
                        outputs_1.values = {};
                        Object.keys(declaration.outputValueSockets).forEach(function(key2) {
                          outputs_1.values[key2] = {
                            name: key2
                          };
                        });
                      }
                      return {
                        blocks: [],
                        // no blocks, just mapping
                        inputs,
                        outputs: outputs_1
                      };
                    }
                  }
                  return mapping;
                }
                function addNewInteractivityFlowGraphMapping(key, extension, mapping) {
                  gltfExtensionsToFlowGraphMapping[extension] || (gltfExtensionsToFlowGraphMapping[extension] = {});
                  gltfExtensionsToFlowGraphMapping[extension][key] = mapping;
                }
                var gltfExtensionsToFlowGraphMapping = {
                  /**
                   * This is the BABYLON extension for glTF interactivity.
                   * It defines babylon-specific blocks and operations.
                   */
                  BABYLON: {
                    /**
                     * flow/log is a flow node that logs input to the console.
                     * It has "in" and "out" flows, and takes a message as input.
                     * The message can be any type of value.
                     * The message is logged to the console when the "in" flow is triggered.
                     * The "out" flow is triggered when the message is logged.
                     */
                    "flow/log": {
                      blocks: [
                        "FlowGraphConsoleLogBlock"
                        /* FlowGraphBlockNames.ConsoleLog */
                      ],
                      inputs: {
                        values: {
                          message: { name: "message" }
                        }
                      }
                    }
                  }
                };
                var gltfToFlowGraphMapping = {
                  "event/onStart": {
                    blocks: [
                      "FlowGraphSceneReadyEventBlock"
                      /* FlowGraphBlockNames.SceneReadyEvent */
                    ],
                    outputs: {
                      flows: {
                        out: { name: "done" }
                      }
                    }
                  },
                  "event/onTick": {
                    blocks: [
                      "FlowGraphSceneTickEventBlock"
                      /* FlowGraphBlockNames.SceneTickEvent */
                    ],
                    inputs: {},
                    outputs: {
                      values: {
                        timeSinceLastTick: {
                          name: "deltaTime",
                          gltfType: "number"
                          /*, dataTransformer: (time: number) => time / 1000*/
                        }
                      },
                      flows: {
                        out: { name: "done" }
                      }
                    }
                  },
                  "event/send": {
                    blocks: [
                      "FlowGraphSendCustomEventBlock"
                      /* FlowGraphBlockNames.SendCustomEvent */
                    ],
                    extraProcessor: function(gltfBlock, declaration, _mapping, parser, serializedObjects) {
                      if (declaration.op !== "event/send" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
                        throw new Error("Receive event should have a single configuration object, the event itself");
                      }
                      var eventConfiguration = gltfBlock.configuration["event"];
                      var eventId = eventConfiguration.value[0];
                      if (typeof eventId !== "number") {
                        throw new Error("Event id should be a number");
                      }
                      var event = parser.arrays.events[eventId];
                      var serializedObject = serializedObjects[0];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.eventId = event.eventId;
                      serializedObject.config.eventData = event.eventData;
                      return serializedObjects;
                    }
                  },
                  "event/receive": {
                    blocks: [
                      "FlowGraphReceiveCustomEventBlock"
                      /* FlowGraphBlockNames.ReceiveCustomEvent */
                    ],
                    outputs: {
                      flows: {
                        out: { name: "done" }
                      }
                    },
                    validation: function(gltfBlock, interactivityGraph) {
                      var _a;
                      if (!gltfBlock.configuration) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Receive event should have a configuration object");
                        return { valid: false, error: "Receive event should have a configuration object" };
                      }
                      var eventConfiguration = gltfBlock.configuration["event"];
                      if (!eventConfiguration) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Receive event should have a single configuration object, the event itself");
                        return { valid: false, error: "Receive event should have a single configuration object, the event itself" };
                      }
                      var eventId = eventConfiguration.value[0];
                      if (typeof eventId !== "number") {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Event id should be a number");
                        return { valid: false, error: "Event id should be a number" };
                      }
                      var event = (_a = interactivityGraph.events) === null || _a === void 0 ? void 0 : _a[eventId];
                      if (!event) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Event with id ".concat(eventId, " not found"));
                        return { valid: false, error: "Event with id ".concat(eventId, " not found") };
                      }
                      return { valid: true };
                    },
                    extraProcessor: function(gltfBlock, declaration, _mapping, parser, serializedObjects) {
                      if (declaration.op !== "event/receive" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
                        throw new Error("Receive event should have a single configuration object, the event itself");
                      }
                      var eventConfiguration = gltfBlock.configuration["event"];
                      var eventId = eventConfiguration.value[0];
                      if (typeof eventId !== "number") {
                        throw new Error("Event id should be a number");
                      }
                      var event = parser.arrays.events[eventId];
                      var serializedObject = serializedObjects[0];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.eventId = event.eventId;
                      serializedObject.config.eventData = event.eventData;
                      return serializedObjects;
                    }
                  },
                  "math/e": getSimpleInputMapping(
                    "FlowGraphEBlock"
                    /* FlowGraphBlockNames.E */
                  ),
                  "math/pi": getSimpleInputMapping(
                    "FlowGraphPIBlock"
                    /* FlowGraphBlockNames.PI */
                  ),
                  "math/inf": getSimpleInputMapping(
                    "FlowGraphInfBlock"
                    /* FlowGraphBlockNames.Inf */
                  ),
                  "math/nan": getSimpleInputMapping(
                    "FlowGraphNaNBlock"
                    /* FlowGraphBlockNames.NaN */
                  ),
                  "math/abs": getSimpleInputMapping(
                    "FlowGraphAbsBlock"
                    /* FlowGraphBlockNames.Abs */
                  ),
                  "math/sign": getSimpleInputMapping(
                    "FlowGraphSignBlock"
                    /* FlowGraphBlockNames.Sign */
                  ),
                  "math/trunc": getSimpleInputMapping(
                    "FlowGraphTruncBlock"
                    /* FlowGraphBlockNames.Trunc */
                  ),
                  "math/floor": getSimpleInputMapping(
                    "FlowGraphFloorBlock"
                    /* FlowGraphBlockNames.Floor */
                  ),
                  "math/ceil": getSimpleInputMapping(
                    "FlowGraphCeilBlock"
                    /* FlowGraphBlockNames.Ceil */
                  ),
                  "math/round": {
                    blocks: [
                      "FlowGraphRoundBlock"
                      /* FlowGraphBlockNames.Round */
                    ],
                    configuration: {},
                    inputs: {
                      values: {
                        a: { name: "a" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(gltfBlock, declaration, _mapping, parser, serializedObjects) {
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      serializedObjects[0].config.roundHalfAwayFromZero = true;
                      return serializedObjects;
                    }
                  },
                  "math/fract": getSimpleInputMapping(
                    "FlowGraphFractBlock"
                    /* FlowGraphBlockNames.Fraction */
                  ),
                  "math/neg": getSimpleInputMapping(
                    "FlowGraphNegationBlock"
                    /* FlowGraphBlockNames.Negation */
                  ),
                  "math/add": getSimpleInputMapping("FlowGraphAddBlock", ["a", "b"], true),
                  "math/sub": getSimpleInputMapping("FlowGraphSubtractBlock", ["a", "b"], true),
                  "math/mul": {
                    blocks: [
                      "FlowGraphMultiplyBlock"
                      /* FlowGraphBlockNames.Multiply */
                    ],
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      serializedObjects[0].config.useMatrixPerComponent = true;
                      serializedObjects[0].config.preventIntegerFloatArithmetic = true;
                      var type = -1;
                      Object.keys(_gltfBlock.values || {}).find(function(value) {
                        var _a;
                        if (((_a = _gltfBlock.values) === null || _a === void 0 ? void 0 : _a[value].type) !== void 0) {
                          type = _gltfBlock.values[value].type;
                          return true;
                        }
                        return false;
                      });
                      if (type !== -1) {
                        serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;
                      }
                      return serializedObjects;
                    },
                    validation: function(gltfBlock) {
                      if (gltfBlock.values) {
                        var types_1 = Object.keys(gltfBlock.values).map(function(key) {
                          return gltfBlock.values[key].type;
                        });
                        var allSameType = types_1.every(function(type) {
                          return type === void 0 || type === types_1[0];
                        });
                        if (!allSameType) {
                          return { valid: false, error: "All inputs must be of the same type" };
                        }
                      }
                      return { valid: true };
                    }
                  },
                  "math/div": getSimpleInputMapping("FlowGraphDivideBlock", ["a", "b"], true),
                  "math/rem": getSimpleInputMapping("FlowGraphModuloBlock", ["a", "b"]),
                  "math/min": getSimpleInputMapping("FlowGraphMinBlock", ["a", "b"]),
                  "math/max": getSimpleInputMapping("FlowGraphMaxBlock", ["a", "b"]),
                  "math/clamp": getSimpleInputMapping("FlowGraphClampBlock", ["a", "b", "c"]),
                  "math/saturate": getSimpleInputMapping(
                    "FlowGraphSaturateBlock"
                    /* FlowGraphBlockNames.Saturate */
                  ),
                  "math/mix": getSimpleInputMapping("FlowGraphMathInterpolationBlock", ["a", "b", "c"]),
                  "math/eq": getSimpleInputMapping("FlowGraphEqualityBlock", ["a", "b"]),
                  "math/lt": getSimpleInputMapping("FlowGraphLessThanBlock", ["a", "b"]),
                  "math/le": getSimpleInputMapping("FlowGraphLessThanOrEqualBlock", ["a", "b"]),
                  "math/gt": getSimpleInputMapping("FlowGraphGreaterThanBlock", ["a", "b"]),
                  "math/ge": getSimpleInputMapping("FlowGraphGreaterThanOrEqualBlock", ["a", "b"]),
                  "math/isnan": getSimpleInputMapping(
                    "FlowGraphIsNaNBlock"
                    /* FlowGraphBlockNames.IsNaN */
                  ),
                  "math/isinf": getSimpleInputMapping(
                    "FlowGraphIsInfBlock"
                    /* FlowGraphBlockNames.IsInfinity */
                  ),
                  "math/select": {
                    blocks: [
                      "FlowGraphConditionalBlock"
                      /* FlowGraphBlockNames.Conditional */
                    ],
                    inputs: {
                      values: {
                        condition: { name: "condition" },
                        // Should we validate those have the same type here, or assume it is already validated?
                        a: { name: "onTrue" },
                        b: { name: "onFalse" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "output" }
                      }
                    }
                  },
                  "math/random": {
                    blocks: [
                      "FlowGraphRandomBlock"
                      /* FlowGraphBlockNames.Random */
                    ],
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    }
                  },
                  "math/sin": getSimpleInputMapping(
                    "FlowGraphSinBlock"
                    /* FlowGraphBlockNames.Sin */
                  ),
                  "math/cos": getSimpleInputMapping(
                    "FlowGraphCosBlock"
                    /* FlowGraphBlockNames.Cos */
                  ),
                  "math/tan": getSimpleInputMapping(
                    "FlowGraphTanBlock"
                    /* FlowGraphBlockNames.Tan */
                  ),
                  "math/asin": getSimpleInputMapping(
                    "FlowGraphASinBlock"
                    /* FlowGraphBlockNames.Asin */
                  ),
                  "math/acos": getSimpleInputMapping(
                    "FlowGraphACosBlock"
                    /* FlowGraphBlockNames.Acos */
                  ),
                  "math/atan": getSimpleInputMapping(
                    "FlowGraphATanBlock"
                    /* FlowGraphBlockNames.Atan */
                  ),
                  "math/atan2": getSimpleInputMapping("FlowGraphATan2Block", ["a", "b"]),
                  "math/sinh": getSimpleInputMapping(
                    "FlowGraphSinhBlock"
                    /* FlowGraphBlockNames.Sinh */
                  ),
                  "math/cosh": getSimpleInputMapping(
                    "FlowGraphCoshBlock"
                    /* FlowGraphBlockNames.Cosh */
                  ),
                  "math/tanh": getSimpleInputMapping(
                    "FlowGraphTanhBlock"
                    /* FlowGraphBlockNames.Tanh */
                  ),
                  "math/asinh": getSimpleInputMapping(
                    "FlowGraphASinhBlock"
                    /* FlowGraphBlockNames.Asinh */
                  ),
                  "math/acosh": getSimpleInputMapping(
                    "FlowGraphACoshBlock"
                    /* FlowGraphBlockNames.Acosh */
                  ),
                  "math/atanh": getSimpleInputMapping(
                    "FlowGraphATanhBlock"
                    /* FlowGraphBlockNames.Atanh */
                  ),
                  "math/exp": getSimpleInputMapping(
                    "FlowGraphExponentialBlock"
                    /* FlowGraphBlockNames.Exponential */
                  ),
                  "math/log": getSimpleInputMapping(
                    "FlowGraphLogBlock"
                    /* FlowGraphBlockNames.Log */
                  ),
                  "math/log2": getSimpleInputMapping(
                    "FlowGraphLog2Block"
                    /* FlowGraphBlockNames.Log2 */
                  ),
                  "math/log10": getSimpleInputMapping(
                    "FlowGraphLog10Block"
                    /* FlowGraphBlockNames.Log10 */
                  ),
                  "math/sqrt": getSimpleInputMapping(
                    "FlowGraphSquareRootBlock"
                    /* FlowGraphBlockNames.SquareRoot */
                  ),
                  "math/cbrt": getSimpleInputMapping(
                    "FlowGraphCubeRootBlock"
                    /* FlowGraphBlockNames.CubeRoot */
                  ),
                  "math/pow": getSimpleInputMapping("FlowGraphPowerBlock", ["a", "b"]),
                  "math/length": getSimpleInputMapping(
                    "FlowGraphLengthBlock"
                    /* FlowGraphBlockNames.Length */
                  ),
                  "math/normalize": getSimpleInputMapping(
                    "FlowGraphNormalizeBlock"
                    /* FlowGraphBlockNames.Normalize */
                  ),
                  "math/dot": getSimpleInputMapping("FlowGraphDotBlock", ["a", "b"]),
                  "math/cross": getSimpleInputMapping("FlowGraphCrossBlock", ["a", "b"]),
                  "math/rotate2d": getSimpleInputMapping("FlowGraphRotate2DBlock", ["a", "b"]),
                  "math/rotate3d": getSimpleInputMapping("FlowGraphRotate3DBlock", ["a", "b", "c"]),
                  "math/transform": {
                    // glTF transform is vectorN with matrixN
                    blocks: [
                      "FlowGraphTransformVectorBlock"
                      /* FlowGraphBlockNames.TransformVector */
                    ],
                    inputs: {
                      values: {
                        a: { name: "a" },
                        b: { name: "b" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    }
                  },
                  "math/combine2": {
                    blocks: [
                      "FlowGraphCombineVector2Block"
                      /* FlowGraphBlockNames.CombineVector2 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    }
                  },
                  "math/combine3": {
                    blocks: [
                      "FlowGraphCombineVector3Block"
                      /* FlowGraphBlockNames.CombineVector3 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" },
                        c: { name: "input_2", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    }
                  },
                  "math/combine4": {
                    blocks: [
                      "FlowGraphCombineVector4Block"
                      /* FlowGraphBlockNames.CombineVector4 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" },
                        c: { name: "input_2", gltfType: "number" },
                        d: { name: "input_3", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    }
                  },
                  // one input, N outputs! outputs named using numbers.
                  "math/extract2": {
                    blocks: [
                      "FlowGraphExtractVector2Block"
                      /* FlowGraphBlockNames.ExtractVector2 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" }
                      }
                    }
                  },
                  "math/extract3": {
                    blocks: [
                      "FlowGraphExtractVector3Block"
                      /* FlowGraphBlockNames.ExtractVector3 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" },
                        "2": { name: "output_2" }
                      }
                    }
                  },
                  "math/extract4": {
                    blocks: [
                      "FlowGraphExtractVector4Block"
                      /* FlowGraphBlockNames.ExtractVector4 */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" },
                        "2": { name: "output_2" },
                        "3": { name: "output_3" }
                      }
                    }
                  },
                  "math/transpose": getSimpleInputMapping(
                    "FlowGraphTransposeBlock"
                    /* FlowGraphBlockNames.Transpose */
                  ),
                  "math/determinant": getSimpleInputMapping(
                    "FlowGraphDeterminantBlock"
                    /* FlowGraphBlockNames.Determinant */
                  ),
                  "math/inverse": getSimpleInputMapping(
                    "FlowGraphInvertMatrixBlock"
                    /* FlowGraphBlockNames.InvertMatrix */
                  ),
                  "math/matmul": getSimpleInputMapping("FlowGraphMatrixMultiplicationBlock", ["a", "b"]),
                  "math/matCompose": {
                    blocks: [
                      "FlowGraphMatrixCompose"
                      /* FlowGraphBlockNames.MatrixCompose */
                    ],
                    inputs: {
                      values: {
                        translation: { name: "position", gltfType: "float3" },
                        rotation: { name: "rotationQuaternion", gltfType: "float4" },
                        scale: { name: "scaling", gltfType: "float3" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
                      var d = serializedObjects[0].dataInputs.find(function(input) {
                        return input.name === "rotationQuaternion";
                      });
                      if (!d) {
                        throw new Error("Rotation quaternion input not found");
                      }
                      if (context._connectionValues[d.uniqueId]) {
                        context._connectionValues[d.uniqueId].type = "Quaternion";
                      }
                      return serializedObjects;
                    }
                  },
                  "math/matDecompose": {
                    blocks: [
                      "FlowGraphMatrixDecompose"
                      /* FlowGraphBlockNames.MatrixDecompose */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        translation: { name: "position" },
                        rotation: { name: "rotationQuaternion" },
                        scale: { name: "scaling" }
                      }
                    }
                  },
                  "math/combine2x2": {
                    blocks: [
                      "FlowGraphCombineMatrix2DBlock"
                      /* FlowGraphBlockNames.CombineMatrix2D */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" },
                        c: { name: "input_2", gltfType: "number" },
                        d: { name: "input_3", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      serializedObjects[0].config.inputIsColumnMajor = true;
                      return serializedObjects;
                    }
                  },
                  "math/extract2x2": {
                    blocks: [
                      "FlowGraphExtractMatrix2DBlock"
                      /* FlowGraphBlockNames.ExtractMatrix2D */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "float2x2" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" },
                        "2": { name: "output_2" },
                        "3": { name: "output_3" }
                      }
                    }
                  },
                  "math/combine3x3": {
                    blocks: [
                      "FlowGraphCombineMatrix3DBlock"
                      /* FlowGraphBlockNames.CombineMatrix3D */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" },
                        c: { name: "input_2", gltfType: "number" },
                        d: { name: "input_3", gltfType: "number" },
                        e: { name: "input_4", gltfType: "number" },
                        f: { name: "input_5", gltfType: "number" },
                        g: { name: "input_6", gltfType: "number" },
                        h: { name: "input_7", gltfType: "number" },
                        i: { name: "input_8", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      serializedObjects[0].config.inputIsColumnMajor = true;
                      return serializedObjects;
                    }
                  },
                  "math/extract3x3": {
                    blocks: [
                      "FlowGraphExtractMatrix3DBlock"
                      /* FlowGraphBlockNames.ExtractMatrix3D */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "float3x3" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" },
                        "2": { name: "output_2" },
                        "3": { name: "output_3" },
                        "4": { name: "output_4" },
                        "5": { name: "output_5" },
                        "6": { name: "output_6" },
                        "7": { name: "output_7" },
                        "8": { name: "output_8" }
                      }
                    }
                  },
                  "math/combine4x4": {
                    blocks: [
                      "FlowGraphCombineMatrixBlock"
                      /* FlowGraphBlockNames.CombineMatrix */
                    ],
                    inputs: {
                      values: {
                        a: { name: "input_0", gltfType: "number" },
                        b: { name: "input_1", gltfType: "number" },
                        c: { name: "input_2", gltfType: "number" },
                        d: { name: "input_3", gltfType: "number" },
                        e: { name: "input_4", gltfType: "number" },
                        f: { name: "input_5", gltfType: "number" },
                        g: { name: "input_6", gltfType: "number" },
                        h: { name: "input_7", gltfType: "number" },
                        i: { name: "input_8", gltfType: "number" },
                        j: { name: "input_9", gltfType: "number" },
                        k: { name: "input_10", gltfType: "number" },
                        l: { name: "input_11", gltfType: "number" },
                        m: { name: "input_12", gltfType: "number" },
                        n: { name: "input_13", gltfType: "number" },
                        o: { name: "input_14", gltfType: "number" },
                        p: { name: "input_15", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      serializedObjects[0].config.inputIsColumnMajor = true;
                      return serializedObjects;
                    }
                  },
                  "math/extract4x4": {
                    blocks: [
                      "FlowGraphExtractMatrixBlock"
                      /* FlowGraphBlockNames.ExtractMatrix */
                    ],
                    configuration: {},
                    inputs: {
                      values: {
                        a: { name: "input", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        "0": { name: "output_0" },
                        "1": { name: "output_1" },
                        "2": { name: "output_2" },
                        "3": { name: "output_3" },
                        "4": { name: "output_4" },
                        "5": { name: "output_5" },
                        "6": { name: "output_6" },
                        "7": { name: "output_7" },
                        "8": { name: "output_8" },
                        "9": { name: "output_9" },
                        "10": { name: "output_10" },
                        "11": { name: "output_11" },
                        "12": { name: "output_12" },
                        "13": { name: "output_13" },
                        "14": { name: "output_14" },
                        "15": { name: "output_15" }
                      }
                    }
                  },
                  "math/compose": {
                    blocks: [
                      "FlowGraphMatrixCompose"
                      /* FlowGraphBlockNames.MatrixCompose */
                    ],
                    configuration: {},
                    inputs: {
                      values: {
                        translation: { name: "position", gltfType: "float3" },
                        rotation: { name: "rotationQuaternion", gltfType: "float4" },
                        scale: { name: "scaling", gltfType: "float3" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "output" }
                      }
                    }
                  },
                  "math/decompose": {
                    blocks: [
                      "FlowGraphMatrixDecompose"
                      /* FlowGraphBlockNames.MatrixDecompose */
                    ],
                    configuration: {},
                    inputs: {
                      values: {
                        a: { name: "input" }
                      }
                    },
                    outputs: {
                      values: {
                        translation: { name: "position" },
                        rotation: { name: "rotationQuaternion" },
                        scale: { name: "scaling" }
                      }
                    }
                  },
                  "math/not": {
                    blocks: [
                      "FlowGraphBitwiseNotBlock"
                      /* FlowGraphBlockNames.BitwiseNot */
                    ],
                    inputs: {
                      values: {
                        a: { name: "a" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
                      var _a, _b;
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      var socketIn = serializedObjects[0].dataInputs[0];
                      serializedObjects[0].config.valueType = (_b = (_a = context._connectionValues[socketIn.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : "FlowGraphInteger";
                      return serializedObjects;
                    }
                  },
                  "math/and": {
                    blocks: [
                      "FlowGraphBitwiseAndBlock"
                      /* FlowGraphBlockNames.BitwiseAnd */
                    ],
                    inputs: {
                      values: {
                        a: { name: "a" },
                        b: { name: "b" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
                      var _a, _b, _c, _d;
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      var socketInA = serializedObjects[0].dataInputs[0];
                      var socketInB = serializedObjects[0].dataInputs[1];
                      serializedObjects[0].config.valueType = (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger";
                      return serializedObjects;
                    }
                  },
                  "math/or": {
                    blocks: [
                      "FlowGraphBitwiseOrBlock"
                      /* FlowGraphBlockNames.BitwiseOr */
                    ],
                    inputs: {
                      values: {
                        a: { name: "a" },
                        b: { name: "b" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
                      var _a, _b, _c, _d;
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      var socketInA = serializedObjects[0].dataInputs[0];
                      var socketInB = serializedObjects[0].dataInputs[1];
                      serializedObjects[0].config.valueType = (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger";
                      return serializedObjects;
                    }
                  },
                  "math/xor": {
                    blocks: [
                      "FlowGraphBitwiseXorBlock"
                      /* FlowGraphBlockNames.BitwiseXor */
                    ],
                    inputs: {
                      values: {
                        a: { name: "a" },
                        b: { name: "b" }
                      }
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
                      var _a, _b, _c, _d;
                      serializedObjects[0].config = serializedObjects[0].config || {};
                      var socketInA = serializedObjects[0].dataInputs[0];
                      var socketInB = serializedObjects[0].dataInputs[1];
                      serializedObjects[0].config.valueType = (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger";
                      return serializedObjects;
                    }
                  },
                  "math/asr": getSimpleInputMapping("FlowGraphBitwiseRightShiftBlock", ["a", "b"]),
                  "math/lsl": getSimpleInputMapping("FlowGraphBitwiseLeftShiftBlock", ["a", "b"]),
                  "math/clz": getSimpleInputMapping(
                    "FlowGraphLeadingZerosBlock"
                    /* FlowGraphBlockNames.LeadingZeros */
                  ),
                  "math/ctz": getSimpleInputMapping(
                    "FlowGraphTrailingZerosBlock"
                    /* FlowGraphBlockNames.TrailingZeros */
                  ),
                  "math/popcnt": getSimpleInputMapping(
                    "FlowGraphOneBitsCounterBlock"
                    /* FlowGraphBlockNames.OneBitsCounter */
                  ),
                  "math/rad": getSimpleInputMapping(
                    "FlowGraphDegToRadBlock"
                    /* FlowGraphBlockNames.DegToRad */
                  ),
                  "math/deg": getSimpleInputMapping(
                    "FlowGraphRadToDegBlock"
                    /* FlowGraphBlockNames.RadToDeg */
                  ),
                  "type/boolToInt": getSimpleInputMapping(
                    "FlowGraphBooleanToInt"
                    /* FlowGraphBlockNames.BooleanToInt */
                  ),
                  "type/boolToFloat": getSimpleInputMapping(
                    "FlowGraphBooleanToFloat"
                    /* FlowGraphBlockNames.BooleanToFloat */
                  ),
                  "type/intToBool": getSimpleInputMapping(
                    "FlowGraphIntToBoolean"
                    /* FlowGraphBlockNames.IntToBoolean */
                  ),
                  "type/intToFloat": getSimpleInputMapping(
                    "FlowGraphIntToFloat"
                    /* FlowGraphBlockNames.IntToFloat */
                  ),
                  "type/floatToInt": getSimpleInputMapping(
                    "FlowGraphFloatToInt"
                    /* FlowGraphBlockNames.FloatToInt */
                  ),
                  "type/floatToBool": getSimpleInputMapping(
                    "FlowGraphFloatToBoolean"
                    /* FlowGraphBlockNames.FloatToBoolean */
                  ),
                  // flows
                  "flow/sequence": {
                    blocks: [
                      "FlowGraphSequenceBlock"
                      /* FlowGraphBlockNames.Sequence */
                    ],
                    extraProcessor: function(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
                      var serializedObject = serializedObjects[0];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;
                      serializedObject.signalOutputs.forEach(function(output, index) {
                        output.name = "out_" + index;
                      });
                      return serializedObjects;
                    }
                  },
                  "flow/branch": {
                    blocks: [
                      "FlowGraphBranchBlock"
                      /* FlowGraphBlockNames.Branch */
                    ],
                    outputs: {
                      flows: {
                        true: { name: "onTrue" },
                        false: { name: "onFalse" }
                      }
                    }
                  },
                  "flow/switch": {
                    blocks: [
                      "FlowGraphSwitchBlock"
                      /* FlowGraphBlockNames.Switch */
                    ],
                    configuration: {
                      cases: { name: "cases", inOptions: true, defaultValue: [] }
                    },
                    inputs: {
                      values: {
                        selection: { name: "case" }
                      }
                    },
                    validation: function(gltfBlock) {
                      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
                        var cases = gltfBlock.configuration.cases.value;
                        var onlyIntegers = cases.every(function(caseValue) {
                          return typeof caseValue === "number" && /^\d+$/.test(caseValue.toString());
                        });
                        if (!onlyIntegers) {
                          gltfBlock.configuration.cases.value = [];
                          return { valid: true };
                        }
                        var uniqueCases = new Set(cases);
                        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
                      }
                      return { valid: true };
                    },
                    extraProcessor: function(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
                      if (declaration.op !== "flow/switch" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
                        throw new Error("Switch should have a single configuration object, the cases array");
                      }
                      var serializedObject = serializedObjects[0];
                      serializedObject.signalOutputs.forEach(function(output) {
                        if (output.name !== "default") {
                          output.name = "out_" + output.name;
                        }
                      });
                      return serializedObjects;
                    }
                  },
                  "flow/while": {
                    blocks: [
                      "FlowGraphWhileLoopBlock"
                      /* FlowGraphBlockNames.WhileLoop */
                    ],
                    outputs: {
                      flows: {
                        loopBody: { name: "executionFlow" }
                      }
                    }
                  },
                  "flow/for": {
                    blocks: [
                      "FlowGraphForLoopBlock"
                      /* FlowGraphBlockNames.ForLoop */
                    ],
                    configuration: {
                      initialIndex: { name: "initialIndex", gltfType: "number", inOptions: true, defaultValue: 0 }
                    },
                    inputs: {
                      values: {
                        startIndex: { name: "startIndex", gltfType: "number" },
                        endIndex: { name: "endIndex", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        index: { name: "index" }
                      },
                      flows: {
                        loopBody: { name: "executionFlow" }
                      }
                    }
                  },
                  "flow/doN": {
                    blocks: [
                      "FlowGraphDoNBlock"
                      /* FlowGraphBlockNames.DoN */
                    ],
                    configuration: {},
                    inputs: {
                      values: {
                        n: { name: "maxExecutions", gltfType: "number" }
                      }
                    },
                    outputs: {
                      values: {
                        currentCount: { name: "executionCount" }
                      }
                    }
                  },
                  "flow/multiGate": {
                    blocks: [
                      "FlowGraphMultiGateBlock"
                      /* FlowGraphBlockNames.MultiGate */
                    ],
                    configuration: {
                      isRandom: { name: "isRandom", gltfType: "boolean", inOptions: true, defaultValue: false },
                      isLoop: { name: "isLoop", gltfType: "boolean", inOptions: true, defaultValue: false }
                    },
                    extraProcessor: function(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
                      if (declaration.op !== "flow/multiGate" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
                        throw new Error("MultiGate should have a single configuration object, the number of output flows");
                      }
                      var serializedObject = serializedObjects[0];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;
                      serializedObject.signalOutputs.forEach(function(output, index) {
                        output.name = "out_" + index;
                      });
                      return serializedObjects;
                    }
                  },
                  "flow/waitAll": {
                    blocks: [
                      "FlowGraphWaitAllBlock"
                      /* FlowGraphBlockNames.WaitAll */
                    ],
                    configuration: {
                      inputFlows: { name: "inputSignalCount", gltfType: "number", inOptions: true, defaultValue: 0 }
                    },
                    inputs: {
                      flows: {
                        "[segment]": { name: "in_$1" }
                      }
                    },
                    validation: function(gltfBlock) {
                      var _a, _b;
                      if (typeof ((_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.inputFlows) === null || _b === void 0 ? void 0 : _b.value[0]) !== "number") {
                        gltfBlock.configuration = gltfBlock.configuration || {
                          inputFlows: { value: [0] }
                        };
                        gltfBlock.configuration.inputFlows.value = [0];
                      }
                      return { valid: true };
                    }
                  },
                  "flow/throttle": {
                    blocks: [
                      "FlowGraphThrottleBlock"
                      /* FlowGraphBlockNames.Throttle */
                    ],
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    }
                  },
                  "flow/setDelay": {
                    blocks: [
                      "FlowGraphSetDelayBlock"
                      /* FlowGraphBlockNames.SetDelay */
                    ],
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    }
                  },
                  "flow/cancelDelay": {
                    blocks: [
                      "FlowGraphCancelDelayBlock"
                      /* FlowGraphBlockNames.CancelDelay */
                    ]
                  },
                  "variable/get": {
                    blocks: [
                      "FlowGraphGetVariableBlock"
                      /* FlowGraphBlockNames.GetVariable */
                    ],
                    validation: function(gltfBlock) {
                      var _a, _b;
                      if (!((_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.variable) === null || _b === void 0 ? void 0 : _b.value)) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Variable get block should have a variable configuration");
                        return { valid: false, error: "Variable get block should have a variable configuration" };
                      }
                      return { valid: true };
                    },
                    configuration: {
                      variable: {
                        name: "variable",
                        gltfType: "number",
                        flowGraphType: "string",
                        inOptions: true,
                        isVariable: true,
                        dataTransformer: function(index, parser) {
                          return [parser.getVariableName(index[0])];
                        }
                      }
                    }
                  },
                  "variable/set": {
                    blocks: [
                      "FlowGraphSetVariableBlock"
                      /* FlowGraphBlockNames.SetVariable */
                    ],
                    configuration: {
                      variable: {
                        name: "variable",
                        gltfType: "number",
                        flowGraphType: "string",
                        inOptions: true,
                        isVariable: true,
                        dataTransformer: function(index, parser) {
                          return [parser.getVariableName(index[0])];
                        }
                      }
                    }
                  },
                  "variable/setMultiple": {
                    blocks: [
                      "FlowGraphSetVariableBlock"
                      /* FlowGraphBlockNames.SetVariable */
                    ],
                    configuration: {
                      variables: {
                        name: "variables",
                        gltfType: "number",
                        flowGraphType: "string",
                        inOptions: true,
                        dataTransformer: function(index, parser) {
                          return [index[0].map(function(i) {
                            return parser.getVariableName(i);
                          })];
                        }
                      }
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {
                      var serializedGetVariable = serializedObjects[0];
                      serializedGetVariable.dataInputs.forEach(function(input) {
                        input.name = parser.getVariableName(+input.name);
                      });
                      return serializedObjects;
                    }
                  },
                  "variable/interpolate": {
                    blocks: [
                      "FlowGraphInterpolationBlock",
                      "FlowGraphContextBlock",
                      "FlowGraphPlayAnimationBlock",
                      "FlowGraphBezierCurveEasing",
                      "FlowGraphGetVariableBlock"
                    ],
                    configuration: {
                      variable: {
                        name: "propertyName",
                        inOptions: true,
                        isVariable: true,
                        dataTransformer: function(index, parser) {
                          return [parser.getVariableName(index[0])];
                        }
                      },
                      useSlerp: {
                        name: "animationType",
                        inOptions: true,
                        defaultValue: false,
                        dataTransformer: function(value) {
                          if (value[0] === true) {
                            return [
                              "Quaternion"
                              /* FlowGraphTypes.Quaternion */
                            ];
                          } else {
                            return [void 0];
                          }
                        }
                      }
                    },
                    inputs: {
                      values: {
                        value: { name: "value_1" },
                        duration: { name: "duration_1", gltfType: "number" },
                        p1: {
                          name: "controlPoint1",
                          toBlock: "FlowGraphBezierCurveEasing"
                          /* FlowGraphBlockNames.BezierCurveEasing */
                        },
                        p2: {
                          name: "controlPoint2",
                          toBlock: "FlowGraphBezierCurveEasing"
                          /* FlowGraphBlockNames.BezierCurveEasing */
                        }
                      },
                      flows: {
                        in: {
                          name: "in",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        }
                      }
                    },
                    outputs: {
                      flows: {
                        err: {
                          name: "error",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        },
                        out: {
                          name: "out",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        },
                        done: {
                          name: "done",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "object",
                        output: "userVariables",
                        inputBlockIndex: 2,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "animation",
                        output: "animation",
                        inputBlockIndex: 2,
                        outputBlockIndex: 0,
                        isVariable: true
                      },
                      {
                        input: "easingFunction",
                        output: "easingFunction",
                        inputBlockIndex: 0,
                        outputBlockIndex: 3,
                        isVariable: true
                      },
                      {
                        input: "value_0",
                        output: "value",
                        inputBlockIndex: 0,
                        outputBlockIndex: 4,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
                      var _a;
                      var _b, _c;
                      var serializedValueInterpolation = serializedObjects[0];
                      var propertyIndex = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.variable.value[0];
                      if (typeof propertyIndex !== "number") {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Variable index is not defined for variable interpolation block");
                        throw new Error("Variable index is not defined for variable interpolation block");
                      }
                      var variable = parser.arrays.staticVariables[propertyIndex];
                      if (typeof serializedValueInterpolation.config.animationType.value === "undefined") {
                        parser.arrays.staticVariables;
                        serializedValueInterpolation.config.animationType.value = (0, babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.getAnimationTypeByFlowGraphType)(variable.type);
                      }
                      var serializedGetVariable = serializedObjects[4];
                      serializedGetVariable.config || (serializedGetVariable.config = {});
                      (_b = serializedGetVariable.config).variable || (_b.variable = {});
                      serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);
                      (_c = serializedObjects[3]).config || (_c.config = {});
                      return serializedObjects;
                    }
                  },
                  "pointer/get": {
                    blocks: [
                      "FlowGraphGetPropertyBlock",
                      "FlowGraphJsonPointerParserBlock"
                      /* FlowGraphBlockNames.JsonPointerParser */
                    ],
                    configuration: {
                      pointer: {
                        name: "jsonPointer",
                        toBlock: "FlowGraphJsonPointerParserBlock"
                        /* FlowGraphBlockNames.JsonPointerParser */
                      }
                    },
                    inputs: {
                      values: {
                        "[segment]": {
                          name: "$1",
                          toBlock: "FlowGraphJsonPointerParserBlock"
                          /* FlowGraphBlockNames.JsonPointerParser */
                        }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "object",
                        output: "object",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "propertyName",
                        output: "propertyName",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "customGetFunction",
                        output: "getFunction",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
                      serializedObjects.forEach(function(serializedObject) {
                        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
                          serializedObject.config || (serializedObject.config = {});
                          serializedObject.config.outputValue = true;
                        }
                      });
                      return serializedObjects;
                    }
                  },
                  "pointer/set": {
                    blocks: [
                      "FlowGraphSetPropertyBlock",
                      "FlowGraphJsonPointerParserBlock"
                      /* FlowGraphBlockNames.JsonPointerParser */
                    ],
                    configuration: {
                      pointer: {
                        name: "jsonPointer",
                        toBlock: "FlowGraphJsonPointerParserBlock"
                        /* FlowGraphBlockNames.JsonPointerParser */
                      }
                    },
                    inputs: {
                      values: {
                        // must be defined due to the array taking over
                        value: { name: "value" },
                        "[segment]": {
                          name: "$1",
                          toBlock: "FlowGraphJsonPointerParserBlock"
                          /* FlowGraphBlockNames.JsonPointerParser */
                        }
                      }
                    },
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "object",
                        output: "object",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "propertyName",
                        output: "propertyName",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "customSetFunction",
                        output: "setFunction",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
                      serializedObjects.forEach(function(serializedObject) {
                        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
                          serializedObject.config || (serializedObject.config = {});
                          serializedObject.config.outputValue = true;
                        }
                      });
                      return serializedObjects;
                    }
                  },
                  "pointer/interpolate": {
                    // interpolate, parse the pointer and play the animation generated. 3 blocks!
                    blocks: [
                      "FlowGraphInterpolationBlock",
                      "FlowGraphJsonPointerParserBlock",
                      "FlowGraphPlayAnimationBlock",
                      "FlowGraphBezierCurveEasing"
                      /* FlowGraphBlockNames.BezierCurveEasing */
                    ],
                    configuration: {
                      pointer: {
                        name: "jsonPointer",
                        toBlock: "FlowGraphJsonPointerParserBlock"
                        /* FlowGraphBlockNames.JsonPointerParser */
                      }
                    },
                    inputs: {
                      values: {
                        value: { name: "value_1" },
                        "[segment]": {
                          name: "$1",
                          toBlock: "FlowGraphJsonPointerParserBlock"
                          /* FlowGraphBlockNames.JsonPointerParser */
                        },
                        duration: {
                          name: "duration_1",
                          gltfType: "number"
                          /*, inOptions: true */
                        },
                        p1: {
                          name: "controlPoint1",
                          toBlock: "FlowGraphBezierCurveEasing"
                          /* FlowGraphBlockNames.BezierCurveEasing */
                        },
                        p2: {
                          name: "controlPoint2",
                          toBlock: "FlowGraphBezierCurveEasing"
                          /* FlowGraphBlockNames.BezierCurveEasing */
                        }
                      },
                      flows: {
                        in: {
                          name: "in",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        }
                      }
                    },
                    outputs: {
                      flows: {
                        err: {
                          name: "error",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        },
                        out: {
                          name: "out",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        },
                        done: {
                          name: "done",
                          toBlock: "FlowGraphPlayAnimationBlock"
                          /* FlowGraphBlockNames.PlayAnimation */
                        }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "object",
                        output: "object",
                        inputBlockIndex: 2,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "propertyName",
                        output: "propertyName",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "customBuildAnimation",
                        output: "generateAnimationsFunction",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "animation",
                        output: "animation",
                        inputBlockIndex: 2,
                        outputBlockIndex: 0,
                        isVariable: true
                      },
                      {
                        input: "easingFunction",
                        output: "easingFunction",
                        inputBlockIndex: 0,
                        outputBlockIndex: 3,
                        isVariable: true
                      },
                      {
                        input: "value_0",
                        output: "value",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
                      serializedObjects.forEach(function(serializedObject) {
                        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
                          serializedObject.config || (serializedObject.config = {});
                          serializedObject.config.outputValue = true;
                        } else if (serializedObject.className === "FlowGraphInterpolationBlock") {
                          serializedObject.config || (serializedObject.config = {});
                          Object.keys(gltfBlock.values || []).forEach(function(key) {
                            var _a;
                            var value = (_a = gltfBlock.values) === null || _a === void 0 ? void 0 : _a[key];
                            if (key === "value" && value) {
                              var type = value.type;
                              if (type !== void 0) {
                                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;
                              }
                            }
                          });
                        }
                      });
                      return serializedObjects;
                    }
                  },
                  "animation/start": {
                    blocks: ["FlowGraphPlayAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                    inputs: {
                      values: {
                        animation: {
                          name: "index",
                          gltfType: "number",
                          toBlock: "FlowGraphArrayIndexBlock"
                          /* FlowGraphBlockNames.ArrayIndex */
                        },
                        speed: { name: "speed", gltfType: "number" },
                        // 60 is a const from the glTF loader
                        startTime: { name: "from", gltfType: "number", dataTransformer: function(time, parser) {
                          return [time[0] * parser._loader.parent.targetFps];
                        } },
                        endTime: { name: "to", gltfType: "number", dataTransformer: function(time, parser) {
                          return [time[0] * parser._loader.parent.targetFps];
                        } }
                      }
                    },
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "animationGroup",
                        output: "value",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "array",
                        output: "animationGroups",
                        inputBlockIndex: 1,
                        outputBlockIndex: 2,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
                      var serializedObject = serializedObjects[serializedObjects.length - 1];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.glTF = globalGLTF;
                      return serializedObjects;
                    }
                  },
                  "animation/stop": {
                    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                    inputs: {
                      values: {
                        animation: {
                          name: "index",
                          gltfType: "number",
                          toBlock: "FlowGraphArrayIndexBlock"
                          /* FlowGraphBlockNames.ArrayIndex */
                        }
                      }
                    },
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "animationGroup",
                        output: "value",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "array",
                        output: "animationGroups",
                        inputBlockIndex: 1,
                        outputBlockIndex: 2,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
                      var serializedObject = serializedObjects[serializedObjects.length - 1];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.glTF = globalGLTF;
                      return serializedObjects;
                    }
                  },
                  "animation/stopAt": {
                    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                    configuration: {},
                    inputs: {
                      values: {
                        animation: {
                          name: "index",
                          gltfType: "number",
                          toBlock: "FlowGraphArrayIndexBlock"
                          /* FlowGraphBlockNames.ArrayIndex */
                        },
                        stopTime: { name: "stopAtFrame", gltfType: "number", dataTransformer: function(time, parser) {
                          return [time[0] * parser._loader.parent.targetFps];
                        } }
                      }
                    },
                    outputs: {
                      flows: {
                        err: { name: "error" }
                      }
                    },
                    interBlockConnectors: [
                      {
                        input: "animationGroup",
                        output: "value",
                        inputBlockIndex: 0,
                        outputBlockIndex: 1,
                        isVariable: true
                      },
                      {
                        input: "array",
                        output: "animationGroups",
                        inputBlockIndex: 1,
                        outputBlockIndex: 2,
                        isVariable: true
                      }
                    ],
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
                      var serializedObject = serializedObjects[serializedObjects.length - 1];
                      serializedObject.config || (serializedObject.config = {});
                      serializedObject.config.glTF = globalGLTF;
                      return serializedObjects;
                    }
                  },
                  "math/switch": {
                    blocks: [
                      "FlowGraphDataSwitchBlock"
                      /* FlowGraphBlockNames.DataSwitch */
                    ],
                    configuration: {
                      cases: { name: "cases", inOptions: true, defaultValue: [] }
                    },
                    inputs: {
                      values: {
                        selection: { name: "case" }
                      }
                    },
                    validation: function(gltfBlock) {
                      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
                        var cases = gltfBlock.configuration.cases.value;
                        var onlyIntegers = cases.every(function(caseValue) {
                          return typeof caseValue === "number" && /^\d+$/.test(caseValue.toString());
                        });
                        if (!onlyIntegers) {
                          gltfBlock.configuration.cases.value = [];
                          return { valid: true };
                        }
                        var uniqueCases = new Set(cases);
                        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
                      }
                      return { valid: true };
                    },
                    extraProcessor: function(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
                      var serializedObject = serializedObjects[0];
                      serializedObject.dataInputs.forEach(function(input) {
                        if (input.name !== "default" && input.name !== "case") {
                          input.name = "in_" + input.name;
                        }
                      });
                      return serializedObjects;
                    }
                  },
                  "debug/log": {
                    blocks: [
                      "FlowGraphConsoleLogBlock"
                      /* FlowGraphBlockNames.ConsoleLog */
                    ],
                    configuration: {
                      message: { name: "messageTemplate", inOptions: true }
                    }
                  }
                };
                function getSimpleInputMapping(type, inputs, inferType) {
                  if (inputs === void 0) {
                    inputs = ["a"];
                  }
                  return {
                    blocks: [type],
                    inputs: {
                      values: inputs.reduce(function(acc, input) {
                        acc[input] = { name: input };
                        return acc;
                      }, {})
                    },
                    outputs: {
                      values: {
                        value: { name: "value" }
                      }
                    },
                    extraProcessor: function(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
                      if (inferType) {
                        serializedObjects[0].config = serializedObjects[0].config || {};
                        serializedObjects[0].config.preventIntegerFloatArithmetic = true;
                        var type_1 = -1;
                        Object.keys(gltfBlock.values || {}).find(function(value) {
                          var _a;
                          if (((_a = gltfBlock.values) === null || _a === void 0 ? void 0 : _a[value].type) !== void 0) {
                            type_1 = gltfBlock.values[value].type;
                            return true;
                          }
                          return false;
                        });
                        if (type_1 !== -1) {
                          serializedObjects[0].config.type = _parser.arrays.types[type_1].flowGraphType;
                        }
                      }
                      return serializedObjects;
                    },
                    validation: function(gltfBlock) {
                      if (inferType) {
                        if (gltfBlock.values) {
                          var types_2 = Object.keys(gltfBlock.values).map(function(key) {
                            return gltfBlock.values[key].type;
                          });
                          console.log(types_2);
                          var allSameType = types_2.every(function(type2) {
                            return type2 === void 0 || type2 === types_2[0];
                          });
                          if (!allSameType) {
                            return { valid: false, error: "All inputs must be of the same type" };
                          }
                        }
                      }
                      return { valid: true };
                    }
                  };
                }
                function getAllSupportedNativeNodeTypes() {
                  return Object.keys(gltfToFlowGraphMapping);
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts": (
              /*!***************************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts ***!
                \***************************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  FlowGraphGLTFDataProvider: () => (
                    /* binding */
                    FlowGraphGLTFDataProvider
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/FlowGraph/flowGraphRichTypes */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__);
                var FlowGraphGLTFDataProvider = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FlowGraphGLTFDataProvider2, _super);
                    function FlowGraphGLTFDataProvider2(config) {
                      var _a, _b;
                      var _this = _super.call(this) || this;
                      var glTF = config.glTF;
                      var animationGroups = ((_a = glTF.animations) === null || _a === void 0 ? void 0 : _a.map(function(a) {
                        return a._babylonAnimationGroup;
                      })) || [];
                      _this.animationGroups = _this.registerDataOutput("animationGroups", babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.RichTypeAny, animationGroups);
                      var nodes = ((_b = glTF.nodes) === null || _b === void 0 ? void 0 : _b.map(function(n) {
                        return n._babylonTransformNode;
                      })) || [];
                      _this.nodes = _this.registerDataOutput("nodes", babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.RichTypeAny, nodes);
                      return _this;
                    }
                    FlowGraphGLTFDataProvider2.prototype.getClassName = function() {
                      return "FlowGraphGLTFDataProvider";
                    };
                    return FlowGraphGLTFDataProvider2;
                  }(babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.FlowGraphBlock)
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  FlowGraphGLTFDataProvider: () => (
                    /* reexport safe */
                    _flowGraphGLTFDataProvider__WEBPACK_IMPORTED_MODULE_2__.FlowGraphGLTFDataProvider
                  ),
                  /* harmony export */
                  InteractivityGraphToFlowGraphParser: () => (
                    /* reexport safe */
                    _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__.InteractivityGraphToFlowGraphParser
                  ),
                  /* harmony export */
                  addNewInteractivityFlowGraphMapping: () => (
                    /* reexport safe */
                    _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.addNewInteractivityFlowGraphMapping
                  ),
                  /* harmony export */
                  getAllSupportedNativeNodeTypes: () => (
                    /* reexport safe */
                    _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getAllSupportedNativeNodeTypes
                  ),
                  /* harmony export */
                  getMappingForDeclaration: () => (
                    /* reexport safe */
                    _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForDeclaration
                  ),
                  /* harmony export */
                  getMappingForFullOperationName: () => (
                    /* reexport safe */
                    _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName
                  ),
                  /* harmony export */
                  gltfTypeToBabylonType: () => (
                    /* reexport safe */
                    _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__.gltfTypeToBabylonType
                  )
                  /* harmony export */
                });
                var _declarationMapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./declarationMapper */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts"
                );
                var _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./interactivityGraphParser */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts"
                );
                var _flowGraphGLTFDataProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./flowGraphGLTFDataProvider */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts": (
              /*!**************************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts ***!
                \**************************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  InteractivityGraphToFlowGraphParser: () => (
                    /* binding */
                    InteractivityGraphToFlowGraphParser
                  ),
                  /* harmony export */
                  gltfTypeToBabylonType: () => (
                    /* binding */
                    gltfTypeToBabylonType
                  )
                  /* harmony export */
                });
                var _declarationMapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./declarationMapper */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Misc/guid */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__);
                var gltfTypeToBabylonType = {
                  float: { length: 1, flowGraphType: "number", elementType: "number" },
                  bool: { length: 1, flowGraphType: "boolean", elementType: "boolean" },
                  float2: { length: 2, flowGraphType: "Vector2", elementType: "number" },
                  float3: { length: 3, flowGraphType: "Vector3", elementType: "number" },
                  float4: { length: 4, flowGraphType: "Vector4", elementType: "number" },
                  float4x4: { length: 16, flowGraphType: "Matrix", elementType: "number" },
                  float2x2: { length: 4, flowGraphType: "Matrix2D", elementType: "number" },
                  float3x3: { length: 9, flowGraphType: "Matrix3D", elementType: "number" },
                  int: { length: 1, flowGraphType: "FlowGraphInteger", elementType: "number" }
                };
                var InteractivityGraphToFlowGraphParser = (
                  /** @class */
                  function() {
                    function InteractivityGraphToFlowGraphParser2(_interactivityGraph, _gltf, _loader) {
                      this._interactivityGraph = _interactivityGraph;
                      this._gltf = _gltf;
                      this._loader = _loader;
                      this._types = [];
                      this._mappings = [];
                      this._staticVariables = [];
                      this._events = [];
                      this._internalEventsCounter = 0;
                      this._nodes = [];
                      this._parseTypes();
                      this._parseDeclarations();
                      this._parseVariables();
                      this._parseEvents();
                      this._parseNodes();
                    }
                    Object.defineProperty(InteractivityGraphToFlowGraphParser2.prototype, "arrays", {
                      get: function() {
                        return {
                          types: this._types,
                          mappings: this._mappings,
                          staticVariables: this._staticVariables,
                          events: this._events,
                          nodes: this._nodes
                        };
                      },
                      enumerable: false,
                      configurable: true
                    });
                    InteractivityGraphToFlowGraphParser2.prototype._parseTypes = function() {
                      if (!this._interactivityGraph.types) {
                        return;
                      }
                      for (var _i = 0, _a = this._interactivityGraph.types; _i < _a.length; _i++) {
                        var type = _a[_i];
                        this._types.push(gltfTypeToBabylonType[type.signature]);
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseDeclarations = function() {
                      if (!this._interactivityGraph.declarations) {
                        return;
                      }
                      for (var _i = 0, _a = this._interactivityGraph.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        var mapping = (0, _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForDeclaration)(declaration);
                        if (!mapping) {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for declaration", declaration]);
                          throw new Error("Error parsing declarations");
                        }
                        this._mappings.push({
                          flowGraphMapping: mapping,
                          fullOperationName: declaration.extension ? declaration.op + ":" + declaration.extension : declaration.op
                        });
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseVariables = function() {
                      if (!this._interactivityGraph.variables) {
                        return;
                      }
                      for (var _i = 0, _a = this._interactivityGraph.variables; _i < _a.length; _i++) {
                        var variable = _a[_i];
                        var parsed = this._parseVariable(variable);
                        this._staticVariables.push(parsed);
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseVariable = function(variable, dataTransform) {
                      var type = this._types[variable.type];
                      if (!type) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No type found for variable", variable]);
                        throw new Error("Error parsing variables");
                      }
                      if (variable.value) {
                        if (variable.value.length !== type.length) {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["Invalid value length for variable", variable, type]);
                          throw new Error("Error parsing variables");
                        }
                      }
                      var value = variable.value || [];
                      if (!value.length) {
                        switch (type.flowGraphType) {
                          case "boolean":
                            value.push(false);
                            break;
                          case "FlowGraphInteger":
                            value.push(0);
                            break;
                          case "number":
                            value.push(NaN);
                            break;
                          case "Vector2":
                            value.push(NaN, NaN);
                            break;
                          case "Vector3":
                            value.push(NaN, NaN, NaN);
                            break;
                          case "Vector4":
                          case "Matrix2D":
                          case "Quaternion":
                            value.fill(NaN, 0, 4);
                            break;
                          case "Matrix":
                            value.fill(NaN, 0, 16);
                            break;
                          case "Matrix3D":
                            value.fill(NaN, 0, 9);
                            break;
                          default:
                            break;
                        }
                      }
                      if (type.elementType === "number" && typeof value[0] === "string") {
                        value[0] = parseFloat(value[0]);
                      }
                      return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseEvents = function() {
                      var _this = this;
                      if (!this._interactivityGraph.events) {
                        return;
                      }
                      var _loop_1 = function(event_12) {
                        var converted = {
                          eventId: event_12.id || "internalEvent_" + this_1._internalEventsCounter++
                        };
                        if (event_12.values) {
                          converted.eventData = Object.keys(event_12.values).map(function(key) {
                            var _a2;
                            var eventValue = (_a2 = event_12.values) === null || _a2 === void 0 ? void 0 : _a2[key];
                            if (!eventValue) {
                              babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No value found for event key", key]);
                              throw new Error("Error parsing events");
                            }
                            var type = _this._types[eventValue.type];
                            if (!type) {
                              babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No type found for event value", eventValue]);
                              throw new Error("Error parsing events");
                            }
                            var value = typeof eventValue.value !== "undefined" ? _this._parseVariable(eventValue) : void 0;
                            return {
                              id: key,
                              type: type.flowGraphType,
                              eventData: true,
                              value
                            };
                          });
                        }
                        this_1._events.push(converted);
                      };
                      var this_1 = this;
                      for (var _i = 0, _a = this._interactivityGraph.events; _i < _a.length; _i++) {
                        var event_1 = _a[_i];
                        _loop_1(event_1);
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseNodes = function() {
                      var _a;
                      if (!this._interactivityGraph.nodes) {
                        return;
                      }
                      for (var _i = 0, _b = this._interactivityGraph.nodes; _i < _b.length; _i++) {
                        var node = _b[_i];
                        if (typeof node.declaration !== "number") {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No declaration found for node", node]);
                          throw new Error("Error parsing nodes");
                        }
                        var mapping = this._mappings[node.declaration];
                        if (!mapping) {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for node", node]);
                          throw new Error("Error parsing nodes");
                        }
                        if (mapping.flowGraphMapping.validation) {
                          var validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);
                          if (!validationResult.valid) {
                            throw new Error("Error validating interactivity node ".concat((_a = this._interactivityGraph.declarations) === null || _a === void 0 ? void 0 : _a[node.declaration].op, " - ").concat(validationResult.error));
                          }
                        }
                        var blocks = [];
                        for (var _c = 0, _d = mapping.flowGraphMapping.blocks; _c < _d.length; _c++) {
                          var blockType = _d[_c];
                          var block = this._getEmptyBlock(blockType, mapping.fullOperationName);
                          this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);
                          blocks.push(block);
                        }
                        this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._getEmptyBlock = function(className, type) {
                      var uniqueId = (0, babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)();
                      var dataInputs = [];
                      var dataOutputs = [];
                      var signalInputs = [];
                      var signalOutputs = [];
                      var config = {};
                      var metadata = {};
                      return {
                        uniqueId,
                        className,
                        dataInputs,
                        dataOutputs,
                        signalInputs,
                        signalOutputs,
                        config,
                        type,
                        metadata
                      };
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseNodeConfiguration = function(node, block, nodeMapping, blockType) {
                      var _this = this;
                      var configuration = block.config;
                      if (node.configuration) {
                        Object.keys(node.configuration).forEach(function(key) {
                          var _a, _b;
                          var value = (_a = node.configuration) === null || _a === void 0 ? void 0 : _a[key];
                          if (!value) {
                            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No value found for node configuration", key]);
                            throw new Error("Error parsing node configuration");
                          }
                          var configMapping = (_b = nodeMapping.configuration) === null || _b === void 0 ? void 0 : _b[key];
                          var belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;
                          if (belongsToBlock) {
                            var configKey = (configMapping === null || configMapping === void 0 ? void 0 : configMapping.name) || key;
                            if ((!value || typeof value.value === "undefined") && typeof (configMapping === null || configMapping === void 0 ? void 0 : configMapping.defaultValue) !== "undefined") {
                              configuration[configKey] = {
                                value: configMapping.defaultValue
                              };
                            } else if (value.value.length >= 1) {
                              configuration[configKey] = {
                                value: value.value.length === 1 ? value.value[0] : value.value
                              };
                            } else {
                              babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn(["Invalid value for node configuration", value]);
                            }
                            if (configMapping && configMapping.dataTransformer) {
                              configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], _this)[0];
                            }
                          }
                        });
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._parseNodeConnections = function(context) {
                      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
                      for (var i = 0; i < this._nodes.length; i++) {
                        var gltfNode = (_a = this._interactivityGraph.nodes) === null || _a === void 0 ? void 0 : _a[i];
                        if (!gltfNode) {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for interactivity node", this._nodes[i]]);
                          throw new Error("Error parsing node connections");
                        }
                        var flowGraphBlocks = this._nodes[i];
                        var outputMapper = this._mappings[gltfNode.declaration];
                        if (!outputMapper) {
                          babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for node", gltfNode]);
                          throw new Error("Error parsing node connections");
                        }
                        var flowsFromGLTF = gltfNode.flows || {};
                        var flowsKeys = Object.keys(flowsFromGLTF).sort();
                        var _loop_2 = function(flowKey2) {
                          var flow = flowsFromGLTF[flowKey2];
                          var flowMapping = (_c = (_b = outputMapper.flowGraphMapping.outputs) === null || _b === void 0 ? void 0 : _b.flows) === null || _c === void 0 ? void 0 : _c[flowKey2];
                          var socketOutName = (flowMapping === null || flowMapping === void 0 ? void 0 : flowMapping.name) || flowKey2;
                          var socketOut = this_2._createNewSocketConnection(socketOutName, true);
                          var block = flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find(function(b) {
                            return b.className === flowMapping.toBlock;
                          }) || flowGraphBlocks.blocks[0];
                          block.signalOutputs.push(socketOut);
                          var inputNodeId = flow.node;
                          var nodeIn = this_2._nodes[inputNodeId];
                          if (!nodeIn) {
                            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for input node id", inputNodeId]);
                            throw new Error("Error parsing node connections");
                          }
                          var inputMapper = (0, _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName)(nodeIn.fullOperationName);
                          if (!inputMapper) {
                            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for input node", nodeIn]);
                            throw new Error("Error parsing node connections");
                          }
                          var flowInMapping = (_e = (_d = inputMapper.inputs) === null || _d === void 0 ? void 0 : _d.flows) === null || _e === void 0 ? void 0 : _e[flow.socket || "in"];
                          var arrayMapping = false;
                          if (!flowInMapping) {
                            for (var key in (_f = inputMapper.inputs) === null || _f === void 0 ? void 0 : _f.flows) {
                              if (key.startsWith("[") && key.endsWith("]")) {
                                arrayMapping = true;
                                flowInMapping = (_h = (_g = inputMapper.inputs) === null || _g === void 0 ? void 0 : _g.flows) === null || _h === void 0 ? void 0 : _h[key];
                              }
                            }
                          }
                          var nodeInSocketName = flowInMapping ? arrayMapping ? flowInMapping.name.replace("$1", flow.socket || "") : flowInMapping.name : flow.socket || "in";
                          var inputBlock = flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find(function(b) {
                            return b.className === flowInMapping.toBlock;
                          }) || nodeIn.blocks[0];
                          var socketIn = inputBlock.signalInputs.find(function(s) {
                            return s.name === nodeInSocketName;
                          });
                          if (!socketIn) {
                            socketIn = this_2._createNewSocketConnection(nodeInSocketName);
                            inputBlock.signalInputs.push(socketIn);
                          }
                          socketIn.connectedPointIds.push(socketOut.uniqueId);
                          socketOut.connectedPointIds.push(socketIn.uniqueId);
                        };
                        var this_2 = this;
                        for (var _i = 0, flowsKeys_1 = flowsKeys; _i < flowsKeys_1.length; _i++) {
                          var flowKey = flowsKeys_1[_i];
                          _loop_2(flowKey);
                        }
                        var valuesFromGLTF = gltfNode.values || {};
                        var valuesKeys = Object.keys(valuesFromGLTF);
                        var _loop_3 = function(valueKey2) {
                          var value = valuesFromGLTF[valueKey2];
                          var valueMapping = (_k = (_j = outputMapper.flowGraphMapping.inputs) === null || _j === void 0 ? void 0 : _j.values) === null || _k === void 0 ? void 0 : _k[valueKey2];
                          var arrayMapping = false;
                          if (!valueMapping) {
                            for (var key in (_l = outputMapper.flowGraphMapping.inputs) === null || _l === void 0 ? void 0 : _l.values) {
                              if (key.startsWith("[") && key.endsWith("]")) {
                                arrayMapping = true;
                                valueMapping = (_o = (_m = outputMapper.flowGraphMapping.inputs) === null || _m === void 0 ? void 0 : _m.values) === null || _o === void 0 ? void 0 : _o[key];
                              }
                            }
                          }
                          var socketInName = valueMapping ? arrayMapping ? valueMapping.name.replace("$1", valueKey2) : valueMapping.name : valueKey2;
                          var socketIn = this_3._createNewSocketConnection(socketInName);
                          var block = valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find(function(b) {
                            return b.className === valueMapping.toBlock;
                          }) || flowGraphBlocks.blocks[0];
                          block.dataInputs.push(socketIn);
                          if (value.value !== void 0) {
                            var convertedValue = this_3._parseVariable(value, valueMapping && valueMapping.dataTransformer);
                            context._connectionValues[socketIn.uniqueId] = convertedValue;
                          } else if (typeof value.node !== "undefined") {
                            var nodeOutId = value.node;
                            var nodeOutSocketName = value.socket || "value";
                            var nodeOut = this_3._nodes[nodeOutId];
                            if (!nodeOut) {
                              babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for output socket reference", value]);
                              throw new Error("Error parsing node connections");
                            }
                            var outputMapper_1 = (0, _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName)(nodeOut.fullOperationName);
                            if (!outputMapper_1) {
                              babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for output socket reference", value]);
                              throw new Error("Error parsing node connections");
                            }
                            var valueMapping_1 = (_q = (_p = outputMapper_1.outputs) === null || _p === void 0 ? void 0 : _p.values) === null || _q === void 0 ? void 0 : _q[nodeOutSocketName];
                            var arrayMapping_1 = false;
                            if (!valueMapping_1) {
                              for (var key in (_r = outputMapper_1.outputs) === null || _r === void 0 ? void 0 : _r.values) {
                                if (key.startsWith("[") && key.endsWith("]")) {
                                  arrayMapping_1 = true;
                                  valueMapping_1 = (_t = (_s = outputMapper_1.outputs) === null || _s === void 0 ? void 0 : _s.values) === null || _t === void 0 ? void 0 : _t[key];
                                }
                              }
                            }
                            var socketOutName_1 = valueMapping_1 ? arrayMapping_1 ? valueMapping_1.name.replace("$1", nodeOutSocketName) : valueMapping_1 === null || valueMapping_1 === void 0 ? void 0 : valueMapping_1.name : nodeOutSocketName;
                            var outBlock = valueMapping_1 && valueMapping_1.toBlock && nodeOut.blocks.find(function(b) {
                              return b.className === valueMapping_1.toBlock;
                            }) || nodeOut.blocks[0];
                            var socketOut = outBlock.dataOutputs.find(function(s) {
                              return s.name === socketOutName_1;
                            });
                            if (!socketOut) {
                              socketOut = this_3._createNewSocketConnection(socketOutName_1, true);
                              outBlock.dataOutputs.push(socketOut);
                            }
                            socketIn.connectedPointIds.push(socketOut.uniqueId);
                            socketOut.connectedPointIds.push(socketIn.uniqueId);
                          } else {
                            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["Invalid value for value connection", value]);
                            throw new Error("Error parsing node connections");
                          }
                        };
                        var this_3 = this;
                        for (var _v = 0, valuesKeys_1 = valuesKeys; _v < valuesKeys_1.length; _v++) {
                          var valueKey = valuesKeys_1[_v];
                          _loop_3(valueKey);
                        }
                        if (outputMapper.flowGraphMapping.interBlockConnectors) {
                          for (var _w = 0, _x = outputMapper.flowGraphMapping.interBlockConnectors; _w < _x.length; _w++) {
                            var connector = _x[_w];
                            var input = connector.input;
                            var output = connector.output;
                            var isVariable = connector.isVariable;
                            this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);
                          }
                        }
                        if (outputMapper.flowGraphMapping.extraProcessor) {
                          var declaration = (_u = this._interactivityGraph.declarations) === null || _u === void 0 ? void 0 : _u[gltfNode.declaration];
                          if (!declaration) {
                            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No declaration found for extra processor", gltfNode]);
                            throw new Error("Error parsing node connections");
                          }
                          flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(gltfNode, declaration, outputMapper.flowGraphMapping, this, flowGraphBlocks.blocks, context, this._gltf);
                        }
                      }
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._createNewSocketConnection = function(name2, isOutput) {
                      return {
                        uniqueId: (0, babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)(),
                        name: name2,
                        _connectionType: isOutput ? 1 : 0,
                        connectedPointIds: []
                      };
                    };
                    InteractivityGraphToFlowGraphParser2.prototype._connectFlowGraphNodes = function(input, output, serializedInput, serializedOutput, isVariable) {
                      var inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;
                      var outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;
                      var inputConnection = inputArray.find(function(s) {
                        return s.name === input;
                      }) || this._createNewSocketConnection(input);
                      var outputConnection = outputArray.find(function(s) {
                        return s.name === output;
                      }) || this._createNewSocketConnection(output, true);
                      if (!inputArray.find(function(s) {
                        return s.name === input;
                      })) {
                        inputArray.push(inputConnection);
                      }
                      if (!outputArray.find(function(s) {
                        return s.name === output;
                      })) {
                        outputArray.push(outputConnection);
                      }
                      inputConnection.connectedPointIds.push(outputConnection.uniqueId);
                      outputConnection.connectedPointIds.push(inputConnection.uniqueId);
                    };
                    InteractivityGraphToFlowGraphParser2.prototype.getVariableName = function(index) {
                      return "staticVariable_" + index;
                    };
                    InteractivityGraphToFlowGraphParser2.prototype.serializeToFlowGraph = function() {
                      var context = {
                        uniqueId: (0, babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)(),
                        _userVariables: {},
                        _connectionValues: {}
                      };
                      this._parseNodeConnections(context);
                      for (var i = 0; i < this._staticVariables.length; i++) {
                        var variable = this._staticVariables[i];
                        context._userVariables[this.getVariableName(i)] = variable;
                      }
                      var allBlocks = this._nodes.reduce(function(acc, val) {
                        return acc.concat(val.blocks);
                      }, []);
                      return {
                        rightHanded: true,
                        allBlocks,
                        executionContexts: [context]
                      };
                    };
                    return InteractivityGraphToFlowGraphParser2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_lights: () => (
                    /* binding */
                    KHR_lights
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Lights/light */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_lights_punctual";
                var KHR_lights = (
                  /** @class */
                  function() {
                    function KHR_lights2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_lights2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._lights;
                    };
                    KHR_lights2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._lights = extension.lights;
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._lights);
                      }
                    };
                    KHR_lights2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        _this._loader._allMaterialsDirtyRequired = true;
                        return _this._loader.loadNodeAsync(context, node, function(babylonMesh) {
                          var babylonLight;
                          var light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._lights, extension.light);
                          var name2 = light.name || babylonMesh.name;
                          _this._loader.babylonScene._blockEntityCollection = !!_this._loader._assetContainer;
                          switch (light.type) {
                            case "directional": {
                              var babylonDirectionalLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(name2, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), _this._loader.babylonScene);
                              babylonDirectionalLight.position.setAll(0);
                              babylonLight = babylonDirectionalLight;
                              break;
                            }
                            case "point": {
                              babylonLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.PointLight(name2, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), _this._loader.babylonScene);
                              break;
                            }
                            case "spot": {
                              var babylonSpotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight(name2, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), 0, 1, _this._loader.babylonScene);
                              babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;
                              babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;
                              babylonLight = babylonSpotLight;
                              break;
                            }
                            default: {
                              _this._loader.babylonScene._blockEntityCollection = false;
                              throw new Error("".concat(extensionContext, ": Invalid light type (").concat(light.type, ")"));
                            }
                          }
                          babylonLight._parentContainer = _this._loader._assetContainer;
                          _this._loader.babylonScene._blockEntityCollection = false;
                          light._babylonLight = babylonLight;
                          babylonLight.falloffType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Light.FALLOFF_GLTF;
                          babylonLight.diffuse = light.color ? babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(light.color) : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                          babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
                          babylonLight.range = light.range == void 0 ? Number.MAX_VALUE : light.range;
                          babylonLight.parent = babylonMesh;
                          _this._loader._babylonLights.push(babylonLight);
                          _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);
                          assign(babylonMesh);
                        });
                      });
                    };
                    return KHR_lights2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_lights(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts": (
              /*!********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts ***!
                \********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* binding */
                    KHR_materials_anisotropy
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_anisotropy";
                var KHR_materials_anisotropy = (
                  /** @class */
                  function() {
                    function KHR_materials_anisotropy2(loader) {
                      this.name = NAME;
                      this.order = 195;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_anisotropy2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_anisotropy2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_anisotropy2.prototype._loadIridescencePropertiesAsync = function(context, properties, babylonMaterial) {
                      var _a, _b;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.anisotropy.isEnabled = true;
                      babylonMaterial.anisotropy.intensity = (_a = properties.anisotropyStrength) !== null && _a !== void 0 ? _a : 0;
                      babylonMaterial.anisotropy.angle = (_b = properties.anisotropyRotation) !== null && _b !== void 0 ? _b : 0;
                      if (properties.anisotropyTexture) {
                        properties.anisotropyTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/anisotropyTexture"), properties.anisotropyTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Anisotropy Intensity)");
                          babylonMaterial.anisotropy.texture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_anisotropy2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_anisotropy(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* binding */
                    KHR_materials_clearcoat
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_clearcoat";
                var KHR_materials_clearcoat = (
                  /** @class */
                  function() {
                    function KHR_materials_clearcoat2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_clearcoat2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_clearcoat2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_clearcoat2.prototype._loadClearCoatPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.clearCoat.isEnabled = true;
                      babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;
                      babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;
                      if (properties.clearcoatFactor != void 0) {
                        babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;
                      } else {
                        babylonMaterial.clearCoat.intensity = 0;
                      }
                      if (properties.clearcoatTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatTexture"), properties.clearcoatTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat)");
                          babylonMaterial.clearCoat.texture = texture;
                        }));
                      }
                      if (properties.clearcoatRoughnessFactor != void 0) {
                        babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;
                      } else {
                        babylonMaterial.clearCoat.roughness = 0;
                      }
                      if (properties.clearcoatRoughnessTexture) {
                        properties.clearcoatRoughnessTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatRoughnessTexture"), properties.clearcoatRoughnessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat Roughness)");
                          babylonMaterial.clearCoat.textureRoughness = texture;
                        }));
                      }
                      if (properties.clearcoatNormalTexture) {
                        properties.clearcoatNormalTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatNormalTexture"), properties.clearcoatNormalTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat Normal)");
                          babylonMaterial.clearCoat.bumpTexture = texture;
                        }));
                        babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;
                        babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;
                        if (properties.clearcoatNormalTexture.scale != void 0) {
                          babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;
                        }
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_clearcoat2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_clearcoat(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts": (
              /*!******************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts ***!
                \******************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_diffuse_transmission: () => (
                    /* binding */
                    KHR_materials_diffuse_transmission
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_diffuse_transmission";
                var KHR_materials_diffuse_transmission = (
                  /** @class */
                  function() {
                    function KHR_materials_diffuse_transmission2(loader) {
                      this.name = NAME;
                      this.order = 174;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        loader.parent.transparencyAsCoverage = true;
                      }
                    }
                    KHR_materials_diffuse_transmission2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_diffuse_transmission2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_diffuse_transmission2.prototype._loadTranslucentPropertiesAsync = function(context, material, babylonMaterial, extension) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var pbrMaterial = babylonMaterial;
                      pbrMaterial.subSurface.isTranslucencyEnabled = true;
                      pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
                      pbrMaterial.subSurface.minimumThickness = 0;
                      pbrMaterial.subSurface.maximumThickness = 0;
                      pbrMaterial.subSurface.useAlbedoToTintTranslucency = false;
                      if (extension.diffuseTransmissionFactor !== void 0) {
                        pbrMaterial.subSurface.translucencyIntensity = extension.diffuseTransmissionFactor;
                      } else {
                        pbrMaterial.subSurface.translucencyIntensity = 0;
                        pbrMaterial.subSurface.isTranslucencyEnabled = false;
                        return Promise.resolve();
                      }
                      var promises = new Array();
                      pbrMaterial.subSurface.useGltfStyleTextures = true;
                      if (extension.diffuseTransmissionTexture) {
                        extension.diffuseTransmissionTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTransmissionTexture"), extension.diffuseTransmissionTexture).then(function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Diffuse Transmission)");
                          pbrMaterial.subSurface.translucencyIntensityTexture = texture;
                        }));
                      }
                      if (extension.diffuseTransmissionColorFactor !== void 0) {
                        pbrMaterial.subSurface.translucencyColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(extension.diffuseTransmissionColorFactor);
                      } else {
                        pbrMaterial.subSurface.translucencyColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                      }
                      if (extension.diffuseTransmissionColorTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTransmissionColorTexture"), extension.diffuseTransmissionColorTexture).then(function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Diffuse Transmission Color)");
                          pbrMaterial.subSurface.translucencyColorTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_diffuse_transmission2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_diffuse_transmission(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts": (
              /*!********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts ***!
                \********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_dispersion: () => (
                    /* binding */
                    KHR_materials_dispersion
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_dispersion";
                var KHR_materials_dispersion = (
                  /** @class */
                  function() {
                    function KHR_materials_dispersion2(loader) {
                      this.name = NAME;
                      this.order = 174;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_dispersion2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_dispersion2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadDispersionPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_dispersion2.prototype._loadDispersionPropertiesAsync = function(context, material, babylonMaterial, extension) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (!babylonMaterial.subSurface.isRefractionEnabled || !extension.dispersion) {
                        return Promise.resolve();
                      }
                      babylonMaterial.subSurface.isDispersionEnabled = true;
                      babylonMaterial.subSurface.dispersion = extension.dispersion;
                      return Promise.resolve();
                    };
                    return KHR_materials_dispersion2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_dispersion(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts": (
              /*!***************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts ***!
                \***************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* binding */
                    KHR_materials_emissive_strength
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_emissive_strength";
                var KHR_materials_emissive_strength = (
                  /** @class */
                  function() {
                    function KHR_materials_emissive_strength2(loader) {
                      this.name = NAME;
                      this.order = 170;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_emissive_strength2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_emissive_strength2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        return _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(function() {
                          _this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);
                        });
                      });
                    };
                    KHR_materials_emissive_strength2.prototype._loadEmissiveProperties = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (properties.emissiveStrength !== void 0) {
                        babylonMaterial.emissiveIntensity = properties.emissiveStrength;
                      }
                    };
                    return KHR_materials_emissive_strength2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_emissive_strength(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts": (
              /*!*************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts ***!
                \*************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* binding */
                    KHR_materials_ior
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_ior";
                var KHR_materials_ior = (
                  /** @class */
                  function() {
                    function KHR_materials_ior2(loader) {
                      this.name = NAME;
                      this.order = 180;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_ior2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_ior2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_ior2.prototype._loadIorPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (properties.ior !== void 0) {
                        babylonMaterial.indexOfRefraction = properties.ior;
                      } else {
                        babylonMaterial.indexOfRefraction = KHR_materials_ior2._DEFAULT_IOR;
                      }
                      return Promise.resolve();
                    };
                    KHR_materials_ior2._DEFAULT_IOR = 1.5;
                    return KHR_materials_ior2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_ior(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts": (
              /*!*********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts ***!
                \*********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* binding */
                    KHR_materials_iridescence
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_iridescence";
                var KHR_materials_iridescence = (
                  /** @class */
                  function() {
                    function KHR_materials_iridescence2(loader) {
                      this.name = NAME;
                      this.order = 195;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_iridescence2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_iridescence2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_iridescence2.prototype._loadIridescencePropertiesAsync = function(context, properties, babylonMaterial) {
                      var _a, _b, _c, _d, _e;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.iridescence.isEnabled = true;
                      babylonMaterial.iridescence.intensity = (_a = properties.iridescenceFactor) !== null && _a !== void 0 ? _a : 0;
                      babylonMaterial.iridescence.indexOfRefraction = (_c = (_b = properties.iridescenceIor) !== null && _b !== void 0 ? _b : properties.iridescenceIOR) !== null && _c !== void 0 ? _c : 1.3;
                      babylonMaterial.iridescence.minimumThickness = (_d = properties.iridescenceThicknessMinimum) !== null && _d !== void 0 ? _d : 100;
                      babylonMaterial.iridescence.maximumThickness = (_e = properties.iridescenceThicknessMaximum) !== null && _e !== void 0 ? _e : 400;
                      if (properties.iridescenceTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceTexture"), properties.iridescenceTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Iridescence)");
                          babylonMaterial.iridescence.texture = texture;
                        }));
                      }
                      if (properties.iridescenceThicknessTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceThicknessTexture"), properties.iridescenceThicknessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Iridescence Thickness)");
                          babylonMaterial.iridescence.thicknessTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_iridescence2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_iridescence(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts": (
              /*!*******************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts ***!
                \*******************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* binding */
                    KHR_materials_pbrSpecularGlossiness
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_pbrSpecularGlossiness";
                var KHR_materials_pbrSpecularGlossiness = (
                  /** @class */
                  function() {
                    function KHR_materials_pbrSpecularGlossiness2(loader) {
                      this.name = NAME;
                      this.order = 200;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_pbrSpecularGlossiness2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_pbrSpecularGlossiness2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSpecularGlossinessPropertiesAsync(extensionContext, extension, babylonMaterial));
                        _this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_pbrSpecularGlossiness2.prototype._loadSpecularGlossinessPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.metallic = null;
                      babylonMaterial.roughness = null;
                      if (properties.diffuseFactor) {
                        babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.diffuseFactor);
                        babylonMaterial.alpha = properties.diffuseFactor[3];
                      } else {
                        babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                      }
                      babylonMaterial.reflectivityColor = properties.specularFactor ? babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularFactor) : babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                      babylonMaterial.microSurface = properties.glossinessFactor == void 0 ? 1 : properties.glossinessFactor;
                      if (properties.diffuseTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTexture"), properties.diffuseTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Diffuse)");
                          babylonMaterial.albedoTexture = texture;
                        }));
                      }
                      if (properties.specularGlossinessTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularGlossinessTexture"), properties.specularGlossinessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular Glossiness)");
                          babylonMaterial.reflectivityTexture = texture;
                          babylonMaterial.reflectivityTexture.hasAlpha = true;
                        }));
                        babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_pbrSpecularGlossiness2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_pbrSpecularGlossiness(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* binding */
                    KHR_materials_sheen
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_sheen";
                var KHR_materials_sheen = (
                  /** @class */
                  function() {
                    function KHR_materials_sheen2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_sheen2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_sheen2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_sheen2.prototype._loadSheenPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.sheen.isEnabled = true;
                      babylonMaterial.sheen.intensity = 1;
                      if (properties.sheenColorFactor != void 0) {
                        babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.sheenColorFactor);
                      } else {
                        babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.Black();
                      }
                      if (properties.sheenColorTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenColorTexture"), properties.sheenColorTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Sheen Color)");
                          babylonMaterial.sheen.texture = texture;
                        }));
                      }
                      if (properties.sheenRoughnessFactor !== void 0) {
                        babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;
                      } else {
                        babylonMaterial.sheen.roughness = 0;
                      }
                      if (properties.sheenRoughnessTexture) {
                        properties.sheenRoughnessTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenRoughnessTexture"), properties.sheenRoughnessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Sheen Roughness)");
                          babylonMaterial.sheen.textureRoughness = texture;
                        }));
                      }
                      babylonMaterial.sheen.albedoScaling = true;
                      babylonMaterial.sheen.useRoughnessFromMainTexture = false;
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_sheen2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_sheen(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* binding */
                    KHR_materials_specular
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_specular";
                var KHR_materials_specular = (
                  /** @class */
                  function() {
                    function KHR_materials_specular2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_specular2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_specular2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_specular2.prototype._loadSpecularPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      if (properties.specularFactor !== void 0) {
                        babylonMaterial.metallicF0Factor = properties.specularFactor;
                      }
                      if (properties.specularColorFactor !== void 0) {
                        babylonMaterial.metallicReflectanceColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularColorFactor);
                      }
                      if (properties.specularTexture) {
                        properties.specularTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularTexture"), properties.specularTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular)");
                          babylonMaterial.metallicReflectanceTexture = texture;
                          babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;
                        }));
                      }
                      if (properties.specularColorTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularColorTexture"), properties.specularColorTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular Color)");
                          babylonMaterial.reflectanceTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_specular2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_specular(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* binding */
                    KHR_materials_transmission
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/tools */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var TransmissionHelper = (
                  /** @class */
                  function() {
                    function TransmissionHelper2(options, scene) {
                      var _this = this;
                      this._opaqueRenderTarget = null;
                      this._opaqueMeshesCache = [];
                      this._transparentMeshesCache = [];
                      this._materialObservers = {};
                      this._options = (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, TransmissionHelper2._GetDefaultOptions()), options);
                      this._scene = scene;
                      this._scene._transmissionHelper = this;
                      this.onErrorObservable = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._scene.onDisposeObservable.addOnce(function() {
                        _this.dispose();
                      });
                      this._parseScene();
                      this._setupRenderTargets();
                    }
                    TransmissionHelper2._GetDefaultOptions = function() {
                      return {
                        renderSize: 1024,
                        samples: 4,
                        lodGenerationScale: 1,
                        lodGenerationOffset: -4,
                        renderTargetTextureType: babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.TEXTURETYPE_HALF_FLOAT,
                        generateMipmaps: true
                      };
                    };
                    TransmissionHelper2.prototype.updateOptions = function(options) {
                      var _this = this;
                      var newValues = Object.keys(options).filter(function(key) {
                        return _this._options[key] !== options[key];
                      });
                      if (!newValues.length) {
                        return;
                      }
                      var newOptions = (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this._options), options);
                      var oldOptions = this._options;
                      this._options = newOptions;
                      if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {
                        this._setupRenderTargets();
                      } else {
                        this._opaqueRenderTarget.samples = newOptions.samples;
                        this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;
                        this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;
                      }
                    };
                    TransmissionHelper2.prototype.getOpaqueTarget = function() {
                      return this._opaqueRenderTarget;
                    };
                    TransmissionHelper2.prototype._shouldRenderAsTransmission = function(material) {
                      if (!material) {
                        return false;
                      }
                      if (material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial && material.subSurface.isRefractionEnabled) {
                        return true;
                      }
                      return false;
                    };
                    TransmissionHelper2.prototype._addMesh = function(mesh) {
                      var _this = this;
                      this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));
                      babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function() {
                        if (_this._shouldRenderAsTransmission(mesh.material)) {
                          mesh.material.refractionTexture = _this._opaqueRenderTarget;
                          if (_this._transparentMeshesCache.indexOf(mesh) === -1) {
                            _this._transparentMeshesCache.push(mesh);
                          }
                        } else {
                          if (_this._opaqueMeshesCache.indexOf(mesh) === -1) {
                            _this._opaqueMeshesCache.push(mesh);
                          }
                        }
                      });
                    };
                    TransmissionHelper2.prototype._removeMesh = function(mesh) {
                      mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);
                      delete this._materialObservers[mesh.uniqueId];
                      var idx = this._transparentMeshesCache.indexOf(mesh);
                      if (idx !== -1) {
                        this._transparentMeshesCache.splice(idx, 1);
                      }
                      idx = this._opaqueMeshesCache.indexOf(mesh);
                      if (idx !== -1) {
                        this._opaqueMeshesCache.splice(idx, 1);
                      }
                    };
                    TransmissionHelper2.prototype._parseScene = function() {
                      this._scene.meshes.forEach(this._addMesh.bind(this));
                      this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
                      this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
                    };
                    TransmissionHelper2.prototype._onMeshMaterialChanged = function(mesh) {
                      var transparentIdx = this._transparentMeshesCache.indexOf(mesh);
                      var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
                      var useTransmission = this._shouldRenderAsTransmission(mesh.material);
                      if (useTransmission) {
                        if (mesh.material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial) {
                          mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;
                        }
                        if (opaqueIdx !== -1) {
                          this._opaqueMeshesCache.splice(opaqueIdx, 1);
                          this._transparentMeshesCache.push(mesh);
                        } else if (transparentIdx === -1) {
                          this._transparentMeshesCache.push(mesh);
                        }
                      } else {
                        if (transparentIdx !== -1) {
                          this._transparentMeshesCache.splice(transparentIdx, 1);
                          this._opaqueMeshesCache.push(mesh);
                        } else if (opaqueIdx === -1) {
                          this._opaqueMeshesCache.push(mesh);
                        }
                      }
                    };
                    TransmissionHelper2.prototype._isRenderTargetValid = function() {
                      var _a;
                      return ((_a = this._opaqueRenderTarget) === null || _a === void 0 ? void 0 : _a.getInternalTexture()) !== null;
                    };
                    TransmissionHelper2.prototype._setupRenderTargets = function() {
                      var _this = this;
                      var _a, _b;
                      if (this._opaqueRenderTarget) {
                        this._opaqueRenderTarget.dispose();
                      }
                      this._opaqueRenderTarget = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, void 0, this._options.renderTargetTextureType);
                      this._opaqueRenderTarget.ignoreCameraViewport = true;
                      this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
                      this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();
                      this._opaqueRenderTarget.gammaSpace = false;
                      this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;
                      this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;
                      this._opaqueRenderTarget.samples = this._options.samples;
                      this._opaqueRenderTarget.renderSprites = true;
                      this._opaqueRenderTarget.renderParticles = true;
                      this._opaqueRenderTarget.disableImageProcessing = true;
                      var saveSceneEnvIntensity;
                      this._opaqueRenderTarget.onBeforeBindObservable.add(function(opaqueRenderTarget) {
                        saveSceneEnvIntensity = _this._scene.environmentIntensity;
                        _this._scene.environmentIntensity = 1;
                        if (!_this._options.clearColor) {
                          _this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, _this._scene.getEngine().useExactSrgbConversions);
                        } else {
                          opaqueRenderTarget.clearColor.copyFrom(_this._options.clearColor);
                        }
                      });
                      this._opaqueRenderTarget.onAfterUnbindObservable.add(function() {
                        _this._scene.environmentIntensity = saveSceneEnvIntensity;
                      });
                      this._transparentMeshesCache.forEach(function(mesh) {
                        if (_this._shouldRenderAsTransmission(mesh.material)) {
                          mesh.material.refractionTexture = _this._opaqueRenderTarget;
                        }
                      });
                    };
                    TransmissionHelper2.prototype.dispose = function() {
                      this._scene._transmissionHelper = void 0;
                      if (this._opaqueRenderTarget) {
                        this._opaqueRenderTarget.dispose();
                        this._opaqueRenderTarget = null;
                      }
                      this._transparentMeshesCache = [];
                      this._opaqueMeshesCache = [];
                    };
                    return TransmissionHelper2;
                  }()
                );
                var NAME = "KHR_materials_transmission";
                var KHR_materials_transmission = (
                  /** @class */
                  function() {
                    function KHR_materials_transmission2(loader) {
                      this.name = NAME;
                      this.order = 175;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        loader.parent.transparencyAsCoverage = true;
                      }
                    }
                    KHR_materials_transmission2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_transmission2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_transmission2.prototype._loadTransparentPropertiesAsync = function(context, material, babylonMaterial, extension) {
                      var _a, _b;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var pbrMaterial = babylonMaterial;
                      pbrMaterial.subSurface.isRefractionEnabled = true;
                      pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
                      pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
                      if (extension.transmissionFactor !== void 0) {
                        pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;
                        var scene = pbrMaterial.getScene();
                        if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {
                          new TransmissionHelper({}, pbrMaterial.getScene());
                        } else if (pbrMaterial.subSurface.refractionIntensity && !((_a = scene._transmissionHelper) === null || _a === void 0 ? void 0 : _a._isRenderTargetValid())) {
                          (_b = scene._transmissionHelper) === null || _b === void 0 ? void 0 : _b._setupRenderTargets();
                        }
                      } else {
                        pbrMaterial.subSurface.refractionIntensity = 0;
                        pbrMaterial.subSurface.isRefractionEnabled = false;
                        return Promise.resolve();
                      }
                      pbrMaterial.subSurface.minimumThickness = 0;
                      pbrMaterial.subSurface.maximumThickness = 0;
                      if (extension.transmissionTexture) {
                        extension.transmissionTexture.nonColorData = true;
                        return this._loader.loadTextureInfoAsync("".concat(context, "/transmissionTexture"), extension.transmissionTexture, void 0).then(function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Transmission)");
                          pbrMaterial.subSurface.refractionIntensityTexture = texture;
                          pbrMaterial.subSurface.useGltfStyleTextures = true;
                        });
                      } else {
                        return Promise.resolve();
                      }
                    };
                    return KHR_materials_transmission2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_transmission(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* binding */
                    KHR_materials_unlit
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_unlit";
                var KHR_materials_unlit = (
                  /** @class */
                  function() {
                    function KHR_materials_unlit2(loader) {
                      this.name = NAME;
                      this.order = 210;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_unlit2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_unlit2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function() {
                        return _this._loadUnlitPropertiesAsync(context, material, babylonMaterial);
                      });
                    };
                    KHR_materials_unlit2.prototype._loadUnlitPropertiesAsync = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.unlit = true;
                      var properties = material.pbrMetallicRoughness;
                      if (properties) {
                        if (properties.baseColorFactor) {
                          babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                          babylonMaterial.alpha = properties.baseColorFactor[3];
                        } else {
                          babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                        }
                        if (properties.baseColorTexture) {
                          promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                            babylonMaterial.albedoTexture = texture;
                          }));
                        }
                      }
                      if (material.doubleSided) {
                        babylonMaterial.backFaceCulling = false;
                        babylonMaterial.twoSidedLighting = true;
                      }
                      this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_unlit2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_unlit(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* binding */
                    KHR_materials_variants
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Meshes/mesh */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__);
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_variants";
                var KHR_materials_variants = (
                  /** @class */
                  function() {
                    function KHR_materials_variants2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_variants2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_variants2.GetAvailableVariants = function(rootNode) {
                      var extensionMetadata = this._GetExtensionMetadata(rootNode);
                      if (!extensionMetadata) {
                        return [];
                      }
                      return Object.keys(extensionMetadata.variants);
                    };
                    KHR_materials_variants2.prototype.getAvailableVariants = function(rootNode) {
                      return KHR_materials_variants2.GetAvailableVariants(rootNode);
                    };
                    KHR_materials_variants2.SelectVariant = function(rootNode, variantName) {
                      var extensionMetadata = this._GetExtensionMetadata(rootNode);
                      if (!extensionMetadata) {
                        throw new Error("Cannot select variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      var select = function(variantName2) {
                        var entries = extensionMetadata.variants[variantName2];
                        if (entries) {
                          for (var _i2 = 0, entries_1 = entries; _i2 < entries_1.length; _i2++) {
                            var entry = entries_1[_i2];
                            entry.mesh.material = entry.material;
                          }
                        }
                      };
                      if (variantName instanceof Array) {
                        for (var _i = 0, variantName_1 = variantName; _i < variantName_1.length; _i++) {
                          var name_1 = variantName_1[_i];
                          select(name_1);
                        }
                      } else {
                        select(variantName);
                      }
                      extensionMetadata.lastSelected = variantName;
                    };
                    KHR_materials_variants2.prototype.selectVariant = function(rootNode, variantName) {
                      KHR_materials_variants2.SelectVariant(rootNode, variantName);
                    };
                    KHR_materials_variants2.Reset = function(rootNode) {
                      var extensionMetadata = this._GetExtensionMetadata(rootNode);
                      if (!extensionMetadata) {
                        throw new Error("Cannot reset on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      for (var _i = 0, _a = extensionMetadata.original; _i < _a.length; _i++) {
                        var entry = _a[_i];
                        entry.mesh.material = entry.material;
                      }
                      extensionMetadata.lastSelected = null;
                    };
                    KHR_materials_variants2.prototype.reset = function(rootNode) {
                      KHR_materials_variants2.Reset(rootNode);
                    };
                    KHR_materials_variants2.GetLastSelectedVariant = function(rootNode) {
                      var extensionMetadata = this._GetExtensionMetadata(rootNode);
                      if (!extensionMetadata) {
                        throw new Error("Cannot get the last selected variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      return extensionMetadata.lastSelected;
                    };
                    KHR_materials_variants2.prototype.getLastSelectedVariant = function(rootNode) {
                      return KHR_materials_variants2.GetLastSelectedVariant(rootNode);
                    };
                    KHR_materials_variants2._GetExtensionMetadata = function(rootNode) {
                      var _a, _b;
                      return ((_b = (_a = rootNode === null || rootNode === void 0 ? void 0 : rootNode._internalMetadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;
                    };
                    KHR_materials_variants2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._variants = extension.variants;
                      }
                    };
                    KHR_materials_variants2.prototype.onReady = function() {
                      var _a;
                      var rootNode = this._loader.rootBabylonMesh;
                      if (rootNode) {
                        var options = this._loader.parent.extensionOptions[NAME];
                        if (options === null || options === void 0 ? void 0 : options.defaultVariant) {
                          KHR_materials_variants2.SelectVariant(rootNode, options.defaultVariant);
                        }
                        (_a = options === null || options === void 0 ? void 0 : options.onLoaded) === null || _a === void 0 ? void 0 : _a.call(options, {
                          get variants() {
                            return KHR_materials_variants2.GetAvailableVariants(rootNode);
                          },
                          get selectedVariant() {
                            var lastSelectedVariant = KHR_materials_variants2.GetLastSelectedVariant(rootNode);
                            if (!lastSelectedVariant) {
                              return KHR_materials_variants2.GetAvailableVariants(rootNode)[0];
                            }
                            if (Array.isArray(lastSelectedVariant)) {
                              return lastSelectedVariant[0];
                            }
                            return lastSelectedVariant;
                          },
                          set selectedVariant(variantName) {
                            KHR_materials_variants2.SelectVariant(rootNode, variantName);
                          }
                        });
                      }
                    };
                    KHR_materials_variants2.prototype._loadMeshPrimitiveAsync = function(context, name2, node, mesh, primitive, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader._loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, function(babylonMesh) {
                          assign(babylonMesh);
                          if (babylonMesh instanceof babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
                            var babylonDrawMode = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader._GetDrawMode(context, primitive.mode);
                            var root_1 = _this._loader.rootBabylonMesh;
                            var metadata = root_1 ? root_1._internalMetadata = root_1._internalMetadata || {} : {};
                            var gltf = metadata.gltf = metadata.gltf || {};
                            var extensionMetadata_1 = gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} };
                            extensionMetadata_1.original.push({ mesh: babylonMesh, material: babylonMesh.material });
                            var _loop_1 = function(mappingIndex2) {
                              var mapping = extension.mappings[mappingIndex2];
                              var material = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/mappings/").concat(mappingIndex2, "/material"), _this._loader.gltf.materials, mapping.material);
                              promises.push(_this._loader._loadMaterialAsync("#/materials/".concat(mapping.material), material, babylonMesh, babylonDrawMode, function(babylonMaterial) {
                                var _loop_2 = function(mappingVariantIndex2) {
                                  var variantIndex = mapping.variants[mappingVariantIndex2];
                                  var variant = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("/extensions/".concat(NAME, "/variants/").concat(variantIndex), _this._variants, variantIndex);
                                  extensionMetadata_1.variants[variant.name] = extensionMetadata_1.variants[variant.name] || [];
                                  extensionMetadata_1.variants[variant.name].push({
                                    mesh: babylonMesh,
                                    material: babylonMaterial
                                  });
                                  babylonMesh.onClonedObservable.add(function(newOne) {
                                    var newMesh = newOne;
                                    var metadata2 = null;
                                    var newRoot = newMesh;
                                    do {
                                      newRoot = newRoot.parent;
                                      if (!newRoot) {
                                        return;
                                      }
                                      metadata2 = KHR_materials_variants2._GetExtensionMetadata(newRoot);
                                    } while (metadata2 === null);
                                    if (root_1 && metadata2 === KHR_materials_variants2._GetExtensionMetadata(root_1)) {
                                      newRoot._internalMetadata = {};
                                      for (var key in root_1._internalMetadata) {
                                        newRoot._internalMetadata[key] = root_1._internalMetadata[key];
                                      }
                                      newRoot._internalMetadata.gltf = [];
                                      for (var key in root_1._internalMetadata.gltf) {
                                        newRoot._internalMetadata.gltf[key] = root_1._internalMetadata.gltf[key];
                                      }
                                      newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };
                                      for (var _i = 0, _a = metadata2.original; _i < _a.length; _i++) {
                                        var original = _a[_i];
                                        newRoot._internalMetadata.gltf[NAME].original.push({
                                          mesh: original.mesh,
                                          material: original.material
                                        });
                                      }
                                      for (var key in metadata2.variants) {
                                        if (Object.prototype.hasOwnProperty.call(metadata2.variants, key)) {
                                          newRoot._internalMetadata.gltf[NAME].variants[key] = [];
                                          for (var _b = 0, _c = metadata2.variants[key]; _b < _c.length; _b++) {
                                            var variantEntry = _c[_b];
                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({
                                              mesh: variantEntry.mesh,
                                              material: variantEntry.material
                                            });
                                          }
                                        }
                                      }
                                      metadata2 = newRoot._internalMetadata.gltf[NAME];
                                    }
                                    for (var _d = 0, _e = metadata2.original; _d < _e.length; _d++) {
                                      var target = _e[_d];
                                      if (target.mesh === babylonMesh) {
                                        target.mesh = newMesh;
                                      }
                                    }
                                    for (var _f = 0, _g = metadata2.variants[variant.name]; _f < _g.length; _f++) {
                                      var target = _g[_f];
                                      if (target.mesh === babylonMesh) {
                                        target.mesh = newMesh;
                                      }
                                    }
                                  });
                                };
                                for (var mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {
                                  _loop_2(mappingVariantIndex);
                                }
                              }));
                            };
                            for (var mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {
                              _loop_1(mappingIndex);
                            }
                          }
                        }));
                        return Promise.all(promises).then(function(_a) {
                          var babylonMesh = _a[0];
                          return babylonMesh;
                        });
                      });
                    };
                    return KHR_materials_variants2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_variants(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts": (
              /*!****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts ***!
                \****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* binding */
                    KHR_materials_volume
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_materials_volume";
                var KHR_materials_volume = (
                  /** @class */
                  function() {
                    function KHR_materials_volume2(loader) {
                      this.name = NAME;
                      this.order = 173;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        this._loader._disableInstancedMesh++;
                      }
                    }
                    KHR_materials_volume2.prototype.dispose = function() {
                      if (this.enabled) {
                        this._loader._disableInstancedMesh--;
                      }
                      this._loader = null;
                    };
                    KHR_materials_volume2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_volume2.prototype._loadVolumePropertiesAsync = function(context, material, babylonMaterial, extension) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled || !extension.thicknessFactor) {
                        return Promise.resolve();
                      }
                      babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;
                      var attenuationDistance = extension.attenuationDistance !== void 0 ? extension.attenuationDistance : Number.MAX_VALUE;
                      babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;
                      if (extension.attenuationColor !== void 0 && extension.attenuationColor.length == 3) {
                        babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);
                      }
                      babylonMaterial.subSurface.minimumThickness = 0;
                      babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;
                      babylonMaterial.subSurface.useThicknessAsDepth = true;
                      if (extension.thicknessTexture) {
                        extension.thicknessTexture.nonColorData = true;
                        return this._loader.loadTextureInfoAsync("".concat(context, "/thicknessTexture"), extension.thicknessTexture).then(function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Thickness)");
                          babylonMaterial.subSurface.thicknessTexture = texture;
                          babylonMaterial.subSurface.useGltfStyleTextures = true;
                        });
                      } else {
                        return Promise.resolve();
                      }
                    };
                    return KHR_materials_volume2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_materials_volume(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* binding */
                    KHR_mesh_quantization
                  )
                  /* harmony export */
                });
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_mesh_quantization";
                var KHR_mesh_quantization = (
                  /** @class */
                  function() {
                    function KHR_mesh_quantization2(loader) {
                      this.name = NAME;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_mesh_quantization2.prototype.dispose = function() {
                    };
                    return KHR_mesh_quantization2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_mesh_quantization(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_node_hoverability: () => (
                    /* binding */
                    KHR_node_hoverability
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./KHR_interactivity/declarationMapper */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var NAME = "KHR_node_hoverability";
                var meshPointerOverPrefix = "targetMeshPointerOver_";
                (0, _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onHoverIn", NAME, {
                  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
                  blocks: ["FlowGraphPointerOverEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                  configuration: {
                    stopPropagation: { name: "stopPropagation" },
                    nodeIndex: {
                      name: "variable",
                      toBlock: "FlowGraphGetVariableBlock",
                      dataTransformer: function(data) {
                        return [meshPointerOverPrefix + data[0]];
                      }
                    }
                  },
                  outputs: {
                    values: {
                      hoverNodeIndex: {
                        name: "index",
                        toBlock: "FlowGraphIndexOfBlock"
                        /* FlowGraphBlockNames.IndexOf */
                      },
                      controllerIndex: { name: "pointerId" }
                    },
                    flows: {
                      out: { name: "done" }
                    }
                  },
                  interBlockConnectors: [
                    {
                      input: "targetMesh",
                      output: "value",
                      inputBlockIndex: 0,
                      outputBlockIndex: 1,
                      isVariable: true
                    },
                    {
                      input: "array",
                      output: "nodes",
                      inputBlockIndex: 2,
                      outputBlockIndex: 3,
                      isVariable: true
                    },
                    {
                      input: "object",
                      output: "meshUnderPointer",
                      inputBlockIndex: 2,
                      outputBlockIndex: 0,
                      isVariable: true
                    }
                  ],
                  extraProcessor: function(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
                    var _a, _b, _c, _d, _e, _f;
                    var serializedObject = serializedObjects[serializedObjects.length - 1];
                    serializedObject.config = serializedObject.config || {};
                    serializedObject.config.glTF = globalGLTF;
                    var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
                    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
                      throw new Error("nodeIndex not found in configuration");
                    }
                    var variableName = meshPointerOverPrefix + nodeIndex;
                    serializedObjects[1].config.variable = variableName;
                    context._userVariables[variableName] = {
                      className: "Mesh",
                      id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
                      uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId
                    };
                    return serializedObjects;
                  }
                });
                var meshPointerOutPrefix = "targetMeshPointerOut_";
                (0, _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onHoverOut", NAME, {
                  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
                  blocks: ["FlowGraphPointerOutEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                  configuration: {
                    stopPropagation: { name: "stopPropagation" },
                    nodeIndex: {
                      name: "variable",
                      toBlock: "FlowGraphGetVariableBlock",
                      dataTransformer: function(data) {
                        return [meshPointerOutPrefix + data[0]];
                      }
                    }
                  },
                  outputs: {
                    values: {
                      hoverNodeIndex: {
                        name: "index",
                        toBlock: "FlowGraphIndexOfBlock"
                        /* FlowGraphBlockNames.IndexOf */
                      },
                      controllerIndex: { name: "pointerId" }
                    },
                    flows: {
                      out: { name: "done" }
                    }
                  },
                  interBlockConnectors: [
                    {
                      input: "targetMesh",
                      output: "value",
                      inputBlockIndex: 0,
                      outputBlockIndex: 1,
                      isVariable: true
                    },
                    {
                      input: "array",
                      output: "nodes",
                      inputBlockIndex: 2,
                      outputBlockIndex: 3,
                      isVariable: true
                    },
                    {
                      input: "object",
                      output: "meshOutOfPointer",
                      inputBlockIndex: 2,
                      outputBlockIndex: 0,
                      isVariable: true
                    }
                  ],
                  extraProcessor: function(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
                    var _a, _b, _c, _d, _e, _f;
                    var serializedObject = serializedObjects[serializedObjects.length - 1];
                    serializedObject.config = serializedObject.config || {};
                    serializedObject.config.glTF = globalGLTF;
                    var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
                    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
                      throw new Error("nodeIndex not found in configuration");
                    }
                    var variableName = meshPointerOutPrefix + nodeIndex;
                    serializedObjects[1].config.variable = variableName;
                    context._userVariables[variableName] = {
                      className: "Mesh",
                      id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
                      uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId
                    };
                    return serializedObjects;
                  }
                });
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_hoverability/hoverable", {
                  get: function(node) {
                    var tn = node._babylonTransformNode;
                    if (tn && tn.pointerOverDisableMeshTesting !== void 0) {
                      return tn.pointerOverDisableMeshTesting;
                    }
                    return true;
                  },
                  set: function(value, node) {
                    var _a;
                    (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function(mesh) {
                      mesh.pointerOverDisableMeshTesting = !value;
                    });
                  },
                  getTarget: function(node) {
                    return node._babylonTransformNode;
                  },
                  getPropertyName: [function() {
                    return "pointerOverDisableMeshTesting";
                  }],
                  type: "boolean"
                });
                var KHR_node_hoverability = (
                  /** @class */
                  function() {
                    function KHR_node_hoverability2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_node_hoverability2.prototype.onReady = function() {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function() {
                        var _a;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function(_b) {
                          (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function(node) {
                            var _a2, _b2, _c;
                            if (((_a2 = node.extensions) === null || _a2 === void 0 ? void 0 : _a2.KHR_node_hoverability) && ((_b2 = node.extensions) === null || _b2 === void 0 ? void 0 : _b2.KHR_node_hoverability.hoverable) === false) {
                              (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.getChildMeshes().forEach(function(mesh) {
                                mesh.pointerOverDisableMeshTesting = true;
                              });
                            }
                          });
                          return [
                            2
                            /*return*/
                          ];
                        });
                      });
                    };
                    KHR_node_hoverability2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    return KHR_node_hoverability2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_node_hoverability(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_node_selectability: () => (
                    /* binding */
                    KHR_node_selectability
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./KHR_interactivity/declarationMapper */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var NAME = "KHR_node_selectability";
                (0, _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onSelect", NAME, {
                  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
                  blocks: ["FlowGraphMeshPickEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
                  configuration: {
                    stopPropagation: { name: "stopPropagation" },
                    nodeIndex: {
                      name: "variable",
                      toBlock: "FlowGraphGetVariableBlock",
                      dataTransformer: function(data) {
                        return ["pickedMesh_" + data[0]];
                      }
                    }
                  },
                  outputs: {
                    values: {
                      selectedNodeIndex: {
                        name: "index",
                        toBlock: "FlowGraphIndexOfBlock"
                        /* FlowGraphBlockNames.IndexOf */
                      },
                      controllerIndex: { name: "pointerId" },
                      selectionPoint: { name: "pickedPoint" },
                      selectionRayOrigin: { name: "pickOrigin" }
                    },
                    flows: {
                      out: { name: "done" }
                    }
                  },
                  interBlockConnectors: [
                    {
                      input: "asset",
                      output: "value",
                      inputBlockIndex: 0,
                      outputBlockIndex: 1,
                      isVariable: true
                    },
                    {
                      input: "array",
                      output: "nodes",
                      inputBlockIndex: 2,
                      outputBlockIndex: 3,
                      isVariable: true
                    },
                    {
                      input: "object",
                      output: "pickedMesh",
                      inputBlockIndex: 2,
                      outputBlockIndex: 0,
                      isVariable: true
                    }
                  ],
                  extraProcessor: function(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
                    var _a, _b, _c, _d, _e, _f;
                    var serializedObject = serializedObjects[serializedObjects.length - 1];
                    serializedObject.config = serializedObject.config || {};
                    serializedObject.config.glTF = globalGLTF;
                    var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
                    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
                      throw new Error("nodeIndex not found in configuration");
                    }
                    var variableName = "pickedMesh_" + nodeIndex;
                    serializedObjects[1].config.variable = variableName;
                    context._userVariables[variableName] = {
                      className: "Mesh",
                      id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
                      uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId
                    };
                    return serializedObjects;
                  }
                });
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_selectability/selectable", {
                  get: function(node) {
                    var tn = node._babylonTransformNode;
                    if (tn && tn.isPickable !== void 0) {
                      return tn.isPickable;
                    }
                    return true;
                  },
                  set: function(value, node) {
                    var _a;
                    (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function(mesh) {
                      mesh.isPickable = value;
                    });
                  },
                  getTarget: function(node) {
                    return node._babylonTransformNode;
                  },
                  getPropertyName: [function() {
                    return "isPickable";
                  }],
                  type: "boolean"
                });
                var KHR_node_selectability = (
                  /** @class */
                  function() {
                    function KHR_node_selectability2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_node_selectability2.prototype.onReady = function() {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function() {
                        var _a;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function(_b) {
                          (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function(node) {
                            var _a2, _b2, _c;
                            if (((_a2 = node.extensions) === null || _a2 === void 0 ? void 0 : _a2.KHR_node_selectability) && ((_b2 = node.extensions) === null || _b2 === void 0 ? void 0 : _b2.KHR_node_selectability.selectable) === false) {
                              (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.getChildMeshes().forEach(function(mesh) {
                                mesh.isPickable = false;
                              });
                            }
                          });
                          return [
                            2
                            /*return*/
                          ];
                        });
                      });
                    };
                    KHR_node_selectability2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    return KHR_node_selectability2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_node_selectability(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_node_visibility: () => (
                    /* binding */
                    KHR_node_visibility
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var NAME = "KHR_node_visibility";
                (0, _objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_visibility/visible", {
                  get: function(node) {
                    var tn = node._babylonTransformNode;
                    if (tn && tn.isVisible !== void 0) {
                      return tn.isVisible;
                    }
                    return true;
                  },
                  set: function(value, node) {
                    var _a, _b;
                    (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function(mesh) {
                      mesh.inheritVisibility = true;
                    });
                    if (node._babylonTransformNode) {
                      node._babylonTransformNode.isVisible = value;
                    }
                    (_b = node._primitiveBabylonMeshes) === null || _b === void 0 ? void 0 : _b.forEach(function(mesh) {
                      mesh.isVisible = value;
                    });
                  },
                  getTarget: function(node) {
                    return node._babylonTransformNode;
                  },
                  getPropertyName: [function() {
                    return "isVisible";
                  }],
                  type: "boolean"
                });
                var KHR_node_visibility = (
                  /** @class */
                  function() {
                    function KHR_node_visibility2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_node_visibility2.prototype.onReady = function() {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function() {
                        var _a;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function(_b) {
                          (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function(node) {
                            var _a2, _b2, _c, _d;
                            (_a2 = node._primitiveBabylonMeshes) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(mesh) {
                              mesh.inheritVisibility = true;
                            });
                            if ((_b2 = node.extensions) === null || _b2 === void 0 ? void 0 : _b2.KHR_node_visibility) {
                              if (((_c = node.extensions) === null || _c === void 0 ? void 0 : _c.KHR_node_visibility.visible) === false) {
                                if (node._babylonTransformNode) {
                                  node._babylonTransformNode.isVisible = false;
                                }
                                (_d = node._primitiveBabylonMeshes) === null || _d === void 0 ? void 0 : _d.forEach(function(mesh) {
                                  mesh.isVisible = false;
                                });
                              }
                            }
                          });
                          return [
                            2
                            /*return*/
                          ];
                        });
                      });
                    };
                    KHR_node_visibility2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    return KHR_node_visibility2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_node_visibility(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* binding */
                    KHR_texture_basisu
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_texture_basisu";
                var KHR_texture_basisu = (
                  /** @class */
                  function() {
                    function KHR_texture_basisu2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_texture_basisu2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_texture_basisu2.prototype._loadTextureAsync = function(context, texture, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
                        var sampler = texture.sampler == void 0 ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), _this._loader.gltf.samplers, texture.sampler);
                        var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), _this._loader.gltf.images, extension.source);
                        return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
                          assign(babylonTexture);
                        }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0, !texture._textureInfo.nonColorData);
                      });
                    };
                    return KHR_texture_basisu2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_texture_basisu(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* binding */
                    KHR_texture_transform
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/texture */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_texture_transform";
                var KHR_texture_transform = (
                  /** @class */
                  function() {
                    function KHR_texture_transform2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_texture_transform2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_texture_transform2.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, textureInfo, this.name, function(extensionContext, extension) {
                        return _this._loader.loadTextureInfoAsync(context, textureInfo, function(babylonTexture) {
                          if (!(babylonTexture instanceof babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__.Texture)) {
                            throw new Error("".concat(extensionContext, ": Texture type not supported"));
                          }
                          if (extension.offset) {
                            babylonTexture.uOffset = extension.offset[0];
                            babylonTexture.vOffset = extension.offset[1];
                          }
                          babylonTexture.uRotationCenter = 0;
                          babylonTexture.vRotationCenter = 0;
                          if (extension.rotation) {
                            babylonTexture.wAng = -extension.rotation;
                          }
                          if (extension.scale) {
                            babylonTexture.uScale = extension.scale[0];
                            babylonTexture.vScale = extension.scale[1];
                          }
                          if (extension.texCoord != void 0) {
                            babylonTexture.coordinatesIndex = extension.texCoord;
                          }
                          assign(babylonTexture);
                        });
                      });
                    };
                    return KHR_texture_transform2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_texture_transform(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts": (
              /*!***********************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts ***!
                \***********************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* binding */
                    KHR_xmp_json_ld
                  )
                  /* harmony export */
                });
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "KHR_xmp_json_ld";
                var KHR_xmp_json_ld = (
                  /** @class */
                  function() {
                    function KHR_xmp_json_ld2(loader) {
                      this.name = NAME;
                      this.order = 100;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_xmp_json_ld2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_xmp_json_ld2.prototype.onLoading = function() {
                      var _a, _b, _c;
                      if (this._loader.rootBabylonMesh === null) {
                        return;
                      }
                      var xmp_gltf = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_xmp_json_ld;
                      var xmp_node = (_c = (_b = this._loader.gltf.asset) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.KHR_xmp_json_ld;
                      if (xmp_gltf && xmp_node) {
                        var packet = +xmp_node.packet;
                        if (xmp_gltf.packets && packet < xmp_gltf.packets.length) {
                          this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};
                          this._loader.rootBabylonMesh.metadata.xmp = xmp_gltf.packets[packet];
                        }
                      }
                    };
                    return KHR_xmp_json_ld2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new KHR_xmp_json_ld(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* binding */
                    MSFT_audio_emitter
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Audio/audioSceneComponent */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "MSFT_audio_emitter";
                var MSFT_audio_emitter = (
                  /** @class */
                  function() {
                    function MSFT_audio_emitter2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_audio_emitter2.prototype.dispose = function() {
                      this._loader = null;
                      this._clips = null;
                      this._emitters = null;
                    };
                    MSFT_audio_emitter2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._clips = extension.clips;
                        this._emitters = extension.emitters;
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._clips);
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._emitters);
                      }
                    };
                    MSFT_audio_emitter2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadSceneAsync(context, scene));
                        for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                          var emitterIndex = _a[_i];
                          var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), _this._emitters, emitterIndex);
                          if (emitter.refDistance != void 0 || emitter.maxDistance != void 0 || emitter.rolloffFactor != void 0 || emitter.distanceModel != void 0 || emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                            throw new Error("".concat(extensionContext, ": Direction or Distance properties are not allowed on emitters attached to a scene"));
                          }
                          promises.push(_this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter));
                        }
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        return _this._loader.loadNodeAsync(extensionContext, node, function(babylonMesh) {
                          var _loop_1 = function(emitterIndex2) {
                            var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), _this._emitters, emitterIndex2);
                            promises.push(_this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter).then(function() {
                              for (var _i2 = 0, _a2 = emitter._babylonSounds; _i2 < _a2.length; _i2++) {
                                var sound = _a2[_i2];
                                sound.attachToMesh(babylonMesh);
                                if (emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                                  sound.setLocalDirectionToMesh(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Forward());
                                  sound.setDirectionalCone(2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle == void 0 ? Math.PI : emitter.innerAngle), 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle == void 0 ? Math.PI : emitter.outerAngle), 0);
                                }
                              }
                            }));
                          };
                          for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                            var emitterIndex = _a[_i];
                            _loop_1(emitterIndex);
                          }
                          assign(babylonMesh);
                        }).then(function(babylonMesh) {
                          return Promise.all(promises).then(function() {
                            return babylonMesh;
                          });
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype.loadAnimationAsync = function(context, animation) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, animation, this.name, function(extensionContext, extension) {
                        return _this._loader.loadAnimationAsync(context, animation).then(function(babylonAnimationGroup) {
                          var promises = new Array();
                          _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(extension.events);
                          for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {
                            var event_1 = _a[_i];
                            promises.push(_this._loadAnimationEventAsync("".concat(extensionContext, "/events/").concat(event_1.index), context, animation, event_1, babylonAnimationGroup));
                          }
                          return Promise.all(promises).then(function() {
                            return babylonAnimationGroup;
                          });
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype._loadClipAsync = function(context, clip) {
                      if (clip._objectURL) {
                        return clip._objectURL;
                      }
                      var promise;
                      if (clip.uri) {
                        promise = this._loader.loadUriAsync(context, clip, clip.uri);
                      } else {
                        var bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/bufferView"), this._loader.gltf.bufferViews, clip.bufferView);
                        promise = this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
                      }
                      clip._objectURL = promise.then(function(data) {
                        return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
                      });
                      return clip._objectURL;
                    };
                    MSFT_audio_emitter2.prototype._loadEmitterAsync = function(context, emitter) {
                      var _this = this;
                      emitter._babylonSounds = emitter._babylonSounds || [];
                      if (!emitter._babylonData) {
                        var clipPromises = new Array();
                        var name_1 = emitter.name || "emitter".concat(emitter.index);
                        var options_1 = {
                          loop: false,
                          autoplay: false,
                          volume: emitter.volume == void 0 ? 1 : emitter.volume
                        };
                        var _loop_2 = function(i2) {
                          var clipContext = "/extensions/".concat(this_1.name, "/clips");
                          var clip = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i2].clip);
                          clipPromises.push(this_1._loadClipAsync("".concat(clipContext, "/").concat(emitter.clips[i2].clip), clip).then(function(objectURL) {
                            var sound = emitter._babylonSounds[i2] = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);
                            sound.refDistance = emitter.refDistance || 1;
                            sound.maxDistance = emitter.maxDistance || 256;
                            sound.rolloffFactor = emitter.rolloffFactor || 1;
                            sound.distanceModel = emitter.distanceModel || "exponential";
                          }));
                        };
                        var this_1 = this;
                        for (var i = 0; i < emitter.clips.length; i++) {
                          _loop_2(i);
                        }
                        var promise = Promise.all(clipPromises).then(function() {
                          var weights = emitter.clips.map(function(clip) {
                            return clip.weight || 1;
                          });
                          var weightedSound = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
                          if (emitter.innerAngle) {
                            weightedSound.directionalConeInnerAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle);
                          }
                          if (emitter.outerAngle) {
                            weightedSound.directionalConeOuterAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle);
                          }
                          if (emitter.volume) {
                            weightedSound.volume = emitter.volume;
                          }
                          emitter._babylonData.sound = weightedSound;
                        });
                        emitter._babylonData = {
                          loaded: promise
                        };
                      }
                      return emitter._babylonData.loaded;
                    };
                    MSFT_audio_emitter2.prototype._getEventAction = function(context, sound, action, time, startOffset) {
                      switch (action) {
                        case "play": {
                          return function(currentFrame) {
                            var frameOffset = (startOffset || 0) + (currentFrame - time);
                            sound.play(frameOffset);
                          };
                        }
                        case "stop": {
                          return function() {
                            sound.stop();
                          };
                        }
                        case "pause": {
                          return function() {
                            sound.pause();
                          };
                        }
                        default: {
                          throw new Error("".concat(context, ": Unsupported action ").concat(action));
                        }
                      }
                    };
                    MSFT_audio_emitter2.prototype._loadAnimationEventAsync = function(context, animationContext, animation, event, babylonAnimationGroup) {
                      var _this = this;
                      if (babylonAnimationGroup.targetedAnimations.length == 0) {
                        return Promise.resolve();
                      }
                      var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
                      var emitterIndex = event.emitter;
                      var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("/extensions/".concat(this.name, "/emitters"), this._emitters, emitterIndex);
                      return this._loadEmitterAsync(context, emitter).then(function() {
                        var sound = emitter._babylonData.sound;
                        if (sound) {
                          var babylonAnimationEvent = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));
                          babylonAnimation.animation.addEvent(babylonAnimationEvent);
                          babylonAnimationGroup.onAnimationGroupEndObservable.add(function() {
                            sound.stop();
                          });
                          babylonAnimationGroup.onAnimationGroupPauseObservable.add(function() {
                            sound.pause();
                          });
                        }
                      });
                    };
                    return MSFT_audio_emitter2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new MSFT_audio_emitter(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_lod: () => (
                    /* binding */
                    MSFT_lod
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/deferred */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "MSFT_lod";
                var MSFT_lod = (
                  /** @class */
                  function() {
                    function MSFT_lod2(loader) {
                      var _a, _b;
                      this.name = NAME;
                      this.order = 100;
                      this.maxLODsToLoad = 10;
                      this.onNodeLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onMaterialLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._bufferLODs = new Array();
                      this._nodeIndexLOD = null;
                      this._nodeSignalLODs = new Array();
                      this._nodePromiseLODs = new Array();
                      this._nodeBufferLODs = new Array();
                      this._materialIndexLOD = null;
                      this._materialSignalLODs = new Array();
                      this._materialPromiseLODs = new Array();
                      this._materialBufferLODs = new Array();
                      this._loader = loader;
                      this.maxLODsToLoad = (_b = (_a = this._loader.parent.extensionOptions[NAME]) === null || _a === void 0 ? void 0 : _a.maxLODsToLoad) !== null && _b !== void 0 ? _b : this.maxLODsToLoad;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_lod2.prototype.dispose = function() {
                      this._loader = null;
                      this._nodeIndexLOD = null;
                      this._nodeSignalLODs.length = 0;
                      this._nodePromiseLODs.length = 0;
                      this._nodeBufferLODs.length = 0;
                      this._materialIndexLOD = null;
                      this._materialSignalLODs.length = 0;
                      this._materialPromiseLODs.length = 0;
                      this._materialBufferLODs.length = 0;
                      this.onMaterialLODsLoadedObservable.clear();
                      this.onNodeLODsLoadedObservable.clear();
                    };
                    MSFT_lod2.prototype.onReady = function() {
                      var _this = this;
                      var _loop_1 = function(indexLOD2) {
                        var promise = Promise.all(this_1._nodePromiseLODs[indexLOD2]).then(function() {
                          if (indexLOD2 !== 0) {
                            _this._loader.endPerformanceCounter("Node LOD ".concat(indexLOD2));
                            _this._loader.log("Loaded node LOD ".concat(indexLOD2));
                          }
                          _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD2);
                          if (indexLOD2 !== _this._nodePromiseLODs.length - 1) {
                            _this._loader.startPerformanceCounter("Node LOD ".concat(indexLOD2 + 1));
                            _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD2 + 1);
                            if (_this._nodeSignalLODs[indexLOD2]) {
                              _this._nodeSignalLODs[indexLOD2].resolve();
                            }
                          }
                        });
                        this_1._loader._completePromises.push(promise);
                      };
                      var this_1 = this;
                      for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
                        _loop_1(indexLOD);
                      }
                      var _loop_2 = function(indexLOD2) {
                        var promise = Promise.all(this_2._materialPromiseLODs[indexLOD2]).then(function() {
                          if (indexLOD2 !== 0) {
                            _this._loader.endPerformanceCounter("Material LOD ".concat(indexLOD2));
                            _this._loader.log("Loaded material LOD ".concat(indexLOD2));
                          }
                          _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD2);
                          if (indexLOD2 !== _this._materialPromiseLODs.length - 1) {
                            _this._loader.startPerformanceCounter("Material LOD ".concat(indexLOD2 + 1));
                            _this._loadBufferLOD(_this._materialBufferLODs, indexLOD2 + 1);
                            if (_this._materialSignalLODs[indexLOD2]) {
                              _this._materialSignalLODs[indexLOD2].resolve();
                            }
                          }
                        });
                        this_2._loader._completePromises.push(promise);
                      };
                      var this_2 = this;
                      for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
                        _loop_2(indexLOD);
                      }
                    };
                    MSFT_lod2.prototype.loadSceneAsync = function(context, scene) {
                      var promise = this._loader.loadSceneAsync(context, scene);
                      this._loadBufferLOD(this._bufferLODs, 0);
                      return promise;
                    };
                    MSFT_lod2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        var firstPromise;
                        var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);
                        _this._loader.logOpen("".concat(extensionContext));
                        var _loop_3 = function(indexLOD2) {
                          var nodeLOD = nodeLODs[indexLOD2];
                          if (indexLOD2 !== 0) {
                            _this._nodeIndexLOD = indexLOD2;
                            _this._nodeSignalLODs[indexLOD2] = _this._nodeSignalLODs[indexLOD2] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                          }
                          var assignWrap = function(babylonTransformNode) {
                            assign(babylonTransformNode);
                            babylonTransformNode.setEnabled(false);
                          };
                          var promise = _this._loader.loadNodeAsync("/nodes/".concat(nodeLOD.index), nodeLOD, assignWrap).then(function(babylonMesh) {
                            if (indexLOD2 !== 0) {
                              var previousNodeLOD = nodeLODs[indexLOD2 - 1];
                              if (previousNodeLOD._babylonTransformNode) {
                                _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
                                delete previousNodeLOD._babylonTransformNode;
                              }
                            }
                            babylonMesh.setEnabled(true);
                            return babylonMesh;
                          });
                          _this._nodePromiseLODs[indexLOD2] = _this._nodePromiseLODs[indexLOD2] || [];
                          if (indexLOD2 === 0) {
                            firstPromise = promise;
                          } else {
                            _this._nodeIndexLOD = null;
                            _this._nodePromiseLODs[indexLOD2].push(promise);
                          }
                        };
                        for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
                          _loop_3(indexLOD);
                        }
                        _this._loader.logClose();
                        return firstPromise;
                      });
                    };
                    MSFT_lod2.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      var _this = this;
                      if (this._nodeIndexLOD) {
                        return null;
                      }
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var firstPromise;
                        var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);
                        _this._loader.logOpen("".concat(extensionContext));
                        var _loop_4 = function(indexLOD2) {
                          var materialLOD = materialLODs[indexLOD2];
                          if (indexLOD2 !== 0) {
                            _this._materialIndexLOD = indexLOD2;
                          }
                          var promise = _this._loader._loadMaterialAsync("/materials/".concat(materialLOD.index), materialLOD, babylonMesh, babylonDrawMode, function(babylonMaterial) {
                            if (indexLOD2 === 0) {
                              assign(babylonMaterial);
                            }
                          }).then(function(babylonMaterial) {
                            if (indexLOD2 !== 0) {
                              assign(babylonMaterial);
                              var previousDataLOD = materialLODs[indexLOD2 - 1]._data;
                              if (previousDataLOD[babylonDrawMode]) {
                                _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
                                delete previousDataLOD[babylonDrawMode];
                              }
                            }
                            return babylonMaterial;
                          });
                          _this._materialPromiseLODs[indexLOD2] = _this._materialPromiseLODs[indexLOD2] || [];
                          if (indexLOD2 === 0) {
                            firstPromise = promise;
                          } else {
                            _this._materialIndexLOD = null;
                            _this._materialPromiseLODs[indexLOD2].push(promise);
                          }
                        };
                        for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
                          _loop_4(indexLOD);
                        }
                        _this._loader.logClose();
                        return firstPromise;
                      });
                    };
                    MSFT_lod2.prototype._loadUriAsync = function(context, property, uri) {
                      var _this = this;
                      if (this._nodeIndexLOD !== null) {
                        this._loader.log("deferred");
                        var previousIndexLOD = this._nodeIndexLOD - 1;
                        this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                        return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function() {
                          return _this._loader.loadUriAsync(context, property, uri);
                        });
                      } else if (this._materialIndexLOD !== null) {
                        this._loader.log("deferred");
                        var previousIndexLOD = this._materialIndexLOD - 1;
                        this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                        return this._materialSignalLODs[previousIndexLOD].promise.then(function() {
                          return _this._loader.loadUriAsync(context, property, uri);
                        });
                      }
                      return null;
                    };
                    MSFT_lod2.prototype.loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      if (this._loader.parent.useRangeRequests && !buffer.uri) {
                        if (!this._loader.bin) {
                          throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
                        }
                        var loadAsync = function(bufferLODs, indexLOD) {
                          var start = byteOffset;
                          var end = start + byteLength - 1;
                          var bufferLOD = bufferLODs[indexLOD];
                          if (bufferLOD) {
                            bufferLOD.start = Math.min(bufferLOD.start, start);
                            bufferLOD.end = Math.max(bufferLOD.end, end);
                          } else {
                            bufferLOD = { start, end, loaded: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred() };
                            bufferLODs[indexLOD] = bufferLOD;
                          }
                          return bufferLOD.loaded.promise.then(function(data) {
                            return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
                          });
                        };
                        this._loader.log("deferred");
                        if (this._nodeIndexLOD !== null) {
                          return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
                        } else if (this._materialIndexLOD !== null) {
                          return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
                        } else {
                          return loadAsync(this._bufferLODs, 0);
                        }
                      }
                      return null;
                    };
                    MSFT_lod2.prototype._loadBufferLOD = function(bufferLODs, indexLOD) {
                      var bufferLOD = bufferLODs[indexLOD];
                      if (bufferLOD) {
                        this._loader.log("Loading buffer range [".concat(bufferLOD.start, "-").concat(bufferLOD.end, "]"));
                        this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function(data) {
                          bufferLOD.loaded.resolve(data);
                        }, function(error) {
                          bufferLOD.loaded.reject(error);
                        });
                      }
                    };
                    MSFT_lod2.prototype._getLODs = function(context, property, array, ids) {
                      if (this.maxLODsToLoad <= 0) {
                        throw new Error("maxLODsToLoad must be greater than zero");
                      }
                      var properties = [];
                      for (var i = ids.length - 1; i >= 0; i--) {
                        properties.push(_glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/ids/").concat(ids[i]), array, ids[i]));
                        if (properties.length === this.maxLODsToLoad) {
                          return properties;
                        }
                      }
                      properties.push(property);
                      return properties;
                    };
                    MSFT_lod2.prototype._disposeTransformNode = function(babylonTransformNode) {
                      var _this = this;
                      var babylonMaterials = [];
                      var babylonMaterial = babylonTransformNode.material;
                      if (babylonMaterial) {
                        babylonMaterials.push(babylonMaterial);
                      }
                      for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {
                        var babylonMesh = _a[_i];
                        if (babylonMesh.material) {
                          babylonMaterials.push(babylonMesh.material);
                        }
                      }
                      babylonTransformNode.dispose();
                      var babylonMaterialsToDispose = babylonMaterials.filter(function(babylonMaterial2) {
                        return _this._loader.babylonScene.meshes.every(function(mesh) {
                          return mesh.material != babylonMaterial2;
                        });
                      });
                      this._disposeMaterials(babylonMaterialsToDispose);
                    };
                    MSFT_lod2.prototype._disposeMaterials = function(babylonMaterials) {
                      var babylonTextures = {};
                      for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {
                        var babylonMaterial = babylonMaterials_1[_i];
                        for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {
                          var babylonTexture = _b[_a];
                          babylonTextures[babylonTexture.uniqueId] = babylonTexture;
                        }
                        babylonMaterial.dispose();
                      }
                      for (var uniqueId in babylonTextures) {
                        for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {
                          var babylonMaterial = _d[_c];
                          if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
                            delete babylonTextures[uniqueId];
                          }
                        }
                      }
                      for (var uniqueId in babylonTextures) {
                        babylonTextures[uniqueId].dispose();
                      }
                    };
                    return MSFT_lod2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new MSFT_lod(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* binding */
                    MSFT_minecraftMesh
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "MSFT_minecraftMesh";
                var MSFT_minecraftMesh = (
                  /** @class */
                  function() {
                    function MSFT_minecraftMesh2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_minecraftMesh2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    MSFT_minecraftMesh2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
                        if (extra) {
                          if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                          }
                          var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                          if (babylonMaterial.needAlphaBlending()) {
                            babylonMaterial.forceDepthWrite = true;
                            babylonMaterial.separateCullingPass = true;
                          }
                          babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
                          babylonMaterial.twoSidedLighting = true;
                          return promise;
                        }
                        return null;
                      });
                    };
                    return MSFT_minecraftMesh2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new MSFT_minecraftMesh(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* binding */
                    MSFT_sRGBFactors
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var NAME = "MSFT_sRGBFactors";
                var MSFT_sRGBFactors = (
                  /** @class */
                  function() {
                    function MSFT_sRGBFactors2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_sRGBFactors2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    MSFT_sRGBFactors2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
                        if (extra) {
                          if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                          }
                          var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                          var useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;
                          if (!babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor, useExactSrgbConversions);
                          }
                          if (!babylonMaterial.reflectivityTexture) {
                            babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor, useExactSrgbConversions);
                          }
                          return promise;
                        }
                        return null;
                      });
                    };
                    return MSFT_sRGBFactors2;
                  }()
                );
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
                (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function(loader) {
                  return new MSFT_sRGBFactors(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts": (
              /*!*********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts ***!
                \*********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFPathToObjectConverter: () => (
                    /* binding */
                    GLTFPathToObjectConverter
                  ),
                  /* harmony export */
                  OptionalPathExceptionsList: () => (
                    /* binding */
                    OptionalPathExceptionsList
                  )
                  /* harmony export */
                });
                var OptionalPathExceptionsList = [
                  {
                    // get the node as object when reading an extension
                    regex: new RegExp("^/nodes/\\d+/extensions/")
                  }
                ];
                var GLTFPathToObjectConverter = (
                  /** @class */
                  function() {
                    function GLTFPathToObjectConverter2(_gltf, _infoTree) {
                      this._gltf = _gltf;
                      this._infoTree = _infoTree;
                    }
                    GLTFPathToObjectConverter2.prototype.convert = function(path) {
                      var objectTree = this._gltf;
                      var infoTree = this._infoTree;
                      var target = void 0;
                      if (!path.startsWith("/")) {
                        throw new Error("Path must start with a /");
                      }
                      var parts = path.split("/");
                      parts.shift();
                      if (parts[parts.length - 1].includes(".length")) {
                        var lastPart = parts[parts.length - 1];
                        var split = lastPart.split(".");
                        parts.pop();
                        parts.push.apply(parts, split);
                      }
                      var ignoreObjectTree = false;
                      for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                        var part = parts_1[_i];
                        var isLength = part === "length";
                        if (isLength && !infoTree.__array__) {
                          throw new Error("Path ".concat(path, " is invalid"));
                        }
                        if (infoTree.__ignoreObjectTree__) {
                          ignoreObjectTree = true;
                        }
                        if (infoTree.__array__ && !isLength) {
                          infoTree = infoTree.__array__;
                        } else {
                          infoTree = infoTree[part];
                          if (!infoTree) {
                            throw new Error("Path ".concat(path, " is invalid"));
                          }
                        }
                        if (!ignoreObjectTree) {
                          if (objectTree === void 0) {
                            var exception = OptionalPathExceptionsList.find(function(e) {
                              return e.regex.test(path);
                            });
                            if (!exception) {
                              throw new Error("Path ".concat(path, " is invalid"));
                            }
                          } else if (!isLength) {
                            objectTree = objectTree === null || objectTree === void 0 ? void 0 : objectTree[part];
                          }
                        }
                        if (infoTree.__target__ || isLength) {
                          target = objectTree;
                        }
                      }
                      return {
                        object: target,
                        info: infoTree
                      };
                    };
                    return GLTFPathToObjectConverter2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts": (
              /*!*************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/index.ts ***!
                \*************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  AddObjectAccessorToKey: () => (
                    /* reexport safe */
                    _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.AddObjectAccessorToKey
                  ),
                  /* harmony export */
                  EXT_lights_ies: () => (
                    /* reexport safe */
                    _EXT_lights_ies__WEBPACK_IMPORTED_MODULE_6__.EXT_lights_ies
                  ),
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* reexport safe */
                    _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_1__.EXT_lights_image_based
                  ),
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* reexport safe */
                    _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_2__.EXT_mesh_gpu_instancing
                  ),
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* reexport safe */
                    _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_3__.EXT_meshopt_compression
                  ),
                  /* harmony export */
                  EXT_texture_avif: () => (
                    /* reexport safe */
                    _EXT_texture_avif__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_avif
                  ),
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* reexport safe */
                    _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_4__.EXT_texture_webp
                  ),
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* reexport safe */
                    _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_36__.ExtrasAsMetadata
                  ),
                  /* harmony export */
                  FlowGraphGLTFDataProvider: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.FlowGraphGLTFDataProvider
                  ),
                  /* harmony export */
                  GetMappingForKey: () => (
                    /* reexport safe */
                    _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.GetMappingForKey
                  ),
                  /* harmony export */
                  GetPathToObjectConverter: () => (
                    /* reexport safe */
                    _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.GetPathToObjectConverter
                  ),
                  /* harmony export */
                  InteractivityGraphToFlowGraphParser: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.InteractivityGraphToFlowGraphParser
                  ),
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* reexport safe */
                    _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_27__.KHR_animation_pointer
                  ),
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* reexport safe */
                    _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_7__.KHR_draco_mesh_compression
                  ),
                  /* harmony export */
                  KHR_interactivity: () => (
                    /* reexport safe */
                    _KHR_interactivity__WEBPACK_IMPORTED_MODULE_32__.KHR_interactivity
                  ),
                  /* harmony export */
                  KHR_lights: () => (
                    /* reexport safe */
                    _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_8__.KHR_lights
                  ),
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* reexport safe */
                    _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_13__.KHR_materials_anisotropy
                  ),
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* reexport safe */
                    _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_11__.KHR_materials_clearcoat
                  ),
                  /* harmony export */
                  KHR_materials_diffuse_transmission: () => (
                    /* reexport safe */
                    _KHR_materials_diffuse_transmission__WEBPACK_IMPORTED_MODULE_20__.KHR_materials_diffuse_transmission
                  ),
                  /* harmony export */
                  KHR_materials_dispersion: () => (
                    /* reexport safe */
                    _KHR_materials_dispersion__WEBPACK_IMPORTED_MODULE_22__.KHR_materials_dispersion
                  ),
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* reexport safe */
                    _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_14__.KHR_materials_emissive_strength
                  ),
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* reexport safe */
                    _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_17__.KHR_materials_ior
                  ),
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* reexport safe */
                    _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_12__.KHR_materials_iridescence
                  ),
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* reexport safe */
                    _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_9__.KHR_materials_pbrSpecularGlossiness
                  ),
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* reexport safe */
                    _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_15__.KHR_materials_sheen
                  ),
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* reexport safe */
                    _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_16__.KHR_materials_specular
                  ),
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* reexport safe */
                    _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_19__.KHR_materials_transmission
                  ),
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* reexport safe */
                    _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_10__.KHR_materials_unlit
                  ),
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* reexport safe */
                    _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_18__.KHR_materials_variants
                  ),
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* reexport safe */
                    _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_21__.KHR_materials_volume
                  ),
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* reexport safe */
                    _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_23__.KHR_mesh_quantization
                  ),
                  /* harmony export */
                  KHR_node_hoverability: () => (
                    /* reexport safe */
                    _KHR_node_hoverability__WEBPACK_IMPORTED_MODULE_35__.KHR_node_hoverability
                  ),
                  /* harmony export */
                  KHR_node_selectability: () => (
                    /* reexport safe */
                    _KHR_node_selectability__WEBPACK_IMPORTED_MODULE_34__.KHR_node_selectability
                  ),
                  /* harmony export */
                  KHR_node_visibility: () => (
                    /* reexport safe */
                    _KHR_node_visibility__WEBPACK_IMPORTED_MODULE_33__.KHR_node_visibility
                  ),
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* reexport safe */
                    _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_24__.KHR_texture_basisu
                  ),
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* reexport safe */
                    _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_25__.KHR_texture_transform
                  ),
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* reexport safe */
                    _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_26__.KHR_xmp_json_ld
                  ),
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* reexport safe */
                    _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_28__.MSFT_audio_emitter
                  ),
                  /* harmony export */
                  MSFT_lod: () => (
                    /* reexport safe */
                    _MSFT_lod__WEBPACK_IMPORTED_MODULE_29__.MSFT_lod
                  ),
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* reexport safe */
                    _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_30__.MSFT_minecraftMesh
                  ),
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* reexport safe */
                    _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_31__.MSFT_sRGBFactors
                  ),
                  /* harmony export */
                  SetInterpolationForKey: () => (
                    /* reexport safe */
                    _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.SetInterpolationForKey
                  ),
                  /* harmony export */
                  _AddInteractivityObjectModel: () => (
                    /* reexport safe */
                    _KHR_interactivity__WEBPACK_IMPORTED_MODULE_32__._AddInteractivityObjectModel
                  ),
                  /* harmony export */
                  addNewInteractivityFlowGraphMapping: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.addNewInteractivityFlowGraphMapping
                  ),
                  /* harmony export */
                  getAllSupportedNativeNodeTypes: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.getAllSupportedNativeNodeTypes
                  ),
                  /* harmony export */
                  getMappingForDeclaration: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.getMappingForDeclaration
                  ),
                  /* harmony export */
                  getMappingForFullOperationName: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.getMappingForFullOperationName
                  ),
                  /* harmony export */
                  gltfTypeToBabylonType: () => (
                    /* reexport safe */
                    _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__.gltfTypeToBabylonType
                  )
                  /* harmony export */
                });
                var _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./EXT_lights_image_based */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts"
                );
                var _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./EXT_mesh_gpu_instancing */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts"
                );
                var _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./EXT_meshopt_compression */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts"
                );
                var _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./EXT_texture_webp */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts"
                );
                var _EXT_texture_avif__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./EXT_texture_avif */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts"
                );
                var _EXT_lights_ies__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ./EXT_lights_ies */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts"
                );
                var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ./KHR_draco_mesh_compression */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts"
                );
                var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ./KHR_lights_punctual */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"
                );
                var _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ./KHR_materials_pbrSpecularGlossiness */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts"
                );
                var _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./KHR_materials_unlit */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts"
                );
                var _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ./KHR_materials_clearcoat */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts"
                );
                var _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ./KHR_materials_iridescence */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts"
                );
                var _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ./KHR_materials_anisotropy */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts"
                );
                var _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                  /*! ./KHR_materials_emissive_strength */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts"
                );
                var _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__2(
                  /*! ./KHR_materials_sheen */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts"
                );
                var _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__2(
                  /*! ./KHR_materials_specular */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts"
                );
                var _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__2(
                  /*! ./KHR_materials_ior */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts"
                );
                var _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__2(
                  /*! ./KHR_materials_variants */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts"
                );
                var _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__2(
                  /*! ./KHR_materials_transmission */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts"
                );
                var _KHR_materials_diffuse_transmission__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__2(
                  /*! ./KHR_materials_diffuse_transmission */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts"
                );
                var _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__2(
                  /*! ./KHR_materials_volume */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts"
                );
                var _KHR_materials_dispersion__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__2(
                  /*! ./KHR_materials_dispersion */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts"
                );
                var _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__2(
                  /*! ./KHR_mesh_quantization */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts"
                );
                var _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__2(
                  /*! ./KHR_texture_basisu */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts"
                );
                var _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__2(
                  /*! ./KHR_texture_transform */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts"
                );
                var _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__2(
                  /*! ./KHR_xmp_json_ld */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts"
                );
                var _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__2(
                  /*! ./KHR_animation_pointer */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts"
                );
                var _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__2(
                  /*! ./MSFT_audio_emitter */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts"
                );
                var _MSFT_lod__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__2(
                  /*! ./MSFT_lod */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts"
                );
                var _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__2(
                  /*! ./MSFT_minecraftMesh */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts"
                );
                var _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__2(
                  /*! ./MSFT_sRGBFactors */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts"
                );
                var _KHR_interactivity__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__2(
                  /*! ./KHR_interactivity */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts"
                );
                var _KHR_node_visibility__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__2(
                  /*! ./KHR_node_visibility */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts"
                );
                var _KHR_node_selectability__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__2(
                  /*! ./KHR_node_selectability */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts"
                );
                var _KHR_node_hoverability__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__2(
                  /*! ./KHR_node_hoverability */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts"
                );
                var _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__2(
                  /*! ./ExtrasAsMetadata */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts"
                );
                var _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__2(
                  /*! ./KHR_interactivity/index */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  AddObjectAccessorToKey: () => (
                    /* binding */
                    AddObjectAccessorToKey
                  ),
                  /* harmony export */
                  GetMappingForKey: () => (
                    /* binding */
                    GetMappingForKey
                  ),
                  /* harmony export */
                  GetPathToObjectConverter: () => (
                    /* binding */
                    GetPathToObjectConverter
                  ),
                  /* harmony export */
                  SetInterpolationForKey: () => (
                    /* binding */
                    SetInterpolationForKey
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Lights/spotLight */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _gltfPathToObjectConverter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./gltfPathToObjectConverter */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts"
                );
                var nodesTree = {
                  length: {
                    type: "number",
                    get: function(nodes) {
                      return nodes.length;
                    },
                    getTarget: function(nodes) {
                      return nodes.map(function(node) {
                        return node._babylonTransformNode;
                      });
                    },
                    getPropertyName: [function() {
                      return "length";
                    }]
                  },
                  __array__: {
                    __target__: true,
                    translation: {
                      type: "Vector3",
                      get: function(node) {
                        var _a;
                        return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position;
                      },
                      set: function(value, node) {
                        var _a;
                        return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position.copyFrom(value);
                      },
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      getPropertyName: [function() {
                        return "position";
                      }]
                    },
                    rotation: {
                      type: "Quaternion",
                      get: function(node) {
                        var _a;
                        return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.rotationQuaternion;
                      },
                      set: function(value, node) {
                        var _a, _b;
                        return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.rotationQuaternion) === null || _b === void 0 ? void 0 : _b.copyFrom(value);
                      },
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      getPropertyName: [function() {
                        return "rotationQuaternion";
                      }]
                    },
                    scale: {
                      type: "Vector3",
                      get: function(node) {
                        var _a;
                        return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling;
                      },
                      set: function(value, node) {
                        var _a;
                        return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling.copyFrom(value);
                      },
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      getPropertyName: [function() {
                        return "scaling";
                      }]
                    },
                    weights: {
                      length: {
                        type: "number",
                        get: function(node) {
                          return node._numMorphTargets;
                        },
                        getTarget: function(node) {
                          return node._babylonTransformNode;
                        },
                        getPropertyName: [function() {
                          return "influence";
                        }]
                      },
                      __array__: {
                        __target__: true,
                        type: "number",
                        get: function(node, index) {
                          var _a, _b;
                          return index !== void 0 ? (_b = (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a[0].morphTargetManager) === null || _b === void 0 ? void 0 : _b.getTarget(index).influence : void 0;
                        },
                        // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
                        getTarget: function(node) {
                          return node._babylonTransformNode;
                        },
                        getPropertyName: [function() {
                          return "influence";
                        }]
                      },
                      type: "number[]",
                      get: function(node, index) {
                        return [0];
                      },
                      // TODO: get the weights correctly
                      // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      getPropertyName: [function() {
                        return "influence";
                      }]
                    },
                    // readonly!
                    matrix: {
                      type: "Matrix",
                      get: function(node) {
                        var _a, _b, _c;
                        return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose((_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling, (_b = node._babylonTransformNode) === null || _b === void 0 ? void 0 : _b.rotationQuaternion, (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.position);
                      },
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      isReadOnly: true
                    },
                    globalMatrix: {
                      type: "Matrix",
                      get: function(node) {
                        var _a, _b, _c, _d, _e, _f, _g;
                        var matrix = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.Identity();
                        var rootNode = node.parent;
                        while (rootNode && rootNode.parent) {
                          rootNode = rootNode.parent;
                        }
                        var forceUpdate = ((_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position._isDirty) || ((_c = (_b = node._babylonTransformNode) === null || _b === void 0 ? void 0 : _b.rotationQuaternion) === null || _c === void 0 ? void 0 : _c._isDirty) || ((_d = node._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.scaling._isDirty);
                        if (rootNode) {
                          var rootMatrix = (_e = rootNode._babylonTransformNode) === null || _e === void 0 ? void 0 : _e.computeWorldMatrix(true).invert();
                          if (rootMatrix) {
                            (_g = (_f = node._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.computeWorldMatrix(forceUpdate)) === null || _g === void 0 ? void 0 : _g.multiplyToRef(rootMatrix, matrix);
                          }
                        } else if (node._babylonTransformNode) {
                          matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));
                        }
                        return matrix;
                      },
                      getTarget: function(node) {
                        return node._babylonTransformNode;
                      },
                      isReadOnly: true
                    },
                    extensions: {
                      EXT_lights_ies: {
                        multiplier: {
                          type: "number",
                          get: function(node) {
                            var _a, _b;
                            return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function(child) {
                              return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                            }, true)[0]) === null || _b === void 0 ? void 0 : _b.intensity;
                          },
                          getTarget: function(node) {
                            var _a;
                            return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function(child) {
                              return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                            }, true)[0];
                          },
                          set: function(value, node) {
                            if (node._babylonTransformNode) {
                              var light = node._babylonTransformNode.getChildren(function(child) {
                                return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                              }, true)[0];
                              if (light) {
                                light.intensity = value;
                              }
                            }
                          }
                        },
                        color: {
                          type: "Color3",
                          get: function(node) {
                            var _a, _b;
                            return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function(child) {
                              return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                            }, true)[0]) === null || _b === void 0 ? void 0 : _b.diffuse;
                          },
                          getTarget: function(node) {
                            var _a;
                            return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function(child) {
                              return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                            }, true)[0];
                          },
                          set: function(value, node) {
                            if (node._babylonTransformNode) {
                              var light = node._babylonTransformNode.getChildren(function(child) {
                                return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight;
                              }, true)[0];
                              if (light) {
                                light.diffuse = value;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                };
                var animationsTree = {
                  length: {
                    type: "number",
                    get: function(animations) {
                      return animations.length;
                    },
                    getTarget: function(animations) {
                      return animations.map(function(animation) {
                        return animation._babylonAnimationGroup;
                      });
                    },
                    getPropertyName: [function() {
                      return "length";
                    }]
                  },
                  __array__: {}
                };
                var meshesTree = {
                  length: {
                    type: "number",
                    get: function(meshes) {
                      return meshes.length;
                    },
                    getTarget: function(meshes) {
                      return meshes.map(function(mesh) {
                        var _a;
                        return (_a = mesh.primitives[0]._instanceData) === null || _a === void 0 ? void 0 : _a.babylonSourceMesh;
                      });
                    },
                    getPropertyName: [function() {
                      return "length";
                    }]
                  },
                  __array__: {}
                };
                var camerasTree = {
                  __array__: {
                    __target__: true,
                    orthographic: {
                      xmag: {
                        componentsCount: 2,
                        type: "Vector2",
                        get: function(camera) {
                          var _a, _b, _c, _d;
                          return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2((_b = (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.orthoLeft) !== null && _b !== void 0 ? _b : 0, (_d = (_c = camera._babylonCamera) === null || _c === void 0 ? void 0 : _c.orthoRight) !== null && _d !== void 0 ? _d : 0);
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.orthoLeft = value.x;
                            camera._babylonCamera.orthoRight = value.y;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "orthoLeft";
                        }, function() {
                          return "orthoRight";
                        }]
                      },
                      ymag: {
                        componentsCount: 2,
                        type: "Vector2",
                        get: function(camera) {
                          var _a, _b, _c, _d;
                          return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2((_b = (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.orthoBottom) !== null && _b !== void 0 ? _b : 0, (_d = (_c = camera._babylonCamera) === null || _c === void 0 ? void 0 : _c.orthoTop) !== null && _d !== void 0 ? _d : 0);
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.orthoBottom = value.x;
                            camera._babylonCamera.orthoTop = value.y;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "orthoBottom";
                        }, function() {
                          return "orthoTop";
                        }]
                      },
                      zfar: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.maxZ;
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.maxZ = value;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "maxZ";
                        }]
                      },
                      znear: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.minZ;
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.minZ = value;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "minZ";
                        }]
                      }
                    },
                    perspective: {
                      aspectRatio: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.getEngine().getAspectRatio(camera._babylonCamera);
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "aspectRatio";
                        }],
                        isReadOnly: true
                        // might not be the case for glTF?
                      },
                      yfov: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.fov;
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.fov = value;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "fov";
                        }]
                      },
                      zfar: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.maxZ;
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.maxZ = value;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "maxZ";
                        }]
                      },
                      znear: {
                        type: "number",
                        get: function(camera) {
                          var _a;
                          return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.minZ;
                        },
                        set: function(value, camera) {
                          if (camera._babylonCamera) {
                            camera._babylonCamera.minZ = value;
                          }
                        },
                        getTarget: function(camera) {
                          return camera;
                        },
                        getPropertyName: [function() {
                          return "minZ";
                        }]
                      }
                    }
                  }
                };
                var materialsTree = {
                  __array__: {
                    __target__: true,
                    emissiveFactor: {
                      type: "Color3",
                      get: function(material, index, payload) {
                        return _GetMaterial(material, index, payload).emissiveColor;
                      },
                      set: function(value, material, index, payload) {
                        return _GetMaterial(material, index, payload).emissiveColor.copyFrom(value);
                      },
                      getTarget: function(material, index, payload) {
                        return _GetMaterial(material, index, payload);
                      },
                      getPropertyName: [function() {
                        return "emissiveColor";
                      }]
                    },
                    emissiveTexture: {
                      extensions: {
                        KHR_texture_transform: _GenerateTextureMap("emissiveTexture")
                      }
                    },
                    normalTexture: {
                      scale: {
                        type: "number",
                        get: function(material, index, payload) {
                          var _a;
                          return (_a = _GetTexture(material, payload, "bumpTexture")) === null || _a === void 0 ? void 0 : _a.level;
                        },
                        set: function(value, material, index, payload) {
                          var texture = _GetTexture(material, payload, "bumpTexture");
                          if (texture) {
                            texture.level = value;
                          }
                        },
                        getTarget: function(material, index, payload) {
                          return _GetMaterial(material, index, payload);
                        },
                        getPropertyName: [function() {
                          return "level";
                        }]
                      },
                      extensions: {
                        KHR_texture_transform: _GenerateTextureMap("bumpTexture")
                      }
                    },
                    occlusionTexture: {
                      strength: {
                        type: "number",
                        get: function(material, index, payload) {
                          return _GetMaterial(material, index, payload).ambientTextureStrength;
                        },
                        set: function(value, material, index, payload) {
                          var mat = _GetMaterial(material, index, payload);
                          if (mat) {
                            mat.ambientTextureStrength = value;
                          }
                        },
                        getTarget: function(material, index, payload) {
                          return _GetMaterial(material, index, payload);
                        },
                        getPropertyName: [function() {
                          return "ambientTextureStrength";
                        }]
                      },
                      extensions: {
                        KHR_texture_transform: _GenerateTextureMap("ambientTexture")
                      }
                    },
                    pbrMetallicRoughness: {
                      baseColorFactor: {
                        type: "Color4",
                        get: function(material, index, payload) {
                          var mat = _GetMaterial(material, index, payload);
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color4.FromColor3(mat.albedoColor, mat.alpha);
                        },
                        set: function(value, material, index, payload) {
                          var mat = _GetMaterial(material, index, payload);
                          mat.albedoColor.set(value.r, value.g, value.b);
                          mat.alpha = value.a;
                        },
                        getTarget: function(material, index, payload) {
                          return _GetMaterial(material, index, payload);
                        },
                        // This is correct on the animation level, but incorrect as a single property of a type Color4
                        getPropertyName: [function() {
                          return "albedoColor";
                        }, function() {
                          return "alpha";
                        }]
                      },
                      baseColorTexture: {
                        extensions: {
                          KHR_texture_transform: _GenerateTextureMap("albedoTexture")
                        }
                      },
                      metallicFactor: {
                        type: "number",
                        get: function(material, index, payload) {
                          return _GetMaterial(material, index, payload).metallic;
                        },
                        set: function(value, material, index, payload) {
                          var mat = _GetMaterial(material, index, payload);
                          if (mat) {
                            mat.metallic = value;
                          }
                        },
                        getTarget: function(material, index, payload) {
                          return _GetMaterial(material, index, payload);
                        },
                        getPropertyName: [function() {
                          return "metallic";
                        }]
                      },
                      roughnessFactor: {
                        type: "number",
                        get: function(material, index, payload) {
                          return _GetMaterial(material, index, payload).roughness;
                        },
                        set: function(value, material, index, payload) {
                          var mat = _GetMaterial(material, index, payload);
                          if (mat) {
                            mat.roughness = value;
                          }
                        },
                        getTarget: function(material, index, payload) {
                          return _GetMaterial(material, index, payload);
                        },
                        getPropertyName: [function() {
                          return "roughness";
                        }]
                      },
                      metallicRoughnessTexture: {
                        extensions: {
                          KHR_texture_transform: _GenerateTextureMap("metallicTexture")
                        }
                      }
                    },
                    extensions: {
                      KHR_materials_anisotropy: {
                        anisotropyStrength: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).anisotropy.intensity;
                          },
                          set: function(value, material, index, payload) {
                            _GetMaterial(material, index, payload).anisotropy.intensity = value;
                          },
                          getTarget: function(material, index, payload) {
                            return _GetMaterial(material, index, payload);
                          },
                          getPropertyName: [function() {
                            return "anisotropy.intensity";
                          }]
                        },
                        anisotropyRotation: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).anisotropy.angle;
                          },
                          set: function(value, material, index, payload) {
                            _GetMaterial(material, index, payload).anisotropy.angle = value;
                          },
                          getTarget: function(material, index, payload) {
                            return _GetMaterial(material, index, payload);
                          },
                          getPropertyName: [function() {
                            return "anisotropy.angle";
                          }]
                        },
                        anisotropyTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("anisotropy", "texture")
                          }
                        }
                      },
                      KHR_materials_clearcoat: {
                        clearcoatFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).clearCoat.intensity;
                          },
                          set: function(value, material, index, payload) {
                            _GetMaterial(material, index, payload).clearCoat.intensity = value;
                          },
                          getTarget: function(material, index, payload) {
                            return _GetMaterial(material, index, payload);
                          },
                          getPropertyName: [function() {
                            return "clearCoat.intensity";
                          }]
                        },
                        clearcoatRoughnessFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).clearCoat.roughness;
                          },
                          set: function(value, material, index, payload) {
                            _GetMaterial(material, index, payload).clearCoat.roughness = value;
                          },
                          getTarget: function(material, index, payload) {
                            return _GetMaterial(material, index, payload);
                          },
                          getPropertyName: [function() {
                            return "clearCoat.roughness";
                          }]
                        },
                        clearcoatTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("clearCoat", "texture")
                          }
                        },
                        clearcoatNormalTexture: {
                          scale: {
                            type: "number",
                            get: function(material, index, payload) {
                              var _a;
                              return (_a = _GetMaterial(material, index, payload).clearCoat.bumpTexture) === null || _a === void 0 ? void 0 : _a.level;
                            },
                            getTarget: _GetMaterial,
                            set: function(value, material, index, payload) {
                              return _GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value;
                            }
                          },
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("clearCoat", "bumpTexture")
                          }
                        },
                        clearcoatRoughnessTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("clearCoat", "textureRoughness")
                          }
                        }
                      },
                      KHR_materials_dispersion: {
                        dispersion: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.dispersion;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.dispersion = value;
                          }
                        }
                      },
                      KHR_materials_emissive_strength: {
                        emissiveStrength: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).emissiveIntensity;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).emissiveIntensity = value;
                          }
                        }
                      },
                      KHR_materials_ior: {
                        ior: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).indexOfRefraction;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).indexOfRefraction = value;
                          }
                        }
                      },
                      KHR_materials_iridescence: {
                        iridescenceFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.intensity;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.intensity = value;
                          }
                        },
                        iridescenceIor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.indexOfRefraction;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.indexOfRefraction = value;
                          }
                        },
                        iridescenceTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("iridescence", "texture")
                          }
                        },
                        iridescenceThicknessMaximum: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.maximumThickness;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.maximumThickness = value;
                          }
                        },
                        iridescenceThicknessMinimum: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.minimumThickness;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).iridescence.minimumThickness = value;
                          }
                        },
                        iridescenceThicknessTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("iridescence", "thicknessTexture")
                          }
                        }
                      },
                      KHR_materials_sheen: {
                        sheenColorFactor: {
                          type: "Color3",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).sheen.color;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).sheen.color.copyFrom(value);
                          }
                        },
                        sheenColorTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("sheen", "texture")
                          }
                        },
                        sheenRoughnessFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).sheen.intensity;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).sheen.intensity = value;
                          }
                        },
                        sheenRoughnessTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("sheen", "thicknessTexture")
                          }
                        }
                      },
                      KHR_materials_specular: {
                        specularFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).metallicF0Factor;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).metallicF0Factor = value;
                          },
                          getPropertyName: [function() {
                            return "metallicF0Factor";
                          }]
                        },
                        specularColorFactor: {
                          type: "Color3",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).metallicReflectanceColor;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value);
                          },
                          getPropertyName: [function() {
                            return "metallicReflectanceColor";
                          }]
                        },
                        specularTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("metallicReflectanceTexture")
                          }
                        },
                        specularColorTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("reflectanceTexture")
                          }
                        }
                      },
                      KHR_materials_transmission: {
                        transmissionFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.refractionIntensity;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.refractionIntensity = value;
                          },
                          getPropertyName: [function() {
                            return "subSurface.refractionIntensity";
                          }]
                        },
                        transmissionTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("subSurface", "refractionIntensityTexture")
                          }
                        }
                      },
                      KHR_materials_diffuse_transmission: {
                        diffuseTransmissionFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.translucencyIntensity;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.translucencyIntensity = value;
                          }
                        },
                        diffuseTransmissionTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("subSurface", "translucencyIntensityTexture")
                          }
                        },
                        diffuseTransmissionColorFactor: {
                          type: "Color3",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.translucencyColor;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            var _a;
                            return value && ((_a = _GetMaterial(material, index, payload).subSurface.translucencyColor) === null || _a === void 0 ? void 0 : _a.copyFrom(value));
                          }
                        },
                        diffuseTransmissionColorTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("subSurface", "translucencyColorTexture")
                          }
                        }
                      },
                      KHR_materials_volume: {
                        attenuationColor: {
                          type: "Color3",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.tintColor;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value);
                          }
                        },
                        attenuationDistance: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.tintColorAtDistance;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value;
                          }
                        },
                        thicknessFactor: {
                          type: "number",
                          get: function(material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.maximumThickness;
                          },
                          getTarget: _GetMaterial,
                          set: function(value, material, index, payload) {
                            return _GetMaterial(material, index, payload).subSurface.maximumThickness = value;
                          }
                        },
                        thicknessTexture: {
                          extensions: {
                            KHR_texture_transform: _GenerateTextureMap("subSurface", "thicknessTexture")
                          }
                        }
                      }
                    }
                  }
                };
                var extensionsTree = {
                  KHR_lights_punctual: {
                    lights: {
                      length: {
                        type: "number",
                        get: function(lights) {
                          return lights.length;
                        },
                        getTarget: function(lights) {
                          return lights.map(function(light) {
                            return light._babylonLight;
                          });
                        },
                        getPropertyName: [function(_lights) {
                          return "length";
                        }]
                      },
                      __array__: {
                        __target__: true,
                        color: {
                          type: "Color3",
                          get: function(light) {
                            var _a;
                            return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.diffuse;
                          },
                          set: function(value, light) {
                            var _a;
                            return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.diffuse.copyFrom(value);
                          },
                          getTarget: function(light) {
                            return light._babylonLight;
                          },
                          getPropertyName: [function(_light) {
                            return "diffuse";
                          }]
                        },
                        intensity: {
                          type: "number",
                          get: function(light) {
                            var _a;
                            return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.intensity;
                          },
                          set: function(value, light) {
                            return light._babylonLight ? light._babylonLight.intensity = value : void 0;
                          },
                          getTarget: function(light) {
                            return light._babylonLight;
                          },
                          getPropertyName: [function(_light) {
                            return "intensity";
                          }]
                        },
                        range: {
                          type: "number",
                          get: function(light) {
                            var _a;
                            return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.range;
                          },
                          set: function(value, light) {
                            return light._babylonLight ? light._babylonLight.range = value : void 0;
                          },
                          getTarget: function(light) {
                            return light._babylonLight;
                          },
                          getPropertyName: [function(_light) {
                            return "range";
                          }]
                        },
                        spot: {
                          innerConeAngle: {
                            type: "number",
                            get: function(light) {
                              var _a;
                              return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.innerAngle;
                            },
                            set: function(value, light) {
                              return light._babylonLight ? light._babylonLight.innerAngle = value : void 0;
                            },
                            getTarget: function(light) {
                              return light._babylonLight;
                            },
                            getPropertyName: [function(_light) {
                              return "innerConeAngle";
                            }]
                          },
                          outerConeAngle: {
                            type: "number",
                            get: function(light) {
                              var _a;
                              return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.angle;
                            },
                            set: function(value, light) {
                              return light._babylonLight ? light._babylonLight.angle = value : void 0;
                            },
                            getTarget: function(light) {
                              return light._babylonLight;
                            },
                            getPropertyName: [function(_light) {
                              return "outerConeAngle";
                            }]
                          }
                        }
                      }
                    }
                  },
                  EXT_lights_ies: {
                    lights: {
                      length: {
                        type: "number",
                        get: function(lights) {
                          return lights.length;
                        },
                        getTarget: function(lights) {
                          return lights.map(function(light) {
                            return light._babylonLight;
                          });
                        },
                        getPropertyName: [function(_lights) {
                          return "length";
                        }]
                      }
                    }
                  },
                  EXT_lights_image_based: {
                    lights: {
                      length: {
                        type: "number",
                        get: function(lights) {
                          return lights.length;
                        },
                        getTarget: function(lights) {
                          return lights.map(function(light) {
                            return light._babylonTexture;
                          });
                        },
                        getPropertyName: [function(_lights) {
                          return "length";
                        }]
                      },
                      __array__: {
                        __target__: true,
                        intensity: {
                          type: "number",
                          get: function(light) {
                            var _a;
                            return (_a = light._babylonTexture) === null || _a === void 0 ? void 0 : _a.level;
                          },
                          set: function(value, light) {
                            if (light._babylonTexture)
                              light._babylonTexture.level = value;
                          },
                          getTarget: function(light) {
                            return light._babylonTexture;
                          }
                        },
                        rotation: {
                          type: "Quaternion",
                          get: function(light) {
                            var _a;
                            return light._babylonTexture && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromRotationMatrix((_a = light._babylonTexture) === null || _a === void 0 ? void 0 : _a.getReflectionTextureMatrix());
                          },
                          set: function(value, light) {
                            var _a;
                            if (!light._babylonTexture)
                              return;
                            if (!((_a = light._babylonTexture.getScene()) === null || _a === void 0 ? void 0 : _a.useRightHandedSystem)) {
                              value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Inverse(value);
                            }
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());
                          },
                          getTarget: function(light) {
                            return light._babylonTexture;
                          }
                        }
                      }
                    }
                  }
                };
                function _GetTexture(material, payload, textureType, textureInObject) {
                  var babylonMaterial = _GetMaterial(material, payload);
                  return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];
                }
                function _GetMaterial(material, _index, payload) {
                  var _a, _b, _c;
                  return (_c = (_a = material._data) === null || _a === void 0 ? void 0 : _a[(_b = payload === null || payload === void 0 ? void 0 : payload.fillMode) !== null && _b !== void 0 ? _b : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Constants.MATERIAL_TriangleFillMode]) === null || _c === void 0 ? void 0 : _c.babylonMaterial;
                }
                function _GenerateTextureMap(textureType, textureInObject) {
                  return {
                    offset: {
                      componentsCount: 2,
                      // assuming two independent values for u and v, and NOT a Vector2
                      type: "Vector2",
                      get: function(material, _index, payload) {
                        var texture = _GetTexture(material, payload, textureType, textureInObject);
                        return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(texture === null || texture === void 0 ? void 0 : texture.uOffset, texture === null || texture === void 0 ? void 0 : texture.vOffset);
                      },
                      getTarget: _GetMaterial,
                      set: function(value, material, _index, payload) {
                        var texture = _GetTexture(material, payload, textureType, textureInObject);
                        texture.uOffset = value.x, texture.vOffset = value.y;
                      },
                      getPropertyName: [
                        function() {
                          return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".uOffset");
                        },
                        function() {
                          return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".vOffset");
                        }
                      ]
                    },
                    rotation: {
                      type: "number",
                      get: function(material, _index, payload) {
                        var _a;
                        return (_a = _GetTexture(material, payload, textureType, textureInObject)) === null || _a === void 0 ? void 0 : _a.wAng;
                      },
                      getTarget: _GetMaterial,
                      set: function(value, material, _index, payload) {
                        return _GetTexture(material, payload, textureType, textureInObject).wAng = value;
                      },
                      getPropertyName: [function() {
                        return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".wAng");
                      }]
                    },
                    scale: {
                      componentsCount: 2,
                      type: "Vector2",
                      get: function(material, _index, payload) {
                        var texture = _GetTexture(material, payload, textureType, textureInObject);
                        return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(texture === null || texture === void 0 ? void 0 : texture.uScale, texture === null || texture === void 0 ? void 0 : texture.vScale);
                      },
                      getTarget: _GetMaterial,
                      set: function(value, material, index, payload) {
                        var texture = _GetTexture(material, payload, textureType, textureInObject);
                        texture.uScale = value.x, texture.vScale = value.y;
                      },
                      getPropertyName: [
                        function() {
                          return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".uScale");
                        },
                        function() {
                          return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".vScale");
                        }
                      ]
                    }
                  };
                }
                var objectModelMapping = {
                  cameras: camerasTree,
                  nodes: nodesTree,
                  materials: materialsTree,
                  extensions: extensionsTree,
                  animations: animationsTree,
                  meshes: meshesTree
                };
                function GetPathToObjectConverter(gltf) {
                  return new _gltfPathToObjectConverter__WEBPACK_IMPORTED_MODULE_1__.GLTFPathToObjectConverter(gltf, objectModelMapping);
                }
                function GetMappingForKey(key) {
                  var keyParts = key.split("/").map(function(part2) {
                    return part2.replace(/{}/g, "__array__");
                  });
                  var current = objectModelMapping;
                  for (var _i = 0, keyParts_1 = keyParts; _i < keyParts_1.length; _i++) {
                    var part = keyParts_1[_i];
                    if (!part) {
                      continue;
                    }
                    current = current[part];
                  }
                  if (current && current.type && current.get) {
                    return current;
                  }
                  return void 0;
                }
                function SetInterpolationForKey(key, interpolation) {
                  var keyParts = key.split("/").map(function(part2) {
                    return part2.replace(/{}/g, "__array__");
                  });
                  var current = objectModelMapping;
                  for (var _i = 0, keyParts_2 = keyParts; _i < keyParts_2.length; _i++) {
                    var part = keyParts_2[_i];
                    if (!part) {
                      continue;
                    }
                    current = current[part];
                  }
                  if (current && current.type && current.get) {
                    current.interpolation = interpolation;
                  }
                }
                function AddObjectAccessorToKey(key, accessor) {
                  var keyParts = key.split("/").map(function(part2) {
                    return part2.replace(/{}/g, "__array__");
                  });
                  var current = objectModelMapping;
                  for (var _i = 0, keyParts_3 = keyParts; _i < keyParts_3.length; _i++) {
                    var part = keyParts_3[_i];
                    if (!part) {
                      continue;
                    }
                    if (!current[part]) {
                      if (part === "?") {
                        current.__ignoreObjectTree__ = true;
                        continue;
                      }
                      current[part] = {};
                      if (part === "__array__") {
                        current[part].__target__ = true;
                      }
                    }
                    current = current[part];
                  }
                  Object.assign(current, accessor);
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ArrayItem: () => (
                    /* binding */
                    ArrayItem
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* binding */
                    GLTFLoader
                  ),
                  /* harmony export */
                  LoadBoundingInfoFromPositionAccessor: () => (
                    /* binding */
                    LoadBoundingInfoFromPositionAccessor
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Buffers/bufferUtils */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./Extensions/objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                var ArrayItem = (
                  /** @class */
                  function() {
                    function ArrayItem2() {
                    }
                    ArrayItem2.Get = function(context, array, index) {
                      if (!array || index == void 0 || !array[index]) {
                        throw new Error("".concat(context, ": Failed to find index (").concat(index, ")"));
                      }
                      return array[index];
                    };
                    ArrayItem2.TryGet = function(array, index) {
                      if (!array || index == void 0 || !array[index]) {
                        return null;
                      }
                      return array[index];
                    };
                    ArrayItem2.Assign = function(array) {
                      if (array) {
                        for (var index = 0; index < array.length; index++) {
                          array[index].index = index;
                        }
                      }
                    };
                    return ArrayItem2;
                  }()
                );
                function LoadBoundingInfoFromPositionAccessor(accessor) {
                  if (accessor.min && accessor.max) {
                    var minArray = accessor.min;
                    var maxArray = accessor.max;
                    var minVector = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);
                    var maxVector = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);
                    if (accessor.normalized && accessor.componentType !== 5126) {
                      var divider = 1;
                      switch (accessor.componentType) {
                        case 5120:
                          divider = 127;
                          break;
                        case 5121:
                          divider = 255;
                          break;
                        case 5122:
                          divider = 32767;
                          break;
                        case 5123:
                          divider = 65535;
                          break;
                      }
                      var oneOverDivider = 1 / divider;
                      minVector.scaleInPlace(oneOverDivider);
                      maxVector.scaleInPlace(oneOverDivider);
                    }
                    return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.BoundingInfo(minVector, maxVector);
                  }
                  return null;
                }
                var GLTFLoader = (
                  /** @class */
                  function() {
                    function GLTFLoader2(parent) {
                      this._completePromises = new Array();
                      this._assetContainer = null;
                      this._babylonLights = [];
                      this._disableInstancedMesh = 0;
                      this._allMaterialsDirtyRequired = false;
                      this._skipStartAnimationStep = false;
                      this._extensions = new Array();
                      this._disposed = false;
                      this._rootUrl = null;
                      this._fileName = null;
                      this._uniqueRootUrl = null;
                      this._bin = null;
                      this._rootBabylonMesh = null;
                      this._defaultBabylonMaterialData = {};
                      this._postSceneLoadActions = new Array();
                      this._parent = parent;
                    }
                    GLTFLoader2.RegisterExtension = function(name2, factory) {
                      (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(name2, false, factory);
                    };
                    GLTFLoader2.UnregisterExtension = function(name2) {
                      return (0, _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(name2);
                    };
                    Object.defineProperty(GLTFLoader2.prototype, "gltf", {
                      /**
                       * The object that represents the glTF JSON.
                       */
                      get: function() {
                        if (!this._gltf) {
                          throw new Error("glTF JSON is not available");
                        }
                        return this._gltf;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "bin", {
                      /**
                       * The BIN chunk of a binary glTF.
                       */
                      get: function() {
                        return this._bin;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "parent", {
                      /**
                       * The parent file loader.
                       */
                      get: function() {
                        return this._parent;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "babylonScene", {
                      /**
                       * The Babylon scene when loading the asset.
                       */
                      get: function() {
                        if (!this._babylonScene) {
                          throw new Error("Scene is not available");
                        }
                        return this._babylonScene;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "rootBabylonMesh", {
                      /**
                       * The root Babylon node when loading the asset.
                       */
                      get: function() {
                        return this._rootBabylonMesh;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "rootUrl", {
                      /**
                       * The root url when loading the asset.
                       */
                      get: function() {
                        return this._rootUrl;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFLoader2.prototype.dispose = function() {
                      if (this._disposed) {
                        return;
                      }
                      this._disposed = true;
                      this._completePromises.length = 0;
                      this._extensions.forEach(function(extension) {
                        return extension.dispose && extension.dispose();
                      });
                      this._extensions.length = 0;
                      this._gltf = null;
                      this._bin = null;
                      this._babylonScene = null;
                      this._rootBabylonMesh = null;
                      this._defaultBabylonMaterialData = {};
                      this._postSceneLoadActions.length = 0;
                      this._parent.dispose();
                    };
                    GLTFLoader2.prototype.importMeshAsync = function(meshesNames, scene, container, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      return Promise.resolve().then(function() {
                        _this._babylonScene = scene;
                        _this._assetContainer = container;
                        _this._loadData(data);
                        var nodes = null;
                        if (meshesNames) {
                          var nodeMap_1 = {};
                          if (_this._gltf.nodes) {
                            for (var _i = 0, _a = _this._gltf.nodes; _i < _a.length; _i++) {
                              var node = _a[_i];
                              if (node.name) {
                                nodeMap_1[node.name] = node.index;
                              }
                            }
                          }
                          var names = meshesNames instanceof Array ? meshesNames : [meshesNames];
                          nodes = names.map(function(name2) {
                            var node2 = nodeMap_1[name2];
                            if (node2 === void 0) {
                              throw new Error("Failed to find node '".concat(name2, "'"));
                            }
                            return node2;
                          });
                        }
                        return _this._loadAsync(rootUrl, fileName, nodes, function() {
                          return {
                            meshes: _this._getMeshes(),
                            particleSystems: [],
                            skeletons: _this._getSkeletons(),
                            animationGroups: _this._getAnimationGroups(),
                            lights: _this._babylonLights,
                            transformNodes: _this._getTransformNodes(),
                            geometries: _this._getGeometries(),
                            spriteManagers: []
                          };
                        });
                      });
                    };
                    GLTFLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      return Promise.resolve().then(function() {
                        _this._babylonScene = scene;
                        _this._loadData(data);
                        return _this._loadAsync(rootUrl, fileName, null, function() {
                          return void 0;
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAsync = function(rootUrl, fileName, nodes, resultFunc) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function() {
                          var loadingToReadyCounterName, loadingToCompleteCounterName, promises, oldBlockMaterialDirtyMechanism, scene, m, material, context_1, babylonDrawMode, resultPromise;
                          var _this2 = this;
                          return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                this._rootUrl = rootUrl;
                                this._uniqueRootUrl = !rootUrl.startsWith("file:") && fileName ? rootUrl : "".concat(rootUrl).concat(Date.now(), "/");
                                this._fileName = fileName;
                                this._allMaterialsDirtyRequired = false;
                                return [4, this._loadExtensionsAsync()];
                              case 1:
                                _a.sent();
                                loadingToReadyCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY]);
                                loadingToCompleteCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE]);
                                this._parent._startPerformanceCounter(loadingToReadyCounterName);
                                this._parent._startPerformanceCounter(loadingToCompleteCounterName);
                                this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING);
                                this._extensionsOnLoading();
                                promises = new Array();
                                oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;
                                this._babylonScene.blockMaterialDirtyMechanism = true;
                                if (!this.parent.loadOnlyMaterials) {
                                  if (nodes) {
                                    promises.push(this.loadSceneAsync("/nodes", { nodes, index: -1 }));
                                  } else if (this._gltf.scene != void 0 || this._gltf.scenes && this._gltf.scenes[0]) {
                                    scene = ArrayItem.Get("/scene", this._gltf.scenes, this._gltf.scene || 0);
                                    promises.push(this.loadSceneAsync("/scenes/".concat(scene.index), scene));
                                  }
                                }
                                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {
                                  for (m = 0; m < this._gltf.materials.length; ++m) {
                                    material = this._gltf.materials[m];
                                    context_1 = "/materials/" + m;
                                    babylonDrawMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
                                    promises.push(this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function() {
                                    }));
                                  }
                                }
                                if (this._allMaterialsDirtyRequired) {
                                  this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
                                } else {
                                  this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);
                                }
                                if (this._parent.compileMaterials) {
                                  promises.push(this._compileMaterialsAsync());
                                }
                                if (this._parent.compileShadowGenerators) {
                                  promises.push(this._compileShadowGeneratorsAsync());
                                }
                                resultPromise = Promise.all(promises).then(function() {
                                  if (_this2._rootBabylonMesh && _this2._rootBabylonMesh !== _this2._parent.customRootNode) {
                                    _this2._rootBabylonMesh.setEnabled(true);
                                  }
                                  for (var _i = 0, _a2 = _this2._babylonScene.materials; _i < _a2.length; _i++) {
                                    var material2 = _a2[_i];
                                    var mat = material2;
                                    if (mat.maxSimultaneousLights !== void 0) {
                                      mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, _this2._babylonScene.lights.length);
                                    }
                                  }
                                  _this2._extensionsOnReady();
                                  _this2._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY);
                                  if (!_this2._skipStartAnimationStep) {
                                    _this2._startAnimations();
                                  }
                                  return resultFunc();
                                });
                                return [2, resultPromise.then(function(result) {
                                  _this2._parent._endPerformanceCounter(loadingToReadyCounterName);
                                  babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function() {
                                    if (!_this2._disposed) {
                                      Promise.all(_this2._completePromises).then(function() {
                                        _this2._parent._endPerformanceCounter(loadingToCompleteCounterName);
                                        _this2._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE);
                                        _this2._parent.onCompleteObservable.notifyObservers(void 0);
                                        _this2._parent.onCompleteObservable.clear();
                                        _this2.dispose();
                                      }, function(error) {
                                        _this2._parent.onErrorObservable.notifyObservers(error);
                                        _this2._parent.onErrorObservable.clear();
                                        _this2.dispose();
                                      });
                                    }
                                  });
                                  return result;
                                })];
                            }
                          });
                        });
                      }).catch(function(error) {
                        if (!_this._disposed) {
                          _this._parent.onErrorObservable.notifyObservers(error);
                          _this._parent.onErrorObservable.clear();
                          _this.dispose();
                        }
                        throw error;
                      });
                    };
                    GLTFLoader2.prototype._loadData = function(data) {
                      this._gltf = data.json;
                      this._setupData();
                      if (data.bin) {
                        var buffers = this._gltf.buffers;
                        if (buffers && buffers[0] && !buffers[0].uri) {
                          var binaryBuffer = buffers[0];
                          if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Binary buffer length (".concat(binaryBuffer.byteLength, ") from JSON does not match chunk length (").concat(data.bin.byteLength, ")"));
                          }
                          this._bin = data.bin;
                        } else {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Unexpected BIN chunk");
                        }
                      }
                    };
                    GLTFLoader2.prototype._setupData = function() {
                      ArrayItem.Assign(this._gltf.accessors);
                      ArrayItem.Assign(this._gltf.animations);
                      ArrayItem.Assign(this._gltf.buffers);
                      ArrayItem.Assign(this._gltf.bufferViews);
                      ArrayItem.Assign(this._gltf.cameras);
                      ArrayItem.Assign(this._gltf.images);
                      ArrayItem.Assign(this._gltf.materials);
                      ArrayItem.Assign(this._gltf.meshes);
                      ArrayItem.Assign(this._gltf.nodes);
                      ArrayItem.Assign(this._gltf.samplers);
                      ArrayItem.Assign(this._gltf.scenes);
                      ArrayItem.Assign(this._gltf.skins);
                      ArrayItem.Assign(this._gltf.textures);
                      if (this._gltf.nodes) {
                        var nodeParents = {};
                        for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {
                          var node = _a[_i];
                          if (node.children) {
                            for (var _b = 0, _c = node.children; _b < _c.length; _b++) {
                              var index = _c[_b];
                              nodeParents[index] = node.index;
                            }
                          }
                        }
                        var rootNode = this._createRootNode();
                        for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {
                          var node = _e[_d];
                          var parentIndex = nodeParents[node.index];
                          node.parent = parentIndex === void 0 ? rootNode : this._gltf.nodes[parentIndex];
                        }
                      }
                    };
                    GLTFLoader2.prototype._loadExtensionsAsync = function() {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function() {
                        var extensionPromises, _a, _b, _c, _loop_1, this_1, _i, _d, name_1;
                        var _e;
                        var _this = this;
                        var _f;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_g) {
                          switch (_g.label) {
                            case 0:
                              extensionPromises = [];
                              _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registeredGLTFExtensions.forEach(function(registeredExtension, name2) {
                                var _a2;
                                if (((_a2 = _this.parent.extensionOptions[name2]) === null || _a2 === void 0 ? void 0 : _a2.enabled) === false) {
                                  if (registeredExtension.isGLTFExtension && _this.isExtensionUsed(name2)) {
                                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Extension ".concat(name2, " is used but has been explicitly disabled."));
                                  }
                                } else if (!registeredExtension.isGLTFExtension || _this.isExtensionUsed(name2)) {
                                  extensionPromises.push(function() {
                                    return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function() {
                                      var extension;
                                      return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_a3) {
                                        switch (_a3.label) {
                                          case 0:
                                            return [4, registeredExtension.factory(this)];
                                          case 1:
                                            extension = _a3.sent();
                                            if (extension.name !== name2) {
                                              babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("The name of the glTF loader extension instance does not match the registered name: ".concat(extension.name, " !== ").concat(name2));
                                            }
                                            this._parent.onExtensionLoadedObservable.notifyObservers(extension);
                                            return [2, extension];
                                        }
                                      });
                                    });
                                  }());
                                }
                              });
                              _b = (_a = (_e = this._extensions).push).apply;
                              _c = [_e];
                              return [4, Promise.all(extensionPromises)];
                            case 1:
                              _b.apply(_a, _c.concat([_g.sent()]));
                              this._extensions.sort(function(a, b) {
                                return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE);
                              });
                              this._parent.onExtensionLoadedObservable.clear();
                              if (this._gltf.extensionsRequired) {
                                _loop_1 = function(name_12) {
                                  var available = this_1._extensions.some(function(extension) {
                                    return extension.name === name_12 && extension.enabled;
                                  });
                                  if (!available) {
                                    if (((_f = this_1.parent.extensionOptions[name_12]) === null || _f === void 0 ? void 0 : _f.enabled) === false) {
                                      throw new Error("Required extension ".concat(name_12, " is disabled"));
                                    }
                                    throw new Error("Required extension ".concat(name_12, " is not available"));
                                  }
                                };
                                this_1 = this;
                                for (_i = 0, _d = this._gltf.extensionsRequired; _i < _d.length; _i++) {
                                  name_1 = _d[_i];
                                  _loop_1(name_1);
                                }
                              }
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    };
                    GLTFLoader2.prototype._createRootNode = function() {
                      if (this._parent.customRootNode !== void 0) {
                        this._rootBabylonMesh = this._parent.customRootNode;
                        return {
                          // eslint-disable-next-line @typescript-eslint/naming-convention
                          _babylonTransformNode: this._rootBabylonMesh === null ? void 0 : this._rootBabylonMesh,
                          index: -1
                        };
                      }
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var rootMesh = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh("__root__", this._babylonScene);
                      this._rootBabylonMesh = rootMesh;
                      this._rootBabylonMesh._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      this._rootBabylonMesh.setEnabled(false);
                      var rootNode = {
                        // eslint-disable-next-line @typescript-eslint/naming-convention
                        _babylonTransformNode: this._rootBabylonMesh,
                        index: -1
                      };
                      switch (this._parent.coordinateSystemMode) {
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.AUTO: {
                          if (!this._babylonScene.useRightHandedSystem) {
                            rootNode.rotation = [0, 1, 0, 0];
                            rootNode.scale = [1, 1, -1];
                            GLTFLoader2._LoadTransform(rootNode, this._rootBabylonMesh);
                          }
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
                          this._babylonScene.useRightHandedSystem = true;
                          break;
                        }
                        default: {
                          throw new Error("Invalid coordinate system mode (".concat(this._parent.coordinateSystemMode, ")"));
                        }
                      }
                      this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);
                      return rootNode;
                    };
                    GLTFLoader2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadSceneAsync(context, scene);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(scene.name || ""));
                      if (scene.nodes) {
                        for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {
                          var index = _a[_i];
                          var node = ArrayItem.Get("".concat(context, "/nodes/").concat(index), this._gltf.nodes, index);
                          promises.push(this.loadNodeAsync("/nodes/".concat(node.index), node, function(babylonMesh) {
                            babylonMesh.parent = _this._rootBabylonMesh;
                          }));
                        }
                      }
                      for (var _b = 0, _c = this._postSceneLoadActions; _b < _c.length; _b++) {
                        var action = _c[_b];
                        action();
                      }
                      promises.push(this._loadAnimationsAsync());
                      this.logClose();
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype._forEachPrimitive = function(node, callback) {
                      if (node._primitiveBabylonMeshes) {
                        for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {
                          var babylonMesh = _a[_i];
                          callback(babylonMesh);
                        }
                      }
                    };
                    GLTFLoader2.prototype._getGeometries = function() {
                      var geometries = [];
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                          var node = nodes_1[_i];
                          this._forEachPrimitive(node, function(babylonMesh) {
                            var geometry = babylonMesh.geometry;
                            if (geometry && geometries.indexOf(geometry) === -1) {
                              geometries.push(geometry);
                            }
                          });
                        }
                      }
                      return geometries;
                    };
                    GLTFLoader2.prototype._getMeshes = function() {
                      var meshes = [];
                      if (this._rootBabylonMesh instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.AbstractMesh) {
                        meshes.push(this._rootBabylonMesh);
                      }
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                          var node = nodes_2[_i];
                          this._forEachPrimitive(node, function(babylonMesh) {
                            meshes.push(babylonMesh);
                          });
                        }
                      }
                      return meshes;
                    };
                    GLTFLoader2.prototype._getTransformNodes = function() {
                      var transformNodes = [];
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
                          var node = nodes_3[_i];
                          if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
                            transformNodes.push(node._babylonTransformNode);
                          }
                          if (node._babylonTransformNodeForSkin) {
                            transformNodes.push(node._babylonTransformNodeForSkin);
                          }
                        }
                      }
                      return transformNodes;
                    };
                    GLTFLoader2.prototype._getSkeletons = function() {
                      var skeletons = [];
                      var skins = this._gltf.skins;
                      if (skins) {
                        for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {
                          var skin = skins_1[_i];
                          if (skin._data) {
                            skeletons.push(skin._data.babylonSkeleton);
                          }
                        }
                      }
                      return skeletons;
                    };
                    GLTFLoader2.prototype._getAnimationGroups = function() {
                      var animationGroups = [];
                      var animations = this._gltf.animations;
                      if (animations) {
                        for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                          var animation = animations_1[_i];
                          if (animation._babylonAnimationGroup) {
                            animationGroups.push(animation._babylonAnimationGroup);
                          }
                        }
                      }
                      return animationGroups;
                    };
                    GLTFLoader2.prototype._startAnimations = function() {
                      switch (this._parent.animationStartMode) {
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.NONE: {
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.FIRST: {
                          var babylonAnimationGroups = this._getAnimationGroups();
                          if (babylonAnimationGroups.length !== 0) {
                            babylonAnimationGroups[0].start(true);
                          }
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.ALL: {
                          var babylonAnimationGroups = this._getAnimationGroups();
                          for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {
                            var babylonAnimationGroup = babylonAnimationGroups_1[_i];
                            babylonAnimationGroup.start(true);
                          }
                          break;
                        }
                        default: {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Invalid animation start mode (".concat(this._parent.animationStartMode, ")"));
                          return;
                        }
                      }
                    };
                    GLTFLoader2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (node._babylonTransformNode) {
                        throw new Error("".concat(context, ": Invalid recursive node hierarchy"));
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(node.name || ""));
                      var loadNode = function(babylonTransformNode) {
                        GLTFLoader2.AddPointerMetadata(babylonTransformNode, context);
                        GLTFLoader2._LoadTransform(node, babylonTransformNode);
                        if (node.camera != void 0) {
                          var camera = ArrayItem.Get("".concat(context, "/camera"), _this._gltf.cameras, node.camera);
                          promises.push(_this.loadCameraAsync("/cameras/".concat(camera.index), camera, function(babylonCamera) {
                            babylonCamera.parent = babylonTransformNode;
                          }));
                        }
                        if (node.children) {
                          for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                            var index = _a[_i];
                            var childNode = ArrayItem.Get("".concat(context, "/children/").concat(index), _this._gltf.nodes, index);
                            promises.push(_this.loadNodeAsync("/nodes/".concat(childNode.index), childNode, function(childBabylonMesh) {
                              childBabylonMesh.parent = babylonTransformNode;
                            }));
                          }
                        }
                        assign(babylonTransformNode);
                      };
                      var hasMesh = node.mesh != void 0;
                      var hasSkin = this._parent.loadSkins && node.skin != void 0;
                      if (!hasMesh || hasSkin) {
                        var nodeName = node.name || "node".concat(node.index);
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        var transformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(nodeName, this._babylonScene);
                        transformNode._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        if (node.mesh == void 0) {
                          node._babylonTransformNode = transformNode;
                        } else {
                          node._babylonTransformNodeForSkin = transformNode;
                        }
                        loadNode(transformNode);
                      }
                      if (hasMesh) {
                        if (hasSkin) {
                          var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                          promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, function(babylonTransformNode) {
                            var babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;
                            babylonTransformNode.metadata = (0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.deepMerge)(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});
                            var skin = ArrayItem.Get("".concat(context, "/skin"), _this._gltf.skins, node.skin);
                            promises.push(_this._loadSkinAsync("/skins/".concat(skin.index), node, skin, function(babylonSkeleton) {
                              _this._forEachPrimitive(node, function(babylonMesh) {
                                babylonMesh.skeleton = babylonSkeleton;
                              });
                              _this._postSceneLoadActions.push(function() {
                                if (skin.skeleton != void 0) {
                                  var parentNode = ArrayItem.Get("/skins/".concat(skin.index, "/skeleton"), _this._gltf.nodes, skin.skeleton).parent;
                                  if (node.index === parentNode.index) {
                                    babylonTransformNode.parent = babylonTransformNodeForSkin.parent;
                                  } else {
                                    babylonTransformNode.parent = parentNode._babylonTransformNode;
                                  }
                                } else {
                                  babylonTransformNode.parent = _this._rootBabylonMesh;
                                }
                                _this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });
                              });
                            }));
                          }));
                        } else {
                          var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                          promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, loadNode));
                        }
                      }
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        _this._forEachPrimitive(node, function(babylonMesh) {
                          var asMesh = babylonMesh;
                          if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {
                            babylonMesh._updateBoundingInfo();
                          } else {
                            babylonMesh.refreshBoundingInfo(true, true);
                          }
                        });
                        return node._babylonTransformNode;
                      });
                    };
                    GLTFLoader2.prototype._loadMeshAsync = function(context, node, mesh, assign) {
                      var primitives = mesh.primitives;
                      if (!primitives || !primitives.length) {
                        throw new Error("".concat(context, ": Primitives are missing"));
                      }
                      if (primitives[0].index == void 0) {
                        ArrayItem.Assign(primitives);
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(mesh.name || ""));
                      var name2 = node.name || "node".concat(node.index);
                      if (primitives.length === 1) {
                        var primitive = mesh.primitives[0];
                        promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), name2, node, mesh, primitive, function(babylonMesh) {
                          node._babylonTransformNode = babylonMesh;
                          node._primitiveBabylonMeshes = [babylonMesh];
                        }));
                      } else {
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        node._babylonTransformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(name2, this._babylonScene);
                        node._babylonTransformNode._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        node._primitiveBabylonMeshes = [];
                        for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                          var primitive = primitives_1[_i];
                          promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), "".concat(name2, "_primitive").concat(primitive.index), node, mesh, primitive, function(babylonMesh) {
                            babylonMesh.parent = node._babylonTransformNode;
                            node._primitiveBabylonMeshes.push(babylonMesh);
                          }));
                        }
                      }
                      assign(node._babylonTransformNode);
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        return node._babylonTransformNode;
                      });
                    };
                    GLTFLoader2.prototype._loadMeshPrimitiveAsync = function(context, name2, node, mesh, primitive, assign) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context));
                      var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == void 0 && !mesh.primitives[0].targets;
                      var babylonAbstractMesh;
                      var promise;
                      if (shouldInstance && primitive._instanceData) {
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name2);
                        babylonAbstractMesh._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        promise = primitive._instanceData.promise;
                      } else {
                        var promises = new Array();
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        var babylonMesh_1 = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh(name2, this._babylonScene);
                        babylonMesh_1._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        babylonMesh_1.sideOrientation = this._babylonScene.useRightHandedSystem ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.CounterClockWiseSideOrientation : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.ClockWiseSideOrientation;
                        this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);
                        promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function(babylonGeometry) {
                          return _this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function() {
                            if (_this._disposed) {
                              return;
                            }
                            _this._babylonScene._blockEntityCollection = !!_this._assetContainer;
                            babylonGeometry.applyToMesh(babylonMesh_1);
                            babylonGeometry._parentContainer = _this._assetContainer;
                            _this._babylonScene._blockEntityCollection = false;
                          });
                        }));
                        var babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
                        if (primitive.material == void 0) {
                          var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
                          if (!babylonMaterial) {
                            babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
                            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
                            this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
                          }
                          babylonMesh_1.material = babylonMaterial;
                        } else if (!this.parent.skipMaterials) {
                          var material = ArrayItem.Get("".concat(context, "/material"), this._gltf.materials, primitive.material);
                          promises.push(this._loadMaterialAsync("/materials/".concat(material.index), material, babylonMesh_1, babylonDrawMode, function(babylonMaterial2) {
                            babylonMesh_1.material = babylonMaterial2;
                          }));
                        }
                        promise = Promise.all(promises);
                        if (shouldInstance) {
                          primitive._instanceData = {
                            babylonSourceMesh: babylonMesh_1,
                            promise
                          };
                        }
                        babylonAbstractMesh = babylonMesh_1;
                      }
                      GLTFLoader2.AddPointerMetadata(babylonAbstractMesh, context);
                      this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
                      assign(babylonAbstractMesh);
                      this.logClose();
                      return promise.then(function() {
                        return babylonAbstractMesh;
                      });
                    };
                    GLTFLoader2.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var attributes = primitive.attributes;
                      if (!attributes) {
                        throw new Error("".concat(context, ": Attributes are missing"));
                      }
                      var promises = new Array();
                      var babylonGeometry = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Geometry(babylonMesh.name, this._babylonScene);
                      if (primitive.indices == void 0) {
                        babylonMesh.isUnIndexed = true;
                      } else {
                        var accessor = ArrayItem.Get("".concat(context, "/indices"), this._gltf.accessors, primitive.indices);
                        promises.push(this._loadIndicesAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function(data) {
                          babylonGeometry.setIndices(data);
                        }));
                      }
                      var loadAttribute = function(name2, kind, callback) {
                        if (attributes[name2] == void 0) {
                          return;
                        }
                        babylonMesh._delayInfo = babylonMesh._delayInfo || [];
                        if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                          babylonMesh._delayInfo.push(kind);
                        }
                        var accessor2 = ArrayItem.Get("".concat(context, "/attributes/").concat(name2), _this._gltf.accessors, attributes[name2]);
                        promises.push(_this._loadVertexAccessorAsync("/accessors/".concat(accessor2.index), accessor2, kind).then(function(babylonVertexBuffer) {
                          if (babylonVertexBuffer.getKind() === babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
                            var babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor2);
                            if (babylonBoundingInfo) {
                              babylonGeometry._boundingInfo = babylonBoundingInfo;
                              babylonGeometry.useBoundingInfoFromGeometry = true;
                            }
                          }
                          babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor2.count);
                        }));
                        if (kind == babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind) {
                          babylonMesh.numBoneInfluencers = 8;
                        }
                        if (callback) {
                          callback(accessor2);
                        }
                      };
                      loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                      loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                      loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
                      loadAttribute("TEXCOORD_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
                      loadAttribute("TEXCOORD_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
                      loadAttribute("TEXCOORD_2", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
                      loadAttribute("TEXCOORD_3", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
                      loadAttribute("TEXCOORD_4", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
                      loadAttribute("TEXCOORD_5", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
                      loadAttribute("JOINTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
                      loadAttribute("WEIGHTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
                      loadAttribute("JOINTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind);
                      loadAttribute("WEIGHTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsExtraKind);
                      loadAttribute("COLOR_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind, function(accessor2) {
                        if (accessor2.type === "VEC4") {
                          babylonMesh.hasVertexAlpha = true;
                        }
                      });
                      return Promise.all(promises).then(function() {
                        return babylonGeometry;
                      });
                    };
                    GLTFLoader2.prototype._createMorphTargets = function(context, node, mesh, primitive, babylonMesh) {
                      if (!primitive.targets || !this._parent.loadMorphTargets) {
                        return;
                      }
                      if (node._numMorphTargets == void 0) {
                        node._numMorphTargets = primitive.targets.length;
                      } else if (primitive.targets.length !== node._numMorphTargets) {
                        throw new Error("".concat(context, ": Primitives do not have the same number of targets"));
                      }
                      var targetNames = mesh.extras ? mesh.extras.targetNames : null;
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      babylonMesh.morphTargetManager = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTargetManager(this._babylonScene);
                      babylonMesh.morphTargetManager._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonMesh.morphTargetManager.areUpdatesFrozen = true;
                      for (var index = 0; index < primitive.targets.length; index++) {
                        var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
                        var name_2 = targetNames ? targetNames[index] : "morphTarget".concat(index);
                        babylonMesh.morphTargetManager.addTarget(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTarget(name_2, weight, babylonMesh.getScene()));
                      }
                    };
                    GLTFLoader2.prototype._loadMorphTargetsAsync = function(context, primitive, babylonMesh, babylonGeometry) {
                      if (!primitive.targets || !this._parent.loadMorphTargets) {
                        return Promise.resolve();
                      }
                      var promises = new Array();
                      var morphTargetManager = babylonMesh.morphTargetManager;
                      for (var index = 0; index < morphTargetManager.numTargets; index++) {
                        var babylonMorphTarget = morphTargetManager.getTarget(index);
                        promises.push(this._loadMorphTargetVertexDataAsync("".concat(context, "/targets/").concat(index), babylonGeometry, primitive.targets[index], babylonMorphTarget));
                      }
                      return Promise.all(promises).then(function() {
                        morphTargetManager.areUpdatesFrozen = false;
                      });
                    };
                    GLTFLoader2.prototype._loadMorphTargetVertexDataAsync = function(context, babylonGeometry, attributes, babylonMorphTarget) {
                      var _this = this;
                      var promises = new Array();
                      var loadAttribute = function(attribute, kind, setData) {
                        if (attributes[attribute] == void 0) {
                          return;
                        }
                        var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
                        if (!babylonVertexBuffer) {
                          return;
                        }
                        var accessor = ArrayItem.Get("".concat(context, "/").concat(attribute), _this._gltf.accessors, attributes[attribute]);
                        promises.push(_this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function(data) {
                          setData(babylonVertexBuffer, data);
                        }));
                      };
                      loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, function(babylonVertexBuffer, data) {
                        var positions = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(data.length, function(value, index) {
                          positions[index] = data[index] + value;
                        });
                        babylonMorphTarget.setPositions(positions);
                      });
                      loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, function(babylonVertexBuffer, data) {
                        var normals = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(normals.length, function(value, index) {
                          normals[index] = data[index] + value;
                        });
                        babylonMorphTarget.setNormals(normals);
                      });
                      loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind, function(babylonVertexBuffer, data) {
                        var tangents = new Float32Array(data.length / 3 * 4);
                        var dataIndex = 0;
                        babylonVertexBuffer.forEach(data.length / 3 * 4, function(value, index) {
                          if ((index + 1) % 4 !== 0) {
                            tangents[dataIndex] = data[dataIndex] + value;
                            dataIndex++;
                          }
                        });
                        babylonMorphTarget.setTangents(tangents);
                      });
                      loadAttribute("TEXCOORD_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind, function(babylonVertexBuffer, data) {
                        var uvs = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(data.length, function(value, index) {
                          uvs[index] = data[index] + value;
                        });
                        babylonMorphTarget.setUVs(uvs);
                      });
                      loadAttribute("TEXCOORD_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind, function(babylonVertexBuffer, data) {
                        var uvs = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(data.length, function(value, index) {
                          uvs[index] = data[index] + value;
                        });
                        babylonMorphTarget.setUV2s(uvs);
                      });
                      loadAttribute("COLOR_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind, function(babylonVertexBuffer, data) {
                        var colors = null;
                        var componentSize = babylonVertexBuffer.getSize();
                        if (componentSize === 3) {
                          colors = new Float32Array(data.length / 3 * 4);
                          babylonVertexBuffer.forEach(data.length, function(value, index) {
                            var pixid = Math.floor(index / 3);
                            var channel = index % 3;
                            colors[4 * pixid + channel] = data[3 * pixid + channel] + value;
                          });
                          for (var i = 0; i < data.length / 3; ++i) {
                            colors[4 * i + 3] = 1;
                          }
                        } else if (componentSize === 4) {
                          colors = new Float32Array(data.length);
                          babylonVertexBuffer.forEach(data.length, function(value, index) {
                            colors[index] = data[index] + value;
                          });
                        } else {
                          throw new Error("".concat(context, ": Invalid number of components (").concat(componentSize, ") for COLOR_0 attribute"));
                        }
                        babylonMorphTarget.setColors(colors);
                      });
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2._LoadTransform = function(node, babylonNode) {
                      if (node.skin != void 0) {
                        return;
                      }
                      var position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
                      var rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity();
                      var scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One();
                      if (node.matrix) {
                        var matrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix);
                        matrix.decompose(scaling, rotation, position);
                      } else {
                        if (node.translation) {
                          position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation);
                        }
                        if (node.rotation) {
                          rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation);
                        }
                        if (node.scale) {
                          scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale);
                        }
                      }
                      babylonNode.position = position;
                      babylonNode.rotationQuaternion = rotation;
                      babylonNode.scaling = scaling;
                    };
                    GLTFLoader2.prototype._loadSkinAsync = function(context, node, skin, assign) {
                      var _this = this;
                      if (!this._parent.loadSkins) {
                        return Promise.resolve();
                      }
                      var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (skin._data) {
                        assign(skin._data.babylonSkeleton);
                        return skin._data.promise;
                      }
                      var skeletonId = "skeleton".concat(skin.index);
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonSkeleton = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
                      babylonSkeleton._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      this._loadBones(context, skin, babylonSkeleton);
                      var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function(inverseBindMatricesData) {
                        _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
                      });
                      skin._data = {
                        babylonSkeleton,
                        promise
                      };
                      assign(babylonSkeleton);
                      return promise;
                    };
                    GLTFLoader2.prototype._loadBones = function(context, skin, babylonSkeleton) {
                      if (skin.skeleton == void 0 || this._parent.alwaysComputeSkeletonRootNode) {
                        var rootNode = this._findSkeletonRootNode("".concat(context, "/joints"), skin.joints);
                        if (rootNode) {
                          if (skin.skeleton === void 0) {
                            skin.skeleton = rootNode.index;
                          } else {
                            var isParent = function(a, b) {
                              for (; b.parent; b = b.parent) {
                                if (b.parent === a) {
                                  return true;
                                }
                              }
                              return false;
                            };
                            var skeletonNode = ArrayItem.Get("".concat(context, "/skeleton"), this._gltf.nodes, skin.skeleton);
                            if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {
                              babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root"));
                              skin.skeleton = rootNode.index;
                            }
                          }
                        } else {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Failed to find common root"));
                        }
                      }
                      var babylonBones = {};
                      for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                        var index = _a[_i];
                        var node = ArrayItem.Get("".concat(context, "/joints/").concat(index), this._gltf.nodes, index);
                        this._loadBone(node, skin, babylonSkeleton, babylonBones);
                      }
                    };
                    GLTFLoader2.prototype._findSkeletonRootNode = function(context, joints) {
                      if (joints.length === 0) {
                        return null;
                      }
                      var paths = {};
                      for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {
                        var index = joints_1[_i];
                        var path = [];
                        var node = ArrayItem.Get("".concat(context, "/").concat(index), this._gltf.nodes, index);
                        while (node.index !== -1) {
                          path.unshift(node);
                          node = node.parent;
                        }
                        paths[index] = path;
                      }
                      var rootNode = null;
                      for (var i = 0; ; ++i) {
                        var path = paths[joints[0]];
                        if (i >= path.length) {
                          return rootNode;
                        }
                        var node = path[i];
                        for (var j = 1; j < joints.length; ++j) {
                          path = paths[joints[j]];
                          if (i >= path.length || node !== path[i]) {
                            return rootNode;
                          }
                        }
                        rootNode = node;
                      }
                    };
                    GLTFLoader2.prototype._loadBone = function(node, skin, babylonSkeleton, babylonBones) {
                      node._isJoint = true;
                      var babylonBone = babylonBones[node.index];
                      if (babylonBone) {
                        return babylonBone;
                      }
                      var parentBabylonBone = null;
                      if (node.index !== skin.skeleton) {
                        if (node.parent && node.parent.index !== -1) {
                          parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
                        } else if (skin.skeleton !== void 0) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("/skins/".concat(skin.index, "/skeleton: Skeleton node is not a common root"));
                        }
                      }
                      var boneIndex = skin.joints.indexOf(node.index);
                      babylonBone = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Bone(node.name || "joint".concat(node.index), babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);
                      babylonBones[node.index] = babylonBone;
                      this._postSceneLoadActions.push(function() {
                        babylonBone.linkTransformNode(node._babylonTransformNode);
                      });
                      return babylonBone;
                    };
                    GLTFLoader2.prototype._loadSkinInverseBindMatricesDataAsync = function(context, skin) {
                      if (skin.inverseBindMatrices == void 0) {
                        return Promise.resolve(null);
                      }
                      var accessor = ArrayItem.Get("".concat(context, "/inverseBindMatrices"), this._gltf.accessors, skin.inverseBindMatrices);
                      return this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor);
                    };
                    GLTFLoader2.prototype._updateBoneMatrices = function(babylonSkeleton, inverseBindMatricesData) {
                      for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {
                        var babylonBone = _a[_i];
                        var baseMatrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Identity();
                        var boneIndex = babylonBone._index;
                        if (inverseBindMatricesData && boneIndex !== -1) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
                          baseMatrix.invertToRef(baseMatrix);
                        }
                        var babylonParentBone = babylonBone.getParent();
                        if (babylonParentBone) {
                          baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);
                        }
                        babylonBone.updateMatrix(baseMatrix, false, false);
                        babylonBone._updateAbsoluteBindMatrices(void 0, false);
                      }
                    };
                    GLTFLoader2.prototype._getNodeMatrix = function(node) {
                      return node.matrix ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose(node.scale ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One(), node.rotation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity(), node.translation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero());
                    };
                    GLTFLoader2.prototype.loadCameraAsync = function(context, camera, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(camera.name || ""));
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonCamera = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.FreeCamera(camera.name || "camera".concat(camera.index), babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), this._babylonScene, false);
                      babylonCamera._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonCamera.ignoreParentScaling = true;
                      camera._babylonCamera = babylonCamera;
                      babylonCamera.rotation.set(0, Math.PI, 0);
                      switch (camera.type) {
                        case "perspective": {
                          var perspective = camera.perspective;
                          if (!perspective) {
                            throw new Error("".concat(context, ": Camera perspective properties are missing"));
                          }
                          babylonCamera.fov = perspective.yfov;
                          babylonCamera.minZ = perspective.znear;
                          babylonCamera.maxZ = perspective.zfar || 0;
                          break;
                        }
                        case "orthographic": {
                          if (!camera.orthographic) {
                            throw new Error("".concat(context, ": Camera orthographic properties are missing"));
                          }
                          babylonCamera.mode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Camera.ORTHOGRAPHIC_CAMERA;
                          babylonCamera.orthoLeft = -camera.orthographic.xmag;
                          babylonCamera.orthoRight = camera.orthographic.xmag;
                          babylonCamera.orthoBottom = -camera.orthographic.ymag;
                          babylonCamera.orthoTop = camera.orthographic.ymag;
                          babylonCamera.minZ = camera.orthographic.znear;
                          babylonCamera.maxZ = camera.orthographic.zfar;
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, ": Invalid camera type (").concat(camera.type, ")"));
                        }
                      }
                      GLTFLoader2.AddPointerMetadata(babylonCamera, context);
                      this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
                      assign(babylonCamera);
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        return babylonCamera;
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationsAsync = function() {
                      var animations = this._gltf.animations;
                      if (!animations) {
                        return Promise.resolve();
                      }
                      var promises = new Array();
                      for (var index = 0; index < animations.length; index++) {
                        var animation = animations[index];
                        promises.push(this.loadAnimationAsync("/animations/".concat(animation.index), animation).then(function(animationGroup) {
                          if (animationGroup.targetedAnimations.length === 0) {
                            animationGroup.dispose();
                          }
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadAnimationAsync = function(context, animation) {
                      var _this = this;
                      var promise = this._extensionsLoadAnimationAsync(context, animation);
                      if (promise) {
                        return promise;
                      }
                      return Promise.resolve(
                        /*! import() */
                      ).then(__webpack_require__2.t.bind(
                        __webpack_require__2,
                        /*! babylonjs/Animations/animationGroup */
                        "babylonjs/Misc/tools",
                        23
                      )).then(function(_a) {
                        var AnimationGroup = _a.AnimationGroup;
                        _this._babylonScene._blockEntityCollection = !!_this._assetContainer;
                        var babylonAnimationGroup = new AnimationGroup(animation.name || "animation".concat(animation.index), _this._babylonScene);
                        babylonAnimationGroup._parentContainer = _this._assetContainer;
                        _this._babylonScene._blockEntityCollection = false;
                        animation._babylonAnimationGroup = babylonAnimationGroup;
                        var promises = new Array();
                        ArrayItem.Assign(animation.channels);
                        ArrayItem.Assign(animation.samplers);
                        for (var _i = 0, _b = animation.channels; _i < _b.length; _i++) {
                          var channel = _b[_i];
                          promises.push(_this._loadAnimationChannelAsync("".concat(context, "/channels/").concat(channel.index), context, animation, channel, function(babylonTarget, babylonAnimation) {
                            babylonTarget.animations = babylonTarget.animations || [];
                            babylonTarget.animations.push(babylonAnimation);
                            babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);
                          }));
                        }
                        return Promise.all(promises).then(function() {
                          babylonAnimationGroup.normalize(0);
                          return babylonAnimationGroup;
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function() {
                        var promise, targetNode, channelTargetPath, pathIsWeights, properties, targetInfo;
                        var _a, _b, _c, _d;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function(_e) {
                          switch (_e.label) {
                            case 0:
                              promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
                              if (promise) {
                                return [2, promise];
                              }
                              if (channel.target.node == void 0) {
                                return [2, Promise.resolve()];
                              }
                              targetNode = ArrayItem.Get("".concat(context, "/target/node"), this._gltf.nodes, channel.target.node);
                              channelTargetPath = channel.target.path;
                              pathIsWeights = channelTargetPath === "weights";
                              if (pathIsWeights && !targetNode._numMorphTargets || !pathIsWeights && !targetNode._babylonTransformNode) {
                                return [2, Promise.resolve()];
                              }
                              if (!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint) {
                                return [2, Promise.resolve()];
                              }
                              return [4, Promise.resolve(
                                /*! import() */
                              ).then(__webpack_require__2.bind(
                                __webpack_require__2,
                                /*! ./glTFLoaderAnimation */
                                "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"
                              ))];
                            case 1:
                              _e.sent();
                              switch (channelTargetPath) {
                                case "translation": {
                                  properties = (_a = (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/translation")) === null || _a === void 0 ? void 0 : _a.interpolation;
                                  break;
                                }
                                case "rotation": {
                                  properties = (_b = (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/rotation")) === null || _b === void 0 ? void 0 : _b.interpolation;
                                  break;
                                }
                                case "scale": {
                                  properties = (_c = (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/scale")) === null || _c === void 0 ? void 0 : _c.interpolation;
                                  break;
                                }
                                case "weights": {
                                  properties = (_d = (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/weights")) === null || _d === void 0 ? void 0 : _d.interpolation;
                                  break;
                                }
                                default: {
                                  throw new Error("".concat(context, "/target/path: Invalid value (").concat(channel.target.path, ")"));
                                }
                              }
                              if (!properties) {
                                throw new Error("".concat(context, "/target/path: Could not find interpolation properties for target path (").concat(channel.target.path, ")"));
                              }
                              targetInfo = {
                                object: targetNode,
                                info: properties
                              };
                              return [2, this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad)];
                          }
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationChannelFromTargetInfoAsync = function(context, animationContext, animation, channel, targetInfo, onLoad) {
                      var fps = this.parent.targetFps;
                      var invfps = 1 / fps;
                      var sampler = ArrayItem.Get("".concat(context, "/sampler"), animation.samplers, channel.sampler);
                      return this._loadAnimationSamplerAsync("".concat(animationContext, "/samplers/").concat(channel.sampler), sampler).then(function(data) {
                        var numAnimations = 0;
                        var target = targetInfo.object;
                        var propertyInfos = targetInfo.info;
                        for (var _i = 0, propertyInfos_1 = propertyInfos; _i < propertyInfos_1.length; _i++) {
                          var propertyInfo = propertyInfos_1[_i];
                          var stride = propertyInfo.getStride(target);
                          var input = data.input;
                          var output = data.output;
                          var keys = new Array(input.length);
                          var outputOffset = 0;
                          switch (data.interpolation) {
                            case "STEP": {
                              for (var index = 0; index < input.length; index++) {
                                var value = propertyInfo.getValue(target, output, outputOffset, 1);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  value,
                                  interpolation: 1
                                };
                              }
                              break;
                            }
                            case "CUBICSPLINE": {
                              for (var index = 0; index < input.length; index++) {
                                var inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
                                outputOffset += stride;
                                var value = propertyInfo.getValue(target, output, outputOffset, 1);
                                outputOffset += stride;
                                var outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  inTangent,
                                  value,
                                  outTangent
                                };
                              }
                              break;
                            }
                            case "LINEAR": {
                              for (var index = 0; index < input.length; index++) {
                                var value = propertyInfo.getValue(target, output, outputOffset, 1);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  value
                                };
                              }
                              break;
                            }
                          }
                          if (outputOffset > 0) {
                            var name_3 = "".concat(animation.name || "animation".concat(animation.index), "_channel").concat(channel.index, "_").concat(numAnimations);
                            var babylonAnimations = propertyInfo.buildAnimations(target, name_3, fps, keys);
                            for (var _a = 0, babylonAnimations_1 = babylonAnimations; _a < babylonAnimations_1.length; _a++) {
                              var babylonAnimation = babylonAnimations_1[_a];
                              numAnimations++;
                              onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);
                            }
                          }
                        }
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationSamplerAsync = function(context, sampler) {
                      if (sampler._data) {
                        return sampler._data;
                      }
                      var interpolation = sampler.interpolation || "LINEAR";
                      switch (interpolation) {
                        case "STEP":
                        case "LINEAR":
                        case "CUBICSPLINE": {
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, "/interpolation: Invalid value (").concat(sampler.interpolation, ")"));
                        }
                      }
                      var inputAccessor = ArrayItem.Get("".concat(context, "/input"), this._gltf.accessors, sampler.input);
                      var outputAccessor = ArrayItem.Get("".concat(context, "/output"), this._gltf.accessors, sampler.output);
                      sampler._data = Promise.all([
                        this._loadFloatAccessorAsync("/accessors/".concat(inputAccessor.index), inputAccessor),
                        this._loadFloatAccessorAsync("/accessors/".concat(outputAccessor.index), outputAccessor)
                      ]).then(function(_a) {
                        var inputData = _a[0], outputData = _a[1];
                        return {
                          input: inputData,
                          interpolation,
                          output: outputData
                        };
                      });
                      return sampler._data;
                    };
                    GLTFLoader2.prototype.loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (!buffer._data) {
                        if (buffer.uri) {
                          buffer._data = this.loadUriAsync("".concat(context, "/uri"), buffer, buffer.uri);
                        } else {
                          if (!this._bin) {
                            throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
                          }
                          buffer._data = this._bin.readAsync(0, buffer.byteLength);
                        }
                      }
                      return buffer._data.then(function(data) {
                        try {
                          return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
                        } catch (e) {
                          throw new Error("".concat(context, ": ").concat(e.message));
                        }
                      });
                    };
                    GLTFLoader2.prototype.loadBufferViewAsync = function(context, bufferView) {
                      var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (bufferView._data) {
                        return bufferView._data;
                      }
                      var buffer = ArrayItem.Get("".concat(context, "/buffer"), this._gltf.buffers, bufferView.buffer);
                      bufferView._data = this.loadBufferAsync("/buffers/".concat(buffer.index), buffer, bufferView.byteOffset || 0, bufferView.byteLength);
                      return bufferView._data;
                    };
                    GLTFLoader2.prototype._loadAccessorAsync = function(context, accessor, constructor) {
                      var _this = this;
                      if (accessor._data) {
                        return accessor._data;
                      }
                      var numComponents = GLTFLoader2._GetNumComponents(context, accessor.type);
                      var byteStride = numComponents * babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(accessor.componentType);
                      var length = numComponents * accessor.count;
                      if (accessor.bufferView == void 0) {
                        accessor._data = Promise.resolve(new constructor(length));
                      } else {
                        var bufferView_1 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView_1.index), bufferView_1).then(function(data) {
                          if (accessor.componentType === 5126 && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {
                            return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
                          } else {
                            var typedArray_1 = new constructor(length);
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function(value, index) {
                              typedArray_1[index] = value;
                            });
                            return typedArray_1;
                          }
                        });
                      }
                      if (accessor.sparse) {
                        var sparse_1 = accessor.sparse;
                        accessor._data = accessor._data.then(function(data) {
                          var typedArray = data;
                          var indicesBufferView = ArrayItem.Get("".concat(context, "/sparse/indices/bufferView"), _this._gltf.bufferViews, sparse_1.indices.bufferView);
                          var valuesBufferView = ArrayItem.Get("".concat(context, "/sparse/values/bufferView"), _this._gltf.bufferViews, sparse_1.values.bufferView);
                          return Promise.all([
                            _this.loadBufferViewAsync("/bufferViews/".concat(indicesBufferView.index), indicesBufferView),
                            _this.loadBufferViewAsync("/bufferViews/".concat(valuesBufferView.index), valuesBufferView)
                          ]).then(function(_a) {
                            var indicesData = _a[0], valuesData = _a[1];
                            var indices = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/indices"), sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);
                            var sparseLength = numComponents * sparse_1.count;
                            var values;
                            if (accessor.componentType === 5126 && !accessor.normalized) {
                              values = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                            } else {
                              var sparseData = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                              values = new constructor(sparseLength);
                              babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function(value, index) {
                                values[index] = value;
                              });
                            }
                            var valuesIndex = 0;
                            for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
                              var dataIndex = indices[indicesIndex] * numComponents;
                              for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {
                                typedArray[dataIndex++] = values[valuesIndex++];
                              }
                            }
                            return typedArray;
                          });
                        });
                      }
                      return accessor._data;
                    };
                    GLTFLoader2.prototype._loadFloatAccessorAsync = function(context, accessor) {
                      return this._loadAccessorAsync(context, accessor, Float32Array);
                    };
                    GLTFLoader2.prototype._loadIndicesAccessorAsync = function(context, accessor) {
                      if (accessor.type !== "SCALAR") {
                        throw new Error("".concat(context, "/type: Invalid value ").concat(accessor.type));
                      }
                      if (accessor.componentType !== 5121 && accessor.componentType !== 5123 && accessor.componentType !== 5125) {
                        throw new Error("".concat(context, "/componentType: Invalid value ").concat(accessor.componentType));
                      }
                      if (accessor._data) {
                        return accessor._data;
                      }
                      if (accessor.sparse) {
                        var constructor = GLTFLoader2._GetTypedArrayConstructor("".concat(context, "/componentType"), accessor.componentType);
                        accessor._data = this._loadAccessorAsync(context, accessor, constructor);
                      } else {
                        var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                          return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
                        });
                      }
                      return accessor._data;
                    };
                    GLTFLoader2.prototype._loadVertexBufferViewAsync = function(bufferView) {
                      if (bufferView._babylonBuffer) {
                        return bufferView._babylonBuffer;
                      }
                      var engine = this._babylonScene.getEngine();
                      bufferView._babylonBuffer = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                        return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Buffer(engine, data, false);
                      });
                      return bufferView._babylonBuffer;
                    };
                    GLTFLoader2.prototype._loadVertexAccessorAsync = function(context, accessor, kind) {
                      var _a;
                      if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {
                        return accessor._babylonVertexBuffer[kind];
                      }
                      if (!accessor._babylonVertexBuffer) {
                        accessor._babylonVertexBuffer = {};
                      }
                      var engine = this._babylonScene.getEngine();
                      if (accessor.sparse || accessor.bufferView == void 0) {
                        accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(function(data) {
                          return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, data, kind, false);
                        });
                      } else {
                        var bufferView_2 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView_2).then(function(babylonBuffer) {
                          var numComponents = GLTFLoader2._GetNumComponents(context, accessor.type);
                          return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, babylonBuffer, kind, false, void 0, bufferView_2.byteStride, void 0, accessor.byteOffset, numComponents, accessor.componentType, accessor.normalized, true, void 0, true);
                        });
                      }
                      return accessor._babylonVertexBuffer[kind];
                    };
                    GLTFLoader2.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      if (properties) {
                        if (properties.baseColorFactor) {
                          babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                          babylonMaterial.alpha = properties.baseColorFactor[3];
                        } else {
                          babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                        }
                        babylonMaterial.metallic = properties.metallicFactor == void 0 ? 1 : properties.metallicFactor;
                        babylonMaterial.roughness = properties.roughnessFactor == void 0 ? 1 : properties.roughnessFactor;
                        if (properties.baseColorTexture) {
                          promises.push(this.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                            babylonMaterial.albedoTexture = texture;
                          }));
                        }
                        if (properties.metallicRoughnessTexture) {
                          properties.metallicRoughnessTexture.nonColorData = true;
                          promises.push(this.loadTextureInfoAsync("".concat(context, "/metallicRoughnessTexture"), properties.metallicRoughnessTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Metallic Roughness)");
                            babylonMaterial.metallicTexture = texture;
                          }));
                          babylonMaterial.useMetallnessFromMetallicTextureBlue = true;
                          babylonMaterial.useRoughnessFromMetallicTextureGreen = true;
                          babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;
                        }
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      material._data = material._data || {};
                      var babylonData = material._data[babylonDrawMode];
                      if (!babylonData) {
                        this.logOpen("".concat(context, " ").concat(material.name || ""));
                        var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
                        babylonData = {
                          babylonMaterial,
                          babylonMeshes: [],
                          promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)
                        };
                        material._data[babylonDrawMode] = babylonData;
                        GLTFLoader2.AddPointerMetadata(babylonMaterial, context);
                        this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
                        this.logClose();
                      }
                      if (babylonMesh) {
                        babylonData.babylonMeshes.push(babylonMesh);
                        babylonMesh.onDisposeObservable.addOnce(function() {
                          var index = babylonData.babylonMeshes.indexOf(babylonMesh);
                          if (index !== -1) {
                            babylonData.babylonMeshes.splice(index, 1);
                          }
                        });
                      }
                      assign(babylonData.babylonMaterial);
                      return babylonData.promise.then(function() {
                        return babylonData.babylonMaterial;
                      });
                    };
                    GLTFLoader2.prototype._createDefaultMaterial = function(name2, babylonDrawMode) {
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonMaterial = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial(name2, this._babylonScene);
                      babylonMaterial._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonMaterial.fillMode = babylonDrawMode;
                      babylonMaterial.enableSpecularAntiAliasing = true;
                      babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;
                      babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;
                      babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
                      babylonMaterial.metallic = 1;
                      babylonMaterial.roughness = 1;
                      return babylonMaterial;
                    };
                    GLTFLoader2.prototype.createMaterial = function(context, material, babylonDrawMode) {
                      var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var name2 = material.name || "material".concat(material.index);
                      var babylonMaterial = this._createDefaultMaterial(name2, babylonDrawMode);
                      return babylonMaterial;
                    };
                    GLTFLoader2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                      if (material.pbrMetallicRoughness) {
                        promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync("".concat(context, "/pbrMetallicRoughness"), material.pbrMetallicRoughness, babylonMaterial));
                      }
                      this.loadMaterialAlphaProperties(context, material, babylonMaterial);
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadMaterialBasePropertiesAsync = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.emissiveColor = material.emissiveFactor ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(material.emissiveFactor) : new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3(0, 0, 0);
                      if (material.doubleSided) {
                        babylonMaterial.backFaceCulling = false;
                        babylonMaterial.twoSidedLighting = true;
                      }
                      if (material.normalTexture) {
                        material.normalTexture.nonColorData = true;
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/normalTexture"), material.normalTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Normal)");
                          babylonMaterial.bumpTexture = texture;
                        }));
                        babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;
                        babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;
                        if (material.normalTexture.scale != void 0 && babylonMaterial.bumpTexture) {
                          babylonMaterial.bumpTexture.level = material.normalTexture.scale;
                        }
                        babylonMaterial.forceIrradianceInFragment = true;
                      }
                      if (material.occlusionTexture) {
                        material.occlusionTexture.nonColorData = true;
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/occlusionTexture"), material.occlusionTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Occlusion)");
                          babylonMaterial.ambientTexture = texture;
                        }));
                        babylonMaterial.useAmbientInGrayScale = true;
                        if (material.occlusionTexture.strength != void 0) {
                          babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;
                        }
                      }
                      if (material.emissiveTexture) {
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/emissiveTexture"), material.emissiveTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Emissive)");
                          babylonMaterial.emissiveTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadMaterialAlphaProperties = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var alphaMode = material.alphaMode || "OPAQUE";
                      switch (alphaMode) {
                        case "OPAQUE": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
                          babylonMaterial.alpha = 1;
                          break;
                        }
                        case "MASK": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHATEST;
                          babylonMaterial.alphaCutOff = material.alphaCutoff == void 0 ? 0.5 : material.alphaCutoff;
                          if (babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoTexture.hasAlpha = true;
                          }
                          break;
                        }
                        case "BLEND": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHABLEND;
                          if (babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoTexture.hasAlpha = true;
                            babylonMaterial.useAlphaFromAlbedoTexture = true;
                          }
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, "/alphaMode: Invalid value (").concat(material.alphaMode, ")"));
                        }
                      }
                    };
                    GLTFLoader2.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
                      var _this = this;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context));
                      if (textureInfo.texCoord >= 6) {
                        throw new Error("".concat(context, "/texCoord: Invalid value (").concat(textureInfo.texCoord, ")"));
                      }
                      var texture = ArrayItem.Get("".concat(context, "/index"), this._gltf.textures, textureInfo.index);
                      texture._textureInfo = textureInfo;
                      var promise = this._loadTextureAsync("/textures/".concat(textureInfo.index), texture, function(babylonTexture) {
                        babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
                        GLTFLoader2.AddPointerMetadata(babylonTexture, context);
                        _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
                        assign(babylonTexture);
                      });
                      this.logClose();
                      return promise;
                    };
                    GLTFLoader2.prototype._loadTextureAsync = function(context, texture, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context, " ").concat(texture.name || ""));
                      var sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get("".concat(context, "/sampler"), this._gltf.samplers, texture.sampler);
                      var image = ArrayItem.Get("".concat(context, "/source"), this._gltf.images, texture.source);
                      var promise = this._createTextureAsync(context, sampler, image, assign, void 0, !texture._textureInfo.nonColorData);
                      this.logClose();
                      return promise;
                    };
                    GLTFLoader2.prototype._createTextureAsync = function(context, sampler, image, assign, textureLoaderOptions, useSRGBBuffer) {
                      var _this = this;
                      var _a, _b;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var samplerData = this._loadSampler("/samplers/".concat(sampler.index), sampler);
                      var promises = new Array();
                      var deferred = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var textureCreationOptions = {
                        noMipmap: samplerData.noMipMaps,
                        invertY: false,
                        samplingMode: samplerData.samplingMode,
                        onLoad: function() {
                          if (!_this._disposed) {
                            deferred.resolve();
                          }
                        },
                        onError: function(message, exception) {
                          if (!_this._disposed) {
                            deferred.reject(new Error("".concat(context, ": ").concat(exception && exception.message ? exception.message : message || "Failed to load texture")));
                          }
                        },
                        mimeType: (_a = image.mimeType) !== null && _a !== void 0 ? _a : (0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.GetMimeType)((_b = image.uri) !== null && _b !== void 0 ? _b : ""),
                        loaderOptions: textureLoaderOptions,
                        useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers
                      };
                      var babylonTexture = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture(null, this._babylonScene, textureCreationOptions);
                      babylonTexture._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      promises.push(deferred.promise);
                      promises.push(this.loadImageAsync("/images/".concat(image.index), image).then(function(data) {
                        var name2 = image.uri || "".concat(_this._fileName, "#image").concat(image.index);
                        var dataUrl = "data:".concat(_this._uniqueRootUrl).concat(name2);
                        babylonTexture.updateURL(dataUrl, data);
                        var internalTexture = babylonTexture.getInternalTexture();
                        if (internalTexture) {
                          internalTexture.label = image.name;
                        }
                      }));
                      babylonTexture.wrapU = samplerData.wrapU;
                      babylonTexture.wrapV = samplerData.wrapV;
                      assign(babylonTexture);
                      if (this._parent.useGltfTextureNames) {
                        babylonTexture.name = image.name || image.uri || "image".concat(image.index);
                      }
                      return Promise.all(promises).then(function() {
                        return babylonTexture;
                      });
                    };
                    GLTFLoader2.prototype._loadSampler = function(context, sampler) {
                      if (!sampler._data) {
                        sampler._data = {
                          noMipMaps: sampler.minFilter === 9728 || sampler.minFilter === 9729,
                          samplingMode: GLTFLoader2._GetTextureSamplingMode(context, sampler),
                          wrapU: GLTFLoader2._GetTextureWrapMode("".concat(context, "/wrapS"), sampler.wrapS),
                          wrapV: GLTFLoader2._GetTextureWrapMode("".concat(context, "/wrapT"), sampler.wrapT)
                        };
                      }
                      return sampler._data;
                    };
                    GLTFLoader2.prototype.loadImageAsync = function(context, image) {
                      if (!image._data) {
                        this.logOpen("".concat(context, " ").concat(image.name || ""));
                        if (image.uri) {
                          image._data = this.loadUriAsync("".concat(context, "/uri"), image, image.uri);
                        } else {
                          var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, image.bufferView);
                          image._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
                        }
                        this.logClose();
                      }
                      return image._data;
                    };
                    GLTFLoader2.prototype.loadUriAsync = function(context, property, uri) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (!GLTFLoader2._ValidateUri(uri)) {
                        throw new Error("".concat(context, ": '").concat(uri, "' is invalid"));
                      }
                      if ((0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.IsBase64DataUrl)(uri)) {
                        var data = new Uint8Array((0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(uri));
                        this.log("".concat(context, ": Decoded ").concat(uri.substring(0, 64), "... (").concat(data.length, " bytes)"));
                        return Promise.resolve(data);
                      }
                      this.log("".concat(context, ": Loading ").concat(uri));
                      return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function(url) {
                        return new Promise(function(resolve, reject) {
                          _this._parent._loadFile(_this._babylonScene, url, function(data2) {
                            if (!_this._disposed) {
                              _this.log("".concat(context, ": Loaded ").concat(uri, " (").concat(data2.byteLength, " bytes)"));
                              resolve(new Uint8Array(data2));
                            }
                          }, true, function(request) {
                            reject(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.LoadFileError("".concat(context, ": Failed to load '").concat(uri, "'").concat(request ? ": " + request.status + " " + request.statusText : ""), request));
                          });
                        });
                      });
                    };
                    GLTFLoader2.AddPointerMetadata = function(babylonObject, pointer) {
                      babylonObject.metadata = babylonObject.metadata || {};
                      var metadata = babylonObject._internalMetadata = babylonObject._internalMetadata || {};
                      var gltf = metadata.gltf = metadata.gltf || {};
                      var pointers = gltf.pointers = gltf.pointers || [];
                      pointers.push(pointer);
                    };
                    GLTFLoader2._GetTextureWrapMode = function(context, mode) {
                      mode = mode == void 0 ? 10497 : mode;
                      switch (mode) {
                        case 33071:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.CLAMP_ADDRESSMODE;
                        case 33648:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.MIRROR_ADDRESSMODE;
                        case 10497:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
                        default:
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Invalid value (").concat(mode, ")"));
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
                      }
                    };
                    GLTFLoader2._GetTextureSamplingMode = function(context, sampler) {
                      var magFilter = sampler.magFilter == void 0 ? 9729 : sampler.magFilter;
                      var minFilter = sampler.minFilter == void 0 ? 9987 : sampler.minFilter;
                      if (magFilter === 9729) {
                        switch (minFilter) {
                          case 9728:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST;
                          case 9729:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR;
                          case 9984:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPNEAREST;
                          case 9985:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPNEAREST;
                          case 9986:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPLINEAR;
                          case 9987:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
                          default:
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
                        }
                      } else {
                        if (magFilter !== 9728) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/magFilter: Invalid value (").concat(magFilter, ")"));
                        }
                        switch (minFilter) {
                          case 9728:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST;
                          case 9729:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR;
                          case 9984:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
                          case 9985:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPNEAREST;
                          case 9986:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPLINEAR;
                          case 9987:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPLINEAR;
                          default:
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
                        }
                      }
                    };
                    GLTFLoader2._GetTypedArrayConstructor = function(context, componentType) {
                      try {
                        return (0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.GetTypedArrayConstructor)(componentType);
                      } catch (e) {
                        throw new Error("".concat(context, ": ").concat(e.message));
                      }
                    };
                    GLTFLoader2._GetTypedArray = function(context, componentType, bufferView, byteOffset, length) {
                      var buffer = bufferView.buffer;
                      byteOffset = bufferView.byteOffset + (byteOffset || 0);
                      var constructor = GLTFLoader2._GetTypedArrayConstructor("".concat(context, "/componentType"), componentType);
                      var componentTypeLength = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(componentType);
                      if (byteOffset % componentTypeLength !== 0) {
                        babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Copying buffer as byte offset (").concat(byteOffset, ") is not a multiple of component type byte length (").concat(componentTypeLength, ")"));
                        return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);
                      }
                      return new constructor(buffer, byteOffset, length);
                    };
                    GLTFLoader2._GetNumComponents = function(context, type) {
                      switch (type) {
                        case "SCALAR":
                          return 1;
                        case "VEC2":
                          return 2;
                        case "VEC3":
                          return 3;
                        case "VEC4":
                          return 4;
                        case "MAT2":
                          return 4;
                        case "MAT3":
                          return 9;
                        case "MAT4":
                          return 16;
                      }
                      throw new Error("".concat(context, ": Invalid type (").concat(type, ")"));
                    };
                    GLTFLoader2._ValidateUri = function(uri) {
                      return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.IsBase64(uri) || uri.indexOf("..") === -1;
                    };
                    GLTFLoader2._GetDrawMode = function(context, mode) {
                      if (mode == void 0) {
                        mode = 4;
                      }
                      switch (mode) {
                        case 0:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.PointListDrawMode;
                        case 1:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineListDrawMode;
                        case 2:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineLoopDrawMode;
                        case 3:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineStripDrawMode;
                        case 4:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
                        case 5:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleStripDrawMode;
                        case 6:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFanDrawMode;
                      }
                      throw new Error("".concat(context, ": Invalid mesh primitive mode (").concat(mode, ")"));
                    };
                    GLTFLoader2.prototype._compileMaterialsAsync = function() {
                      var _this = this;
                      this._parent._startPerformanceCounter("Compile materials");
                      var promises = new Array();
                      if (this._gltf.materials) {
                        for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {
                          var material = _a[_i];
                          if (material._data) {
                            for (var babylonDrawMode in material._data) {
                              var babylonData = material._data[babylonDrawMode];
                              for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {
                                var babylonMesh = _c[_b];
                                babylonMesh.computeWorldMatrix(true);
                                var babylonMaterial = babylonData.babylonMaterial;
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
                                if (this._parent.useClipPlane) {
                                  promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                                  promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
                                }
                              }
                            }
                          }
                        }
                      }
                      return Promise.all(promises).then(function() {
                        _this._parent._endPerformanceCounter("Compile materials");
                      });
                    };
                    GLTFLoader2.prototype._compileShadowGeneratorsAsync = function() {
                      var _this = this;
                      this._parent._startPerformanceCounter("Compile shadow generators");
                      var promises = new Array();
                      var lights = this._babylonScene.lights;
                      for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                        var light = lights_1[_i];
                        var generator = light.getShadowGenerator();
                        if (generator) {
                          promises.push(generator.forceCompilationAsync());
                        }
                      }
                      return Promise.all(promises).then(function() {
                        _this._parent._endPerformanceCounter("Compile shadow generators");
                      });
                    };
                    GLTFLoader2.prototype._forEachExtensions = function(action) {
                      for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
                        var extension = _a[_i];
                        if (extension.enabled) {
                          action(extension);
                        }
                      }
                    };
                    GLTFLoader2.prototype._applyExtensions = function(property, functionName, actionAsync) {
                      for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
                        var extension = _a[_i];
                        if (extension.enabled) {
                          var id = "".concat(extension.name, ".").concat(functionName);
                          var loaderProperty = property;
                          loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
                          var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
                          if (!activeLoaderExtensionFunctions[id]) {
                            activeLoaderExtensionFunctions[id] = true;
                            try {
                              var result = actionAsync(extension);
                              if (result) {
                                return result;
                              }
                            } finally {
                              delete activeLoaderExtensionFunctions[id];
                            }
                          }
                        }
                      }
                      return null;
                    };
                    GLTFLoader2.prototype._extensionsOnLoading = function() {
                      this._forEachExtensions(function(extension) {
                        return extension.onLoading && extension.onLoading();
                      });
                    };
                    GLTFLoader2.prototype._extensionsOnReady = function() {
                      this._forEachExtensions(function(extension) {
                        return extension.onReady && extension.onReady();
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadSceneAsync = function(context, scene) {
                      return this._applyExtensions(scene, "loadScene", function(extension) {
                        return extension.loadSceneAsync && extension.loadSceneAsync(context, scene);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadNodeAsync = function(context, node, assign) {
                      return this._applyExtensions(node, "loadNode", function(extension) {
                        return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadCameraAsync = function(context, camera, assign) {
                      return this._applyExtensions(camera, "loadCamera", function(extension) {
                        return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadVertexDataAsync = function(context, primitive, babylonMesh) {
                      return this._applyExtensions(primitive, "loadVertexData", function(extension) {
                        return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMeshPrimitiveAsync = function(context, name2, node, mesh, primitive, assign) {
                      return this._applyExtensions(primitive, "loadMeshPrimitive", function(extension) {
                        return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      return this._applyExtensions(material, "loadMaterial", function(extension) {
                        return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsCreateMaterial = function(context, material, babylonDrawMode) {
                      return this._applyExtensions(material, "createMaterial", function(extension) {
                        return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      return this._applyExtensions(material, "loadMaterialProperties", function(extension) {
                        return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadTextureInfoAsync = function(context, textureInfo, assign) {
                      return this._applyExtensions(textureInfo, "loadTextureInfo", function(extension) {
                        return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadTextureAsync = function(context, texture, assign) {
                      return this._applyExtensions(texture, "loadTexture", function(extension) {
                        return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadAnimationAsync = function(context, animation) {
                      return this._applyExtensions(animation, "loadAnimation", function(extension) {
                        return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      return this._applyExtensions(animation, "loadAnimationChannel", function(extension) {
                        return extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadSkinAsync = function(context, node, skin) {
                      return this._applyExtensions(skin, "loadSkin", function(extension) {
                        return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadUriAsync = function(context, property, uri) {
                      return this._applyExtensions(property, "loadUri", function(extension) {
                        return extension._loadUriAsync && extension._loadUriAsync(context, property, uri);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadBufferViewAsync = function(context, bufferView) {
                      return this._applyExtensions(bufferView, "loadBufferView", function(extension) {
                        return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      return this._applyExtensions(buffer, "loadBuffer", function(extension) {
                        return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength);
                      });
                    };
                    GLTFLoader2.LoadExtensionAsync = function(context, property, extensionName, actionAsync) {
                      if (!property.extensions) {
                        return null;
                      }
                      var extensions = property.extensions;
                      var extension = extensions[extensionName];
                      if (!extension) {
                        return null;
                      }
                      return actionAsync("".concat(context, "/extensions/").concat(extensionName), extension);
                    };
                    GLTFLoader2.LoadExtraAsync = function(context, property, extensionName, actionAsync) {
                      if (!property.extras) {
                        return null;
                      }
                      var extras = property.extras;
                      var extra = extras[extensionName];
                      if (!extra) {
                        return null;
                      }
                      return actionAsync("".concat(context, "/extras/").concat(extensionName), extra);
                    };
                    GLTFLoader2.prototype.isExtensionUsed = function(name2) {
                      return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name2) !== -1;
                    };
                    GLTFLoader2.prototype.logOpen = function(message) {
                      this._parent._logOpen(message);
                    };
                    GLTFLoader2.prototype.logClose = function() {
                      this._parent._logClose();
                    };
                    GLTFLoader2.prototype.log = function(message) {
                      this._parent._log(message);
                    };
                    GLTFLoader2.prototype.startPerformanceCounter = function(counterName) {
                      this._parent._startPerformanceCounter(counterName);
                    };
                    GLTFLoader2.prototype.endPerformanceCounter = function(counterName) {
                      this._parent._endPerformanceCounter(counterName);
                    };
                    GLTFLoader2.DefaultSampler = { index: -1 };
                    return GLTFLoader2;
                  }()
                );
                _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFFileLoader._CreateGLTF2Loader = function(parent) {
                  return new GLTFLoader(parent);
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  AnimationPropertyInfo: () => (
                    /* binding */
                    AnimationPropertyInfo
                  ),
                  /* harmony export */
                  TransformNodeAnimationPropertyInfo: () => (
                    /* binding */
                    TransformNodeAnimationPropertyInfo
                  ),
                  /* harmony export */
                  WeightAnimationPropertyInfo: () => (
                    /* binding */
                    WeightAnimationPropertyInfo
                  ),
                  /* harmony export */
                  getQuaternion: () => (
                    /* binding */
                    getQuaternion
                  ),
                  /* harmony export */
                  getVector3: () => (
                    /* binding */
                    getVector3
                  ),
                  /* harmony export */
                  getWeights: () => (
                    /* binding */
                    getWeights
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.vector */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
                var _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./Extensions/objectModelMapping */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"
                );
                function getVector3(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(source, offset).scaleInPlace(scale);
                }
                function getQuaternion(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(source, offset).scaleInPlace(scale);
                }
                function getWeights(target, source, offset, scale) {
                  var value = new Array(target._numMorphTargets);
                  for (var i = 0; i < value.length; i++) {
                    value[i] = source[offset++] * scale;
                  }
                  return value;
                }
                var AnimationPropertyInfo = (
                  /** @class */
                  function() {
                    function AnimationPropertyInfo2(type, name2, getValue, getStride) {
                      this.type = type;
                      this.name = name2;
                      this.getValue = getValue;
                      this.getStride = getStride;
                    }
                    AnimationPropertyInfo2.prototype._buildAnimation = function(name2, fps, keys) {
                      var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation(name2, this.name, fps, this.type);
                      babylonAnimation.setKeys(keys);
                      return babylonAnimation;
                    };
                    return AnimationPropertyInfo2;
                  }()
                );
                var TransformNodeAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TransformNodeAnimationPropertyInfo2, _super);
                    function TransformNodeAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    TransformNodeAnimationPropertyInfo2.prototype.buildAnimations = function(target, name2, fps, keys) {
                      var babylonAnimations = [];
                      babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode, babylonAnimation: this._buildAnimation(name2, fps, keys) });
                      return babylonAnimations;
                    };
                    return TransformNodeAnimationPropertyInfo2;
                  }(AnimationPropertyInfo)
                );
                var WeightAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(WeightAnimationPropertyInfo2, _super);
                    function WeightAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    WeightAnimationPropertyInfo2.prototype.buildAnimations = function(target, name2, fps, keys) {
                      var babylonAnimations = [];
                      if (target._numMorphTargets) {
                        var _loop_1 = function(targetIndex2) {
                          var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation("".concat(name2, "_").concat(targetIndex2), this_1.name, fps, this_1.type);
                          babylonAnimation.setKeys(keys.map(function(key) {
                            return {
                              frame: key.frame,
                              inTangent: key.inTangent ? key.inTangent[targetIndex2] : void 0,
                              value: key.value[targetIndex2],
                              outTangent: key.outTangent ? key.outTangent[targetIndex2] : void 0,
                              interpolation: key.interpolation
                            };
                          }));
                          if (target._primitiveBabylonMeshes) {
                            for (var _i = 0, _a = target._primitiveBabylonMeshes; _i < _a.length; _i++) {
                              var babylonMesh = _a[_i];
                              if (babylonMesh.morphTargetManager) {
                                var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex2);
                                var babylonAnimationClone = babylonAnimation.clone();
                                morphTarget.animations.push(babylonAnimationClone);
                                babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });
                              }
                            }
                          }
                        };
                        var this_1 = this;
                        for (var targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {
                          _loop_1(targetIndex);
                        }
                      }
                      return babylonAnimations;
                    };
                    return WeightAnimationPropertyInfo2;
                  }(AnimationPropertyInfo)
                );
                (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/translation", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "position", getVector3, function() {
                  return 3;
                })]);
                (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/rotation", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", getQuaternion, function() {
                  return 4;
                })]);
                (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/scale", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "scaling", getVector3, function() {
                  return 3;
                })]);
                (0, _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/weights", [new WeightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "influence", getWeights, function(target) {
                  return target._numMorphTargets;
                })]);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  registerGLTFExtension: () => (
                    /* binding */
                    registerGLTFExtension
                  ),
                  /* harmony export */
                  registeredGLTFExtensions: () => (
                    /* binding */
                    registeredGLTFExtensions
                  ),
                  /* harmony export */
                  unregisterGLTFExtension: () => (
                    /* binding */
                    unregisterGLTFExtension
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/logger */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);
                var _registeredGLTFExtensions = /* @__PURE__ */ new Map();
                var registeredGLTFExtensions = _registeredGLTFExtensions;
                function registerGLTFExtension(name2, isGLTFExtension, factory) {
                  if (unregisterGLTFExtension(name2)) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Extension with the name '".concat(name2, "' already exists"));
                  }
                  _registeredGLTFExtensions.set(name2, {
                    isGLTFExtension,
                    factory
                  });
                }
                function unregisterGLTFExtension(name2) {
                  return _registeredGLTFExtensions.delete(name2);
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts": (
              /*!*****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts ***!
                \*****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/index.ts": (
              /*!**************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/index.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  AddObjectAccessorToKey: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.AddObjectAccessorToKey
                  ),
                  /* harmony export */
                  AnimationPropertyInfo: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.AnimationPropertyInfo
                  ),
                  /* harmony export */
                  ArrayItem: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem
                  ),
                  /* harmony export */
                  EXT_lights_ies: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_lights_ies
                  ),
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_lights_image_based
                  ),
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_mesh_gpu_instancing
                  ),
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_meshopt_compression
                  ),
                  /* harmony export */
                  EXT_texture_avif: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_avif
                  ),
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_webp
                  ),
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.ExtrasAsMetadata
                  ),
                  /* harmony export */
                  FlowGraphGLTFDataProvider: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.FlowGraphGLTFDataProvider
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader
                  ),
                  /* harmony export */
                  GetMappingForKey: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.GetMappingForKey
                  ),
                  /* harmony export */
                  GetPathToObjectConverter: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.GetPathToObjectConverter
                  ),
                  /* harmony export */
                  InteractivityGraphToFlowGraphParser: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.InteractivityGraphToFlowGraphParser
                  ),
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_animation_pointer
                  ),
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_draco_mesh_compression
                  ),
                  /* harmony export */
                  KHR_interactivity: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_interactivity
                  ),
                  /* harmony export */
                  KHR_lights: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_lights
                  ),
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_anisotropy
                  ),
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_clearcoat
                  ),
                  /* harmony export */
                  KHR_materials_diffuse_transmission: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_diffuse_transmission
                  ),
                  /* harmony export */
                  KHR_materials_dispersion: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_dispersion
                  ),
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_emissive_strength
                  ),
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_ior
                  ),
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_iridescence
                  ),
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_pbrSpecularGlossiness
                  ),
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_sheen
                  ),
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_specular
                  ),
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_transmission
                  ),
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_unlit
                  ),
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_variants
                  ),
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_volume
                  ),
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_mesh_quantization
                  ),
                  /* harmony export */
                  KHR_node_hoverability: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_hoverability
                  ),
                  /* harmony export */
                  KHR_node_selectability: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_selectability
                  ),
                  /* harmony export */
                  KHR_node_visibility: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_visibility
                  ),
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_texture_basisu
                  ),
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_texture_transform
                  ),
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_xmp_json_ld
                  ),
                  /* harmony export */
                  LoadBoundingInfoFromPositionAccessor: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.LoadBoundingInfoFromPositionAccessor
                  ),
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_audio_emitter
                  ),
                  /* harmony export */
                  MSFT_lod: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_lod
                  ),
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_minecraftMesh
                  ),
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_sRGBFactors
                  ),
                  /* harmony export */
                  SetInterpolationForKey: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.SetInterpolationForKey
                  ),
                  /* harmony export */
                  TransformNodeAnimationPropertyInfo: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.TransformNodeAnimationPropertyInfo
                  ),
                  /* harmony export */
                  WeightAnimationPropertyInfo: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.WeightAnimationPropertyInfo
                  ),
                  /* harmony export */
                  _AddInteractivityObjectModel: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__._AddInteractivityObjectModel
                  ),
                  /* harmony export */
                  addNewInteractivityFlowGraphMapping: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.addNewInteractivityFlowGraphMapping
                  ),
                  /* harmony export */
                  getAllSupportedNativeNodeTypes: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getAllSupportedNativeNodeTypes
                  ),
                  /* harmony export */
                  getMappingForDeclaration: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getMappingForDeclaration
                  ),
                  /* harmony export */
                  getMappingForFullOperationName: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getMappingForFullOperationName
                  ),
                  /* harmony export */
                  getQuaternion: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getQuaternion
                  ),
                  /* harmony export */
                  getVector3: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getVector3
                  ),
                  /* harmony export */
                  getWeights: () => (
                    /* reexport safe */
                    _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getWeights
                  ),
                  /* harmony export */
                  gltfTypeToBabylonType: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.gltfTypeToBabylonType
                  ),
                  /* harmony export */
                  registerGLTFExtension: () => (
                    /* reexport safe */
                    _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension
                  ),
                  /* harmony export */
                  registeredGLTFExtensions: () => (
                    /* reexport safe */
                    _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registeredGLTFExtensions
                  ),
                  /* harmony export */
                  unregisterGLTFExtension: () => (
                    /* reexport safe */
                    _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoaderExtension */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts"
                );
                var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderExtensionRegistry */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts"
                );
                var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./glTFLoaderAnimation */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"
                );
                var _Extensions_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./Extensions/index */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFFileLoaderMetadata: () => (
                    /* binding */
                    GLTFFileLoaderMetadata
                  ),
                  /* harmony export */
                  GLTFMagicBase64Encoded: () => (
                    /* binding */
                    GLTFMagicBase64Encoded
                  )
                  /* harmony export */
                });
                var GLTFMagicBase64Encoded = "Z2xURg";
                var GLTFFileLoaderMetadata = {
                  name: "gltf",
                  extensions: {
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".gltf": { isBinary: false, mimeType: "model/gltf+json" },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    ".glb": { isBinary: true, mimeType: "model/gltf-binary" }
                  },
                  canDirectLoad: function(data) {
                    return data.indexOf("asset") !== -1 && data.indexOf("version") !== -1 || data.startsWith("data:base64," + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
                    data.startsWith("data:;base64," + GLTFMagicBase64Encoded) || data.startsWith("data:application/octet-stream;base64," + GLTFMagicBase64Encoded) || data.startsWith("data:model/gltf-binary;base64," + GLTFMagicBase64Encoded);
                  }
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/glTFFileLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/glTFFileLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* binding */
                    GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* binding */
                    GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* binding */
                    GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* binding */
                    GLTFLoaderState
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/error */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                var _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFFileLoader.metadata */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts"
                );
                function readAsync(arrayBuffer, byteOffset, byteLength) {
                  try {
                    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
                  } catch (e) {
                    return Promise.reject(e);
                  }
                }
                function readViewAsync(arrayBufferView, byteOffset, byteLength) {
                  try {
                    if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {
                      throw new RangeError("Offset is out of range.");
                    }
                    if (byteOffset + byteLength > arrayBufferView.byteLength) {
                      throw new RangeError("Length is out of range.");
                    }
                    return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));
                  } catch (e) {
                    return Promise.reject(e);
                  }
                }
                var GLTFLoaderCoordinateSystemMode;
                (function(GLTFLoaderCoordinateSystemMode2) {
                  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["AUTO"] = 0] = "AUTO";
                  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
                })(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
                var GLTFLoaderAnimationStartMode;
                (function(GLTFLoaderAnimationStartMode2) {
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["NONE"] = 0] = "NONE";
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["FIRST"] = 1] = "FIRST";
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["ALL"] = 2] = "ALL";
                })(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
                var GLTFLoaderState;
                (function(GLTFLoaderState2) {
                  GLTFLoaderState2[GLTFLoaderState2["LOADING"] = 0] = "LOADING";
                  GLTFLoaderState2[GLTFLoaderState2["READY"] = 1] = "READY";
                  GLTFLoaderState2[GLTFLoaderState2["COMPLETE"] = 2] = "COMPLETE";
                })(GLTFLoaderState || (GLTFLoaderState = {}));
                var GLTFLoaderOptions = (
                  /** @class */
                  function() {
                    function GLTFLoaderOptions2() {
                      this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
                      this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
                      this.loadNodeAnimations = true;
                      this.loadSkins = true;
                      this.loadMorphTargets = true;
                      this.compileMaterials = false;
                      this.useClipPlane = false;
                      this.compileShadowGenerators = false;
                      this.transparencyAsCoverage = false;
                      this.useRangeRequests = false;
                      this.createInstances = true;
                      this.alwaysComputeBoundingBox = false;
                      this.loadAllMaterials = false;
                      this.loadOnlyMaterials = false;
                      this.skipMaterials = false;
                      this.useSRGBBuffers = true;
                      this.targetFps = 60;
                      this.alwaysComputeSkeletonRootNode = false;
                      this.useGltfTextureNames = false;
                      this.preprocessUrlAsync = function(url) {
                        return Promise.resolve(url);
                      };
                      this.extensionOptions = {};
                    }
                    GLTFLoaderOptions2.prototype.copyFrom = function(options) {
                      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
                      if (options) {
                        this.onParsed = options.onParsed;
                        this.coordinateSystemMode = (_a = options.coordinateSystemMode) !== null && _a !== void 0 ? _a : this.coordinateSystemMode;
                        this.animationStartMode = (_b = options.animationStartMode) !== null && _b !== void 0 ? _b : this.animationStartMode;
                        this.loadNodeAnimations = (_c = options.loadNodeAnimations) !== null && _c !== void 0 ? _c : this.loadNodeAnimations;
                        this.loadSkins = (_d = options.loadSkins) !== null && _d !== void 0 ? _d : this.loadSkins;
                        this.loadMorphTargets = (_e = options.loadMorphTargets) !== null && _e !== void 0 ? _e : this.loadMorphTargets;
                        this.compileMaterials = (_f = options.compileMaterials) !== null && _f !== void 0 ? _f : this.compileMaterials;
                        this.useClipPlane = (_g = options.useClipPlane) !== null && _g !== void 0 ? _g : this.useClipPlane;
                        this.compileShadowGenerators = (_h = options.compileShadowGenerators) !== null && _h !== void 0 ? _h : this.compileShadowGenerators;
                        this.transparencyAsCoverage = (_j = options.transparencyAsCoverage) !== null && _j !== void 0 ? _j : this.transparencyAsCoverage;
                        this.useRangeRequests = (_k = options.useRangeRequests) !== null && _k !== void 0 ? _k : this.useRangeRequests;
                        this.createInstances = (_l = options.createInstances) !== null && _l !== void 0 ? _l : this.createInstances;
                        this.alwaysComputeBoundingBox = (_m = options.alwaysComputeBoundingBox) !== null && _m !== void 0 ? _m : this.alwaysComputeBoundingBox;
                        this.loadAllMaterials = (_o = options.loadAllMaterials) !== null && _o !== void 0 ? _o : this.loadAllMaterials;
                        this.loadOnlyMaterials = (_p = options.loadOnlyMaterials) !== null && _p !== void 0 ? _p : this.loadOnlyMaterials;
                        this.skipMaterials = (_q = options.skipMaterials) !== null && _q !== void 0 ? _q : this.skipMaterials;
                        this.useSRGBBuffers = (_r = options.useSRGBBuffers) !== null && _r !== void 0 ? _r : this.useSRGBBuffers;
                        this.targetFps = (_s = options.targetFps) !== null && _s !== void 0 ? _s : this.targetFps;
                        this.alwaysComputeSkeletonRootNode = (_t = options.alwaysComputeSkeletonRootNode) !== null && _t !== void 0 ? _t : this.alwaysComputeSkeletonRootNode;
                        this.useGltfTextureNames = (_u = options.useGltfTextureNames) !== null && _u !== void 0 ? _u : this.useGltfTextureNames;
                        this.preprocessUrlAsync = (_v = options.preprocessUrlAsync) !== null && _v !== void 0 ? _v : this.preprocessUrlAsync;
                        this.customRootNode = options.customRootNode;
                        this.onMeshLoaded = options.onMeshLoaded;
                        this.onSkinLoaded = options.onSkinLoaded;
                        this.onTextureLoaded = options.onTextureLoaded;
                        this.onMaterialLoaded = options.onMaterialLoaded;
                        this.onCameraLoaded = options.onCameraLoaded;
                        this.extensionOptions = (_w = options.extensionOptions) !== null && _w !== void 0 ? _w : this.extensionOptions;
                      }
                    };
                    return GLTFLoaderOptions2;
                  }()
                );
                var GLTFFileLoader = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(GLTFFileLoader2, _super);
                    function GLTFFileLoader2(options) {
                      var _this = _super.call(this) || this;
                      _this.onParsedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onMeshLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onSkinLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onTextureLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onMaterialLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onCameraLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onCompleteObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onErrorObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onDisposeObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.onExtensionLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this.validate = false;
                      _this.onValidatedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this._loader = null;
                      _this._state = null;
                      _this._requests = new Array();
                      _this.name = _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.name;
                      _this.extensions = _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.extensions;
                      _this.onLoaderStateChangedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      _this._logIndentLevel = 0;
                      _this._loggingEnabled = false;
                      _this._log = _this._logDisabled;
                      _this._capturePerformanceCounters = false;
                      _this._startPerformanceCounter = _this._startPerformanceCounterDisabled;
                      _this._endPerformanceCounter = _this._endPerformanceCounterDisabled;
                      _this.copyFrom(options);
                      return _this;
                    }
                    Object.defineProperty(GLTFFileLoader2.prototype, "onParsed", {
                      /**
                       * Raised when the asset has been parsed
                       */
                      set: function(callback) {
                        if (this._onParsedObserver) {
                          this.onParsedObservable.remove(this._onParsedObserver);
                        }
                        if (callback) {
                          this._onParsedObserver = this.onParsedObservable.add(callback);
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onMeshLoaded", {
                      /**
                       * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
                       * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
                       */
                      set: function(callback) {
                        if (this._onMeshLoadedObserver) {
                          this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
                        }
                        if (callback) {
                          this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onSkinLoaded", {
                      /**
                       * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.
                       * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh
                       */
                      set: function(callback) {
                        if (this._onSkinLoadedObserver) {
                          this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);
                        }
                        if (callback) {
                          this._onSkinLoadedObserver = this.onSkinLoadedObservable.add(function(data) {
                            return callback(data.node, data.skinnedNode);
                          });
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onTextureLoaded", {
                      /**
                       * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
                       */
                      set: function(callback) {
                        if (this._onTextureLoadedObserver) {
                          this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
                        }
                        if (callback) {
                          this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onMaterialLoaded", {
                      /**
                       * Callback raised when the loader creates a material after parsing the glTF properties of the material.
                       */
                      set: function(callback) {
                        if (this._onMaterialLoadedObserver) {
                          this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
                        }
                        if (callback) {
                          this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onCameraLoaded", {
                      /**
                       * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
                       */
                      set: function(callback) {
                        if (this._onCameraLoadedObserver) {
                          this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
                        }
                        if (callback) {
                          this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onComplete", {
                      /**
                       * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
                       * For assets with LODs, raised when all of the LODs are complete.
                       * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
                       */
                      set: function(callback) {
                        if (this._onCompleteObserver) {
                          this.onCompleteObservable.remove(this._onCompleteObserver);
                        }
                        this._onCompleteObserver = this.onCompleteObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onError", {
                      /**
                       * Callback raised when an error occurs.
                       */
                      set: function(callback) {
                        if (this._onErrorObserver) {
                          this.onErrorObservable.remove(this._onErrorObserver);
                        }
                        this._onErrorObserver = this.onErrorObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onDispose", {
                      /**
                       * Callback raised after the loader is disposed.
                       */
                      set: function(callback) {
                        if (this._onDisposeObserver) {
                          this.onDisposeObservable.remove(this._onDisposeObserver);
                        }
                        this._onDisposeObserver = this.onDisposeObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onExtensionLoaded", {
                      /**
                       * Callback raised after a loader extension is created.
                       */
                      set: function(callback) {
                        if (this._onExtensionLoadedObserver) {
                          this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
                        }
                        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "loggingEnabled", {
                      /**
                       * Defines if the loader logging is enabled.
                       */
                      get: function() {
                        return this._loggingEnabled;
                      },
                      set: function(value) {
                        if (this._loggingEnabled === value) {
                          return;
                        }
                        this._loggingEnabled = value;
                        if (this._loggingEnabled) {
                          this._log = this._logEnabled;
                        } else {
                          this._log = this._logDisabled;
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "capturePerformanceCounters", {
                      /**
                       * Defines if the loader should capture performance counters.
                       */
                      get: function() {
                        return this._capturePerformanceCounters;
                      },
                      set: function(value) {
                        if (this._capturePerformanceCounters === value) {
                          return;
                        }
                        this._capturePerformanceCounters = value;
                        if (this._capturePerformanceCounters) {
                          this._startPerformanceCounter = this._startPerformanceCounterEnabled;
                          this._endPerformanceCounter = this._endPerformanceCounterEnabled;
                        } else {
                          this._startPerformanceCounter = this._startPerformanceCounterDisabled;
                          this._endPerformanceCounter = this._endPerformanceCounterDisabled;
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onValidated", {
                      /**
                       * Callback raised after a loader extension is created.
                       */
                      set: function(callback) {
                        if (this._onValidatedObserver) {
                          this.onValidatedObservable.remove(this._onValidatedObserver);
                        }
                        this._onValidatedObserver = this.onValidatedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFFileLoader2.prototype.dispose = function() {
                      if (this._loader) {
                        this._loader.dispose();
                        this._loader = null;
                      }
                      for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
                        var request = _a[_i];
                        request.abort();
                      }
                      this._requests.length = 0;
                      delete this._progressCallback;
                      this.preprocessUrlAsync = function(url) {
                        return Promise.resolve(url);
                      };
                      this.onMeshLoadedObservable.clear();
                      this.onSkinLoadedObservable.clear();
                      this.onTextureLoadedObservable.clear();
                      this.onMaterialLoadedObservable.clear();
                      this.onCameraLoadedObservable.clear();
                      this.onCompleteObservable.clear();
                      this.onExtensionLoadedObservable.clear();
                      this.onDisposeObservable.notifyObservers(void 0);
                      this.onDisposeObservable.clear();
                    };
                    GLTFFileLoader2.prototype.loadFile = function(scene, fileOrUrl, rootUrl, onSuccess, onProgress, useArrayBuffer, onError, name2) {
                      var _this = this;
                      if (ArrayBuffer.isView(fileOrUrl)) {
                        this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name2);
                        return null;
                      }
                      this._progressCallback = onProgress;
                      var fileName = fileOrUrl.name || babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.GetFilename(fileOrUrl);
                      if (useArrayBuffer) {
                        if (this.useRangeRequests) {
                          if (this.validate) {
                            babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("glTF validation is not supported when range requests are enabled");
                          }
                          var fileRequest_1 = {
                            abort: function() {
                            },
                            onCompleteObservable: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable()
                          };
                          var dataBuffer = {
                            readAsync: function(byteOffset, byteLength) {
                              return new Promise(function(resolve, reject) {
                                _this._loadFile(scene, fileOrUrl, function(data) {
                                  resolve(new Uint8Array(data));
                                }, true, function(error) {
                                  reject(error);
                                }, function(webRequest) {
                                  webRequest.setRequestHeader("Range", "bytes=".concat(byteOffset, "-").concat(byteOffset + byteLength - 1));
                                });
                              });
                            },
                            byteLength: 0
                          };
                          this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader(dataBuffer)).then(function(loaderData) {
                            fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
                            onSuccess(loaderData);
                          }, onError ? function(error) {
                            return onError(void 0, error);
                          } : void 0);
                          return fileRequest_1;
                        }
                        return this._loadFile(scene, fileOrUrl, function(data) {
                          _this._validate(scene, new Uint8Array(data, 0, data.byteLength), rootUrl, fileName);
                          _this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                            readAsync: function(byteOffset, byteLength) {
                              return readAsync(data, byteOffset, byteLength);
                            },
                            byteLength: data.byteLength
                          })).then(function(loaderData) {
                            onSuccess(loaderData);
                          }, onError ? function(error) {
                            return onError(void 0, error);
                          } : void 0);
                        }, true, onError);
                      } else {
                        return this._loadFile(scene, fileOrUrl, function(data) {
                          try {
                            _this._validate(scene, data, rootUrl, fileName);
                            onSuccess({ json: _this._parseJson(data) });
                          } catch (_a) {
                            if (onError) {
                              onError();
                            }
                          }
                        }, false, onError);
                      }
                    };
                    GLTFFileLoader2.prototype._loadBinary = function(scene, data, rootUrl, onSuccess, onError, fileName) {
                      this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);
                      this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                        readAsync: function(byteOffset, byteLength) {
                          return readViewAsync(data, byteOffset, byteLength);
                        },
                        byteLength: data.byteLength
                      })).then(function(loaderData) {
                        onSuccess(loaderData);
                      }, onError ? function(error) {
                        return onError(void 0, error);
                      } : void 0);
                    };
                    GLTFFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        return _this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);
                      });
                    };
                    GLTFFileLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
                      });
                    };
                    GLTFFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        var container = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                        var materials = [];
                        _this.onMaterialLoadedObservable.add(function(material) {
                          materials.push(material);
                        });
                        var textures = [];
                        _this.onTextureLoadedObservable.add(function(texture) {
                          textures.push(texture);
                        });
                        var cameras = [];
                        _this.onCameraLoadedObservable.add(function(camera) {
                          cameras.push(camera);
                        });
                        var morphTargetManagers = [];
                        _this.onMeshLoadedObservable.add(function(mesh) {
                          if (mesh.morphTargetManager) {
                            morphTargetManagers.push(mesh.morphTargetManager);
                          }
                        });
                        return _this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then(function(result) {
                          Array.prototype.push.apply(container.geometries, result.geometries);
                          Array.prototype.push.apply(container.meshes, result.meshes);
                          Array.prototype.push.apply(container.particleSystems, result.particleSystems);
                          Array.prototype.push.apply(container.skeletons, result.skeletons);
                          Array.prototype.push.apply(container.animationGroups, result.animationGroups);
                          Array.prototype.push.apply(container.materials, materials);
                          Array.prototype.push.apply(container.textures, textures);
                          Array.prototype.push.apply(container.lights, result.lights);
                          Array.prototype.push.apply(container.transformNodes, result.transformNodes);
                          Array.prototype.push.apply(container.cameras, cameras);
                          Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);
                          return container;
                        });
                      });
                    };
                    GLTFFileLoader2.prototype.canDirectLoad = function(data) {
                      return _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.canDirectLoad(data);
                    };
                    GLTFFileLoader2.prototype.directLoad = function(scene, data) {
                      if (data.startsWith("base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
                      data.startsWith(";base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) || data.startsWith("application/octet-stream;base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) || data.startsWith("model/gltf-binary;base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded)) {
                        var arrayBuffer_1 = (0, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(data);
                        this._validate(scene, new Uint8Array(arrayBuffer_1, 0, arrayBuffer_1.byteLength));
                        return this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                          readAsync: function(byteOffset, byteLength) {
                            return readAsync(arrayBuffer_1, byteOffset, byteLength);
                          },
                          byteLength: arrayBuffer_1.byteLength
                        }));
                      }
                      this._validate(scene, data);
                      return Promise.resolve({ json: this._parseJson(data) });
                    };
                    GLTFFileLoader2.prototype.createPlugin = function(options) {
                      return new GLTFFileLoader2(options[_glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.name]);
                    };
                    Object.defineProperty(GLTFFileLoader2.prototype, "loaderState", {
                      /**
                       * The loader state or null if the loader is not active.
                       */
                      get: function() {
                        return this._state;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFFileLoader2.prototype.whenCompleteAsync = function() {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this.onCompleteObservable.addOnce(function() {
                          resolve();
                        });
                        _this.onErrorObservable.addOnce(function(reason) {
                          reject(reason);
                        });
                      });
                    };
                    GLTFFileLoader2.prototype._setState = function(state) {
                      if (this._state === state) {
                        return;
                      }
                      this._state = state;
                      this.onLoaderStateChangedObservable.notifyObservers(this._state);
                      this._log(GLTFLoaderState[this._state]);
                    };
                    GLTFFileLoader2.prototype._loadFile = function(scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {
                      var _this = this;
                      var request = scene._loadFile(fileOrUrl, onSuccess, function(event) {
                        _this._onProgress(event, request);
                      }, true, useArrayBuffer, onError, onOpened);
                      request.onCompleteObservable.add(function() {
                        request._lengthComputable = true;
                        request._total = request._loaded;
                      });
                      this._requests.push(request);
                      return request;
                    };
                    GLTFFileLoader2.prototype._onProgress = function(event, request) {
                      if (!this._progressCallback) {
                        return;
                      }
                      request._lengthComputable = event.lengthComputable;
                      request._loaded = event.loaded;
                      request._total = event.total;
                      var lengthComputable = true;
                      var loaded = 0;
                      var total = 0;
                      for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
                        var request_1 = _a[_i];
                        if (request_1._lengthComputable === void 0 || request_1._loaded === void 0 || request_1._total === void 0) {
                          return;
                        }
                        lengthComputable = lengthComputable && request_1._lengthComputable;
                        loaded += request_1._loaded;
                        total += request_1._total;
                      }
                      this._progressCallback({
                        lengthComputable,
                        loaded,
                        total: lengthComputable ? total : 0
                      });
                    };
                    GLTFFileLoader2.prototype._validate = function(scene, data, rootUrl, fileName) {
                      var _this = this;
                      if (rootUrl === void 0) {
                        rootUrl = "";
                      }
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      if (!this.validate) {
                        return;
                      }
                      this._startPerformanceCounter("Validate JSON");
                      _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation.ValidateAsync(data, rootUrl, fileName, function(uri) {
                        return _this.preprocessUrlAsync(rootUrl + uri).then(function(url) {
                          return scene._loadFileAsync(url, void 0, true, true).then(function(data2) {
                            return new Uint8Array(data2, 0, data2.byteLength);
                          });
                        });
                      }).then(function(result) {
                        _this._endPerformanceCounter("Validate JSON");
                        _this.onValidatedObservable.notifyObservers(result);
                        _this.onValidatedObservable.clear();
                      }, function(reason) {
                        _this._endPerformanceCounter("Validate JSON");
                        babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Failed to validate: ".concat(reason.message));
                        _this.onValidatedObservable.clear();
                      });
                    };
                    GLTFFileLoader2.prototype._getLoader = function(loaderData) {
                      var asset = loaderData.json.asset || {};
                      this._log("Asset version: ".concat(asset.version));
                      asset.minVersion && this._log("Asset minimum version: ".concat(asset.minVersion));
                      asset.generator && this._log("Asset generator: ".concat(asset.generator));
                      var version = GLTFFileLoader2._parseVersion(asset.version);
                      if (!version) {
                        throw new Error("Invalid version: " + asset.version);
                      }
                      if (asset.minVersion !== void 0) {
                        var minVersion = GLTFFileLoader2._parseVersion(asset.minVersion);
                        if (!minVersion) {
                          throw new Error("Invalid minimum version: " + asset.minVersion);
                        }
                        if (GLTFFileLoader2._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
                          throw new Error("Incompatible minimum version: " + asset.minVersion);
                        }
                      }
                      var createLoaders = {
                        1: GLTFFileLoader2._CreateGLTF1Loader,
                        2: GLTFFileLoader2._CreateGLTF2Loader
                      };
                      var createLoader = createLoaders[version.major];
                      if (!createLoader) {
                        throw new Error("Unsupported version: " + asset.version);
                      }
                      return createLoader(this);
                    };
                    GLTFFileLoader2.prototype._parseJson = function(json) {
                      this._startPerformanceCounter("Parse JSON");
                      this._log("JSON length: ".concat(json.length));
                      var parsed = JSON.parse(json);
                      this._endPerformanceCounter("Parse JSON");
                      return parsed;
                    };
                    GLTFFileLoader2.prototype._unpackBinaryAsync = function(dataReader) {
                      var _this = this;
                      this._startPerformanceCounter("Unpack Binary");
                      return dataReader.loadAsync(20).then(function() {
                        var Binary = {
                          Magic: 1179937895
                        };
                        var magic = dataReader.readUint32();
                        if (magic !== Binary.Magic) {
                          throw new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.RuntimeError("Unexpected magic: " + magic, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes.GLTFLoaderUnexpectedMagicError);
                        }
                        var version = dataReader.readUint32();
                        if (_this.loggingEnabled) {
                          _this._log("Binary version: ".concat(version));
                        }
                        var length = dataReader.readUint32();
                        if (!_this.useRangeRequests && length !== dataReader.buffer.byteLength) {
                          babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Length in header does not match actual data length: ".concat(length, " != ").concat(dataReader.buffer.byteLength));
                        }
                        var unpacked;
                        switch (version) {
                          case 1: {
                            unpacked = _this._unpackBinaryV1Async(dataReader, length);
                            break;
                          }
                          case 2: {
                            unpacked = _this._unpackBinaryV2Async(dataReader, length);
                            break;
                          }
                          default: {
                            throw new Error("Unsupported version: " + version);
                          }
                        }
                        _this._endPerformanceCounter("Unpack Binary");
                        return unpacked;
                      });
                    };
                    GLTFFileLoader2.prototype._unpackBinaryV1Async = function(dataReader, length) {
                      var ContentFormat = {
                        JSON: 0
                      };
                      var contentLength = dataReader.readUint32();
                      var contentFormat = dataReader.readUint32();
                      if (contentFormat !== ContentFormat.JSON) {
                        throw new Error("Unexpected content format: ".concat(contentFormat));
                      }
                      var bodyLength = length - dataReader.byteOffset;
                      var data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
                      if (bodyLength !== 0) {
                        var startByteOffset_1 = dataReader.byteOffset;
                        data.bin = {
                          readAsync: function(byteOffset, byteLength) {
                            return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength);
                          },
                          byteLength: bodyLength
                        };
                      }
                      return Promise.resolve(data);
                    };
                    GLTFFileLoader2.prototype._unpackBinaryV2Async = function(dataReader, length) {
                      var _this = this;
                      var ChunkFormat = {
                        JSON: 1313821514,
                        BIN: 5130562
                      };
                      var chunkLength = dataReader.readUint32();
                      var chunkFormat = dataReader.readUint32();
                      if (chunkFormat !== ChunkFormat.JSON) {
                        throw new Error("First chunk format is not JSON");
                      }
                      if (dataReader.byteOffset + chunkLength === length) {
                        return dataReader.loadAsync(chunkLength).then(function() {
                          return { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
                        });
                      }
                      return dataReader.loadAsync(chunkLength + 8).then(function() {
                        var data = { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
                        var readAsync2 = function() {
                          var chunkLength2 = dataReader.readUint32();
                          var chunkFormat2 = dataReader.readUint32();
                          switch (chunkFormat2) {
                            case ChunkFormat.JSON: {
                              throw new Error("Unexpected JSON chunk");
                            }
                            case ChunkFormat.BIN: {
                              var startByteOffset_2 = dataReader.byteOffset;
                              data.bin = {
                                readAsync: function(byteOffset, byteLength) {
                                  return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);
                                },
                                byteLength: chunkLength2
                              };
                              dataReader.skipBytes(chunkLength2);
                              break;
                            }
                            default: {
                              dataReader.skipBytes(chunkLength2);
                              break;
                            }
                          }
                          if (dataReader.byteOffset !== length) {
                            return dataReader.loadAsync(8).then(readAsync2);
                          }
                          return Promise.resolve(data);
                        };
                        return readAsync2();
                      });
                    };
                    GLTFFileLoader2._parseVersion = function(version) {
                      if (version === "1.0" || version === "1.0.1") {
                        return {
                          major: 1,
                          minor: 0
                        };
                      }
                      var match = (version + "").match(/^(\d+)\.(\d+)/);
                      if (!match) {
                        return null;
                      }
                      return {
                        major: parseInt(match[1]),
                        minor: parseInt(match[2])
                      };
                    };
                    GLTFFileLoader2._compareVersion = function(a, b) {
                      if (a.major > b.major) {
                        return 1;
                      }
                      if (a.major < b.major) {
                        return -1;
                      }
                      if (a.minor > b.minor) {
                        return 1;
                      }
                      if (a.minor < b.minor) {
                        return -1;
                      }
                      return 0;
                    };
                    GLTFFileLoader2.prototype._logOpen = function(message) {
                      this._log(message);
                      this._logIndentLevel++;
                    };
                    GLTFFileLoader2.prototype._logClose = function() {
                      --this._logIndentLevel;
                    };
                    GLTFFileLoader2.prototype._logEnabled = function(message) {
                      var spaces = GLTFFileLoader2._logSpaces.substring(0, this._logIndentLevel * 2);
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Log("".concat(spaces).concat(message));
                    };
                    GLTFFileLoader2.prototype._logDisabled = function(message) {
                    };
                    GLTFFileLoader2.prototype._startPerformanceCounterEnabled = function(counterName) {
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.StartPerformanceCounter(counterName);
                    };
                    GLTFFileLoader2.prototype._startPerformanceCounterDisabled = function(counterName) {
                    };
                    GLTFFileLoader2.prototype._endPerformanceCounterEnabled = function(counterName) {
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.EndPerformanceCounter(counterName);
                    };
                    GLTFFileLoader2.prototype._endPerformanceCounterDisabled = function(counterName) {
                    };
                    GLTFFileLoader2.IncrementalLoading = true;
                    GLTFFileLoader2.HomogeneousCoordinates = false;
                    GLTFFileLoader2._logSpaces = "                                ";
                    return GLTFFileLoader2;
                  }(GLTFLoaderOptions)
                );
                (0, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new GLTFFileLoader());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/glTFValidation.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/glTFValidation.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFValidation: () => (
                    /* binding */
                    GLTFValidation
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/tools */
                  "babylonjs/Misc/tools"
                );
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);
                function validateAsync(data, rootUrl, fileName, getExternalResource) {
                  var options = {
                    externalResourceFunction: getExternalResource
                  };
                  if (fileName) {
                    options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
                  }
                  return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);
                }
                function workerFunc() {
                  var pendingExternalResources = [];
                  onmessage = function(message) {
                    var data = message.data;
                    switch (data.id) {
                      case "init": {
                        importScripts(data.url);
                        break;
                      }
                      case "validate": {
                        validateAsync(data.data, data.rootUrl, data.fileName, function(uri) {
                          return new Promise(function(resolve, reject) {
                            var index = pendingExternalResources.length;
                            pendingExternalResources.push({ resolve, reject });
                            postMessage({ id: "getExternalResource", index, uri });
                          });
                        }).then(function(value) {
                          postMessage({ id: "validate.resolve", value });
                        }, function(reason) {
                          postMessage({ id: "validate.reject", reason });
                        });
                        break;
                      }
                      case "getExternalResource.resolve": {
                        pendingExternalResources[data.index].resolve(data.value);
                        break;
                      }
                      case "getExternalResource.reject": {
                        pendingExternalResources[data.index].reject(data.reason);
                        break;
                      }
                    }
                  };
                }
                var GLTFValidation = (
                  /** @class */
                  function() {
                    function GLTFValidation2() {
                    }
                    GLTFValidation2.ValidateAsync = function(data, rootUrl, fileName, getExternalResource) {
                      var _this = this;
                      if (typeof Worker === "function") {
                        return new Promise(function(resolve, reject) {
                          var workerContent = "".concat(validateAsync, "(").concat(workerFunc, ")()");
                          var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
                          var worker = new Worker(workerBlobUrl);
                          var onError = function(error) {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            reject(error);
                          };
                          var onMessage = function(message) {
                            var data2 = message.data;
                            switch (data2.id) {
                              case "getExternalResource": {
                                getExternalResource(data2.uri).then(function(value) {
                                  worker.postMessage({ id: "getExternalResource.resolve", index: data2.index, value }, [value.buffer]);
                                }, function(reason) {
                                  worker.postMessage({ id: "getExternalResource.reject", index: data2.index, reason });
                                });
                                break;
                              }
                              case "validate.resolve": {
                                worker.removeEventListener("error", onError);
                                worker.removeEventListener("message", onMessage);
                                resolve(data2.value);
                                worker.terminate();
                                break;
                              }
                              case "validate.reject": {
                                worker.removeEventListener("error", onError);
                                worker.removeEventListener("message", onMessage);
                                reject(data2.reason);
                                worker.terminate();
                              }
                            }
                          };
                          worker.addEventListener("error", onError);
                          worker.addEventListener("message", onMessage);
                          worker.postMessage({ id: "init", url: babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.GetBabylonScriptURL(_this.Configuration.url) });
                          if (ArrayBuffer.isView(data)) {
                            var slicedData = data.slice();
                            worker.postMessage({ id: "validate", data: slicedData, rootUrl, fileName }, [slicedData.buffer]);
                          } else {
                            worker.postMessage({ id: "validate", data, rootUrl, fileName });
                          }
                        });
                      } else {
                        if (!this._LoadScriptPromise) {
                          this._LoadScriptPromise = babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadBabylonScriptAsync(this.Configuration.url);
                        }
                        return this._LoadScriptPromise.then(function() {
                          return validateAsync(data, rootUrl, fileName, getExternalResource);
                        });
                      }
                    };
                    GLTFValidation2.Configuration = {
                      url: "".concat(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools._DefaultCdnUrl, "/gltf_validator.js")
                    };
                    return GLTFValidation2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/index.ts": (
              /*!**********************************************!*\
                !*** ../../../dev/loaders/src/glTF/index.ts ***!
                \**********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport module object */
                    _1_0_index__WEBPACK_IMPORTED_MODULE_2__
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport module object */
                    _2_0_index__WEBPACK_IMPORTED_MODULE_3__
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation
                  )
                  /* harmony export */
                });
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                var _1_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./1.0/index */
                  "../../../dev/loaders/src/glTF/1.0/index.ts"
                );
                var _2_0_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./2.0/index */
                  "../../../dev/loaders/src/glTF/2.0/index.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/index.ts": (
              /*!*****************************************!*\
                !*** ../../../dev/loaders/src/index.ts ***!
                \*****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation
                  ),
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoader
                  ),
                  /* harmony export */
                  SPLATFileLoader: () => (
                    /* reexport safe */
                    _SPLAT_index__WEBPACK_IMPORTED_MODULE_3__.SPLATFileLoader
                  ),
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    _STL_index__WEBPACK_IMPORTED_MODULE_2__.STLFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.SolidParser
                  )
                  /* harmony export */
                });
                var _glTF_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTF/index */
                  "../../../dev/loaders/src/glTF/index.ts"
                );
                var _OBJ_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./OBJ/index */
                  "../../../dev/loaders/src/OBJ/index.ts"
                );
                var _STL_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./STL/index */
                  "../../../dev/loaders/src/STL/index.ts"
                );
                var _SPLAT_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./SPLAT/index */
                  "../../../dev/loaders/src/SPLAT/index.ts"
                );
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF.ts": (
              /*!******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF.ts ***!
                \******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation
                  )
                  /* harmony export */
                });
                var loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! loaders/glTF/glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  for (var key in loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__) {
                    globalObject.BABYLON[key] = loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__[key];
                  }
                  for (var key in loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__) {
                    globalObject.BABYLON[key] = loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF1.ts": (
              /*!*******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF1.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport module object */
                    loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__
                  )
                  /* harmony export */
                });
                var loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/1.0/index */
                  "../../../dev/loaders/src/glTF/1.0/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  globalObject.BABYLON.GLTF1 = globalObject.BABYLON.GLTF1 || {};
                  for (var key in loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__) {
                    globalObject.BABYLON.GLTF1[key] = loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF2.ts": (
              /*!*******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF2.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport module object */
                    loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__
                  )
                  /* harmony export */
                });
                var loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/Extensions/index */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts"
                );
                var loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts"
                );
                var loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/index */
                  "../../../dev/loaders/src/glTF/2.0/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  var BABYLON_1 = globalObject.BABYLON;
                  BABYLON_1.GLTF2 = BABYLON_1.GLTF2 || {};
                  BABYLON_1.GLTF2.Loader = BABYLON_1.GLTF2.Loader || {};
                  BABYLON_1.GLTF2.Loader.Extensions = BABYLON_1.GLTF2.Loader.Extensions || {};
                  var keys = [];
                  for (var key in loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__) {
                    BABYLON_1.GLTF2.Loader.Extensions[key] = loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    keys.push(key);
                  }
                  for (var key in loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__) {
                    BABYLON_1.GLTF2.Loader[key] = loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__[key];
                    keys.push(key);
                  }
                  for (var key in loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__) {
                    if (keys.indexOf(key) > -1) {
                      continue;
                    }
                    BABYLON_1.GLTF2[key] = loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts": (
              /*!***************************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-objFileLoader.ts ***!
                \***************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser
                  )
                  /* harmony export */
                });
                var loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/OBJ/index */
                  "../../../dev/loaders/src/OBJ/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  for (var key in loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__) {
                    if (!globalObject.BABYLON[key]) {
                      globalObject.BABYLON[key] = loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    }
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts": (
              /*!***************************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts ***!
                \***************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  )
                  /* harmony export */
                });
                var loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/STL/index */
                  "../../../dev/loaders/src/STL/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  for (var key in loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__) {
                    if (!globalObject.BABYLON[key]) {
                      globalObject.BABYLON[key] = loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    }
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy.ts": (
              /*!*************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy.ts ***!
                \*************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation
                  ),
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader
                  ),
                  /* harmony export */
                  SPLATFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.SPLATFileLoader
                  ),
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser
                  )
                  /* harmony export */
                });
                var loaders_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/index */
                  "../../../dev/loaders/src/index.ts"
                );
                var _legacy_glTF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./legacy-glTF */
                  "../../../lts/loaders/src/legacy/legacy-glTF.ts"
                );
                var _legacy_glTF1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./legacy-glTF1 */
                  "../../../lts/loaders/src/legacy/legacy-glTF1.ts"
                );
                var _legacy_glTF2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./legacy-glTF2 */
                  "../../../lts/loaders/src/legacy/legacy-glTF2.ts"
                );
                var _legacy_objFileLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./legacy-objFileLoader */
                  "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts"
                );
                var _legacy_stlFileLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./legacy-stlFileLoader */
                  "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts"
                );
              }
            ),
            /***/
            "babylonjs/Misc/tools": (
              /*!****************************************************************************************************!*\
                !*** external {"root":"BABYLON","commonjs":"babylonjs","commonjs2":"babylonjs","amd":"babylonjs"} ***!
                \****************************************************************************************************/
              /***/
              (module2) => {
                module2.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_tools__;
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
            var leafPrototypes;
            __webpack_require__.t = function(value, mode) {
              if (mode & 1) value = this(value);
              if (mode & 8) return value;
              if (typeof value === "object" && value) {
                if (mode & 4 && value.__esModule) return value;
                if (mode & 16 && typeof value.then === "function") return value;
              }
              var ns = /* @__PURE__ */ Object.create(null);
              __webpack_require__.r(ns);
              var def = {};
              leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
              for (var current = mode & 2 && value; typeof current == "object" && !~leafPrototypes.indexOf(current); current = getProto(current)) {
                Object.getOwnPropertyNames(current).forEach((key) => def[key] = () => value[key]);
              }
              def["default"] = () => value;
              __webpack_require__.d(ns, def);
              return ns;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object") return window;
              }
            }();
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = {};
          (() => {
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              "default": () => __WEBPACK_DEFAULT_EXPORT__,
              /* harmony export */
              loaders: () => (
                /* reexport module object */
                _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__
              )
              /* harmony export */
            });
            var _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! @lts/loaders/legacy/legacy */
              "../../../lts/loaders/src/legacy/legacy.ts"
            );
            const __WEBPACK_DEFAULT_EXPORT__ = _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__;
          })();
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_babylonjs_loaders();
/*! Bundled license information:

babylonjs-loaders/babylonjs.loaders.js:
  (*!**********************!*\
    !*** ./src/index.ts ***!
    \**********************)
*/
//# sourceMappingURL=babylonjs-loaders.js.map
