import{_ as h,D as p,c as t,I as n,w as l,a as s,j as i,a4 as e,o as k}from"./chunks/framework.Br-KnHaE.js";const r="/assets/normalChange.BrxzNR84.png",N=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"other/light.md","filePath":"other/light.md"}'),E={name:"other/light.md"},d=i("h2",{id:"漫反射",tabindex:"-1"},[s("漫反射 "),i("a",{class:"header-anchor",href:"#漫反射","aria-label":'Permalink to "漫反射"'},"​")],-1),o=i("p",null,"在漫反射中，反射光的颜色取决于入射光的颜色、表面的基底色、入射光与表面形成的入射角。我们将入射角定义为入射光与表面的法线形成的夹角，并用θ表示，那么漫反射光的颜色可以根据下面的式子计算得到：",-1),g=i("br",null,null,-1),c=i("br",null,null,-1),y=i("h2",{id:"环境反射",tabindex:"-1"},[s("环境反射 "),i("a",{class:"header-anchor",href:"#环境反射","aria-label":'Permalink to "环境反射"'},"​")],-1),A=i("p",null,"环境反射是针对环境光而言的。在环境反射中，反射光的方向可以认为就是入射光的反方向。有余环境光照射物体的方式就是各方面均匀、强度相等的，所以反射光也是各向均匀的，我们可以这样描述：",-1),F=i("h2",{id:"最终颜色",tabindex:"-1"},[s("最终颜色 "),i("a",{class:"header-anchor",href:"#最终颜色","aria-label":'Permalink to "最终颜色"'},"​")],-1),D=i("h2",{id:"运动中的物体的光照效果",tabindex:"-1"},[s("运动中的物体的光照效果 "),i("a",{class:"header-anchor",href:"#运动中的物体的光照效果","aria-label":'Permalink to "运动中的物体的光照效果"'},"​")],-1),u=i("p",null,[s("很多场景中，物体有可能会动，观察者的视角也很有可能会改变，必须考虑这种情况。首先，先看一下物体变动时，法向量的情况："),i("br"),i("img",{src:r,alt:"image"}),s(" 平移变换不会改变法向量，因为平移不会改变物体的方向。")],-1),v=i("p",null,"旋转变换会改变法向量，因为旋转改变了物体的方向。",-1),_=i("p",null,"缩放变换对法向量的影响较为复杂。如图所见，最右侧的图显示了立方体先旋转了45度，再在y轴上拉伸至原来的2倍的情况。此时法向量改变了，因为表面的朝向改变了。但是，如果缩放比例在所有的轴上都一致的话，那么法向量就不会变化。最后，即使物体在某些轴上的缩放比例并不一致，法向量也并不一定会变化，比如将最左侧图中的立方体在y轴方向上拉伸两倍，法向量就不会变化。",-1),m=i("p",null,"所以，为了处理这种情况，矩阵中引入了一种魔法矩阵：逆转置矩阵。",-1),f=e("",28);function C(b,x,B,q,P,S){const a=p("font");return k(),t("div",null,[d,o,n(a,{color:"red"},{default:l(()=>[s("漫反射光颜色 = 入射光颜色 x 表面基底色 x cosθ")]),_:1}),s(),i("p",null,[s("可以通过计算两个矢量的"),n(a,{color:"red"},{default:l(()=>[s("点积")]),_:1}),s("，来计算着两个矢量的夹角余弦值cosθ")]),n(a,{color:"red"},{default:l(()=>[s("漫反射光颜色 = 入射光颜色 x 表面基底色 x (光线方向 · 法线方向)")]),_:1}),s(),i("p",null,[s("这里有两点需要注意："),g,s(" （1）光线方向矢量和表面法线矢量的长度必须为1，否则反射光的颜色就会过暗或过亮。将一个矢量的长度调整为1，同时保持方向不变的过程称之为归一化。GLSL ES提供了内置的归一化函数，可以直接使用。"),c,s(" （2）"),n(a,{color:"orange"},{default:l(()=>[s("这里所谓的“光线方向”，实际上是入射方向的反方向，即从入射点指向光源方向（因为这样，该方向与法线方向的夹角才是入射角）")]),_:1})]),y,A,n(a,{color:"red"},{default:l(()=>[s("环境发射光颜色 = 入射光颜色 x 表面基底色")]),_:1}),s(),F,n(a,{color:"red"},{default:l(()=>[s("表面的反射光颜色 = 漫反射光颜色 + 漫反射光颜色")]),_:1}),s(),D,u,v,_,m,n(a,{color:"red"},{default:l(()=>[s("逆转置矩阵由矩阵先逆后转置，或者先转置后逆来得出。")]),_:1}),s(),f])}const j=h(E,[["render",C]]);export{N as __pageData,j as default};
