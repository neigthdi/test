import{_ as r,D as c,c as d,I as a,w as s,a as e,j as o,a4 as l,o as n}from"./chunks/framework.Br-KnHaE.js";const i="/assets/normalChange.BrxzNR84.png",$=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"other/light.md","filePath":"other/light.md"}'),_={name:"other/light.md"},p=o("h2",{id:"漫反射",tabindex:"-1"},[e("漫反射 "),o("a",{class:"header-anchor",href:"#漫反射","aria-label":'Permalink to "漫反射"'},"​")],-1),h=o("p",null,"在漫反射中，反射光的颜色取决于入射光的颜色、表面的基底色、入射光与表面形成的入射角。我们将入射角定义为入射光与表面的法线形成的夹角，并用θ表示，那么漫反射光的颜色可以根据下面的式子计算得到：",-1),u=o("br",null,null,-1),b=o("br",null,null,-1),f=o("h2",{id:"环境反射",tabindex:"-1"},[e("环境反射 "),o("a",{class:"header-anchor",href:"#环境反射","aria-label":'Permalink to "环境反射"'},"​")],-1),m=o("p",null,"环境反射是针对环境光而言的。在环境反射中，反射光的方向可以认为就是入射光的反方向。有余环境光照射物体的方式就是各方面均匀、强度相等的，所以反射光也是各向均匀的，我们可以这样描述：",-1),x=o("h2",{id:"最终颜色",tabindex:"-1"},[e("最终颜色 "),o("a",{class:"header-anchor",href:"#最终颜色","aria-label":'Permalink to "最终颜色"'},"​")],-1),A=o("h2",{id:"运动中的物体的光照效果",tabindex:"-1"},[e("运动中的物体的光照效果 "),o("a",{class:"header-anchor",href:"#运动中的物体的光照效果","aria-label":'Permalink to "运动中的物体的光照效果"'},"​")],-1),S=o("p",null,[e("很多场景中，物体有可能会动，观察者的视角也很有可能会改变，必须考虑这种情况。首先，先看一下物体变动时，法向量的情况："),o("br"),o("img",{src:i,alt:"image"}),e(" 平移变换不会改变法向量，因为平移不会改变物体的方向。")],-1),g=o("p",null,"旋转变换会改变法向量，因为旋转改变了物体的方向。",-1),P=o("p",null,"缩放变换对法向量的影响较为复杂。如图所见，最右侧的图显示了立方体先旋转了45度，再在y轴上拉伸至原来的2倍的情况。此时法向量改变了，因为表面的朝向改变了。但是，如果缩放比例在所有的轴上都一致的话，那么法向量就不会变化。最后，即使物体在某些轴上的缩放比例并不一致，法向量也并不一定会变化，比如将最左侧图中的立方体在y轴方向上拉伸两倍，法向量就不会变化。",-1),q=o("p",null,"所以，为了处理这种情况，矩阵中引入了一种魔法矩阵：逆转置矩阵。",-1),k=l('<h3 id="逆矩阵" tabindex="-1">逆矩阵 <a class="header-anchor" href="#逆矩阵" aria-label="Permalink to &quot;逆矩阵&quot;">​</a></h3><p><code>逆矩阵本身并不直接表示缩放，但它在某些情况下可以用于实现与缩放相反的变换。</code></p><p>逆矩阵的定义：逆矩阵是指一个矩阵的逆元，即如果存在一个矩阵B，使得矩阵A乘以B等于单位矩阵I（在相应的数域上），则称B为A的逆矩阵，记为A&quot;。逆矩阵的一个重要性质是，它可以将原矩阵所表示的变换“撤销”或“反转”。</p><p>缩放矩阵的定义：缩放矩阵是一个对角矩阵，其对角线上的元素表示在各个维度上的缩放因子。</p><p><code>矩阵S = </code><br> |sx, 0|<br> |0, sy|</p><p>逆矩阵与缩放矩阵的关系：对于缩放矩阵S，其逆矩阵S&quot;可以通过将对角线上的缩放因子取倒数来得到</p><p><code>矩阵S&quot; = </code><br> |1/sx, 0|<br> |0, 1/sy|</p><p>这个逆矩阵实际上表示了一个与原缩放相反的变换。如果原缩放矩阵S将某个向量在x轴和y轴上分别放大了<code>sx</code>和<code>sy</code>倍，那么逆矩阵S&quot;就会将这个向量在x轴和y轴上分别缩小到原来的<code>1/sx</code>和<code>1/sy</code>倍。</p><p>因此，虽然逆矩阵本身不直接表示缩放，但它可以用于实现与缩放相反的变换，从而在某些情况下可以看作是一种“反向缩放”。</p><h3 id="转置矩阵" tabindex="-1">转置矩阵 <a class="header-anchor" href="#转置矩阵" aria-label="Permalink to &quot;转置矩阵&quot;">​</a></h3><p>转置矩阵在数学和线性代数中扮演着重要的角色，<code>但直接将其与“旋转”联系起来并不总是准确的，因为转置矩阵主要代表的是矩阵行与列的互换，而不是几何意义上的旋转</code>。然而，<code>在特定的上下文中，特别是当涉及到正交矩阵时，转置矩阵与旋转操作之间确实存在一种紧密的联系，因为旋转矩阵是正交矩阵的一种特例</code>。</p><p>转置矩阵的基本定义：给定一个矩阵 A，其转置矩阵 A(t) 是通过将 A 的行与列互换得到的。具体来说，如果 A 是一个 m×n 矩阵，那么 A(t) 是一个 n×m 矩阵。</p><p>正交矩阵与旋转：正交矩阵是一种特殊的方阵，其行向量和列向量都是单位向量且两两正交（即点积为零）。正交矩阵的一个重要性质是其转置矩阵等于其逆矩阵，即 A(t) = A&quot; 。</p><p>在二维和三维空间中，正交矩阵可以表示旋转和/或反射操作。例如，在二维空间中，旋转角度 θ 的正交矩阵可以表示为：</p><p><code>Rθ=</code><br> |cos(θ), −sin(θ)|<br> |sin(θ), cos(θ) |</p><p>这个矩阵的转置矩阵是：</p><p><code>Rθ(t)=</code><br> |cos(θ), sin(θ)|<br> |-sin(θ), cos(θ) |</p><p>值得注意的是，这个转置矩阵实际上表示的是旋转角度 −θ 的操作，因为旋转矩阵的逆矩阵等于其转置矩阵且表示相反的旋转。</p><p>虽然转置矩阵本身并不直接表示旋转，但在正交矩阵的上下文中，转置矩阵与旋转操作之间存在紧密的联系。具体来说，正交矩阵的转置矩阵等于其逆矩阵，且在某些情况下（如二维旋转矩阵），这个逆矩阵可以解释为相反的旋转操作。因此，在正交矩阵的语境下讨论转置矩阵与旋转的关系是合理的，但在更一般的矩阵理论中，这种关系并不成立。</p>',19);function y(B,N,T,V,C,I){const t=c("font");return n(),d("div",null,[p,h,a(t,{color:"red"},{default:s(()=>[e("漫反射光颜色 = 入射光颜色 x 表面基底色 x cosθ")]),_:1}),e(),o("p",null,[e("可以通过计算两个矢量的"),a(t,{color:"red"},{default:s(()=>[e("点积")]),_:1}),e("，来计算着两个矢量的夹角余弦值cosθ")]),a(t,{color:"red"},{default:s(()=>[e("漫反射光颜色 = 入射光颜色 x 表面基底色 x (光线方向 · 法线方向)")]),_:1}),e(),o("p",null,[e("这里有两点需要注意："),u,e(" （1）光线方向矢量和表面法线矢量的长度必须为1，否则反射光的颜色就会过暗或过亮。将一个矢量的长度调整为1，同时保持方向不变的过程称之为归一化。GLSL ES提供了内置的归一化函数，可以直接使用。"),b,e(" （2）"),a(t,{color:"orange"},{default:s(()=>[e("这里所谓的“光线方向”，实际上是入射方向的反方向，即从入射点指向光源方向（因为这样，该方向与法线方向的夹角才是入射角）")]),_:1})]),f,m,a(t,{color:"red"},{default:s(()=>[e("环境发射光颜色 = 入射光颜色 x 表面基底色")]),_:1}),e(),x,a(t,{color:"red"},{default:s(()=>[e("表面的反射光颜色 = 漫反射光颜色 + 漫反射光颜色")]),_:1}),e(),A,S,g,P,q,a(t,{color:"red"},{default:s(()=>[e("逆转置矩阵由矩阵先逆后转置，或者先转置后逆来得出。")]),_:1}),e(),k])}const v=r(_,[["render",y]]);export{$ as __pageData,v as default};
